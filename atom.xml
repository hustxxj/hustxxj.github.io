<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江江的小跟班.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hustxxj.github.io/"/>
  <updated>2020-02-26T01:53:18.542Z</updated>
  <id>http://hustxxj.github.io/</id>
  
  <author>
    <name>Xuxuejie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer——09.变态跳台阶</title>
    <link href="http://hustxxj.github.io/2020/02/25/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9409.%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://hustxxj.github.io/2020/02/25/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9409.%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2020-02-25T13:15:36.000Z</published>
    <updated>2020-02-26T01:53:18.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>列出前几项可以发现规律：<br>1-1(1);<br>2-1(1):2(1)-(2);<br>3-1(2):2(1):3(1)-(4);<br>4-1(4):2(2):3(1):4(1)-(8);<br>5-1(8):2(4):3(2):4(1):5(1)-(16);</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        return pow(2,number-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树）：226-翻转二叉树"><a href="#LeetCode练习（树）：226-翻转二叉树" class="headerlink" title="LeetCode练习（树）：226.翻转二叉树"></a><strong>LeetCode练习（树）：226.翻转二叉树</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>翻转一棵树<br><code><img src="/2020/02/25/剑指Offer——09.变态跳台阶/09_226.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><ol><li><p>迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode* m=temp-&gt;left;</span><br><span class="line">                temp-&gt;left=temp-&gt;right;</span><br><span class="line">                temp-&gt;right=m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        invert(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void invert(TreeNode* root) //输入根节点，翻转二叉树</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">           return;</span><br><span class="line">        TreeNode* temp=root-&gt;left;</span><br><span class="line">        root-&gt;left=root-&gt;right;</span><br><span class="line">        root-&gt;right=temp;</span><br><span class="line">        invert(root-&gt;left);</span><br><span class="line">        invert(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（树）：111-二叉树的最小深度"><a href="#LeetCode练习（树）：111-二叉树的最小深度" class="headerlink" title="LeetCode练习（树）：111.二叉树的最小深度"></a><strong>LeetCode练习（树）：111.二叉树的最小深度</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>注意：最短路径不等于没有路径，本题和求最大深度有一定区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">          return 0;</span><br><span class="line"></span><br><span class="line">        int left=minDepth(root-&gt;left);</span><br><span class="line">        int right=minDepth(root-&gt;right);</span><br><span class="line">        int min;</span><br><span class="line">        if(root-&gt;left==nullptr || root-&gt;right==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            min=(left==0)?right+1:left+1;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            min=(left&gt;=right)?right+1:left+1;</span><br><span class="line">        &#125; </span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（树）：107-二叉树的层次遍历II"><a href="#LeetCode练习（树）：107-二叉树的层次遍历II" class="headerlink" title="LeetCode练习（树）：107.二叉树的层次遍历II"></a><strong>LeetCode练习（树）：107.二叉树的层次遍历II</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，返回其节点值自底向上的层次遍历。即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; vec;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                vec.push_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer--08.跳台阶</title>
    <link href="http://hustxxj.github.io/2020/02/24/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9408.%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://hustxxj.github.io/2020/02/24/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9408.%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2020-02-24T04:17:23.000Z</published>
    <updated>2020-02-24T13:03:39.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>1…1<br>2…2(1,1;2)<br>3…3(1,2;2,1)2+1=3<br>4…4(1,3;2,2)3+2=5<br>5…5(1,4;2,3)5+3=8<br>6…6(1,5;2,4)8+5=13</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(number==2)</span><br><span class="line">        &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a=1,b=2;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=3;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树-递归）：104-二叉树的最大深度"><a href="#LeetCode练习（树-递归）：104-二叉树的最大深度" class="headerlink" title="LeetCode练习（树/递归）：104.二叉树的最大深度"></a><strong>LeetCode练习（树/递归）：104.二叉树的最大深度</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li><p>递归思路<br>maxDepth(root)：输入根节点，输出根节点到最远叶子节点的深度<br>maxDepth(root-&gt;left)：输入左叶子节点，返回左叶子节点到其最远叶子节点的深度<br>maxDepth(root-&gt;right):输入右叶子节点，返回右叶子节点到其最远叶子节点的深度<br>maxDepth(root)=max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int left=maxDepth(root-&gt;left);</span><br><span class="line">        int right=maxDepth(root-&gt;right);</span><br><span class="line">        int max=(left&gt;=right)?left:right;</span><br><span class="line">        return max+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>迭代思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        int depth=0;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode*  temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                  q.push(temp-&gt;left);</span><br><span class="line">                if(temp-&gt;right != nullptr)</span><br><span class="line">                  q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（树-递归）：101-对称二叉树"><a href="#LeetCode练习（树-递归）：101-对称二叉树" class="headerlink" title="LeetCode练习（树/递归）：101.对称二叉树"></a><strong>LeetCode练习（树/递归）：101.对称二叉树</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，检查它是否是镜像对称的。<br><code><img src="/2020/02/24/剑指Offer——08.跳台阶/08_101.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><ol><li><p>迭代实现<br>逐层迭代，每遍历完一层，比较vector内的数是否中心对称（出现空树用0补齐）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right==nullptr || root-&gt;left==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(root-&gt;right==nullptr &amp;&amp; root-&gt;left==nullptr)</span><br><span class="line">              return true;</span><br><span class="line">            else</span><br><span class="line">              return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        q.push(root);</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            for(int i=0;i&lt;(vec.size()/2);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(vec[i] != vec[vec.size()-1-i])</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vec.clear();</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                    vec.push_back(temp-&gt;left-&gt;val);</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    vec.push_back(0);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                    vec.push_back(temp-&gt;right-&gt;val);</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    vec.push_back(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>递归实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">          return true;</span><br><span class="line">        return issi(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool issi(TreeNode* left,TreeNode* right)   //输入两个节点，返回两节点是否对称</span><br><span class="line">    &#123;</span><br><span class="line">        if(left==nullptr &amp;&amp; right==nullptr)</span><br><span class="line">          return true;</span><br><span class="line">        if(left==nullptr || right==nullptr)</span><br><span class="line">          return false;</span><br><span class="line">        if(left-&gt;val!=right-&gt;val)</span><br><span class="line">          return false;</span><br><span class="line">        else</span><br><span class="line">          return issi(left-&gt;left,right-&gt;right)&amp;&amp;issi(right-&gt;left,left-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（数-迭代）：102-二叉树层次遍历"><a href="#LeetCode练习（数-迭代）：102-二叉树层次遍历" class="headerlink" title="LeetCode练习（数/迭代）：102.二叉树层次遍历"></a><strong>LeetCode练习（数/迭代）：102.二叉树层次遍历</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，返回其层次遍历的节点数。（即逐层的，从左到右访问所有节点）。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">           return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                temp.push_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left!=nullptr)</span><br><span class="line">                  q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right!=nullptr)</span><br><span class="line">                  q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer--07.斐波那契数列</title>
    <link href="http://hustxxj.github.io/2020/02/22/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9407.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/02/22/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9407.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2020-02-22T13:19:56.000Z</published>
    <updated>2020-02-23T07:15:15.290Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p>n&lt;=39 </p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><ol><li>递归实现</li><li>循环实现</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><p>循环实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n==1)</span><br><span class="line">            return 1;</span><br><span class="line">        int one=0,two=1,three=0;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            three=one+two;</span><br><span class="line">            one=two;</span><br><span class="line">            two=three;</span><br><span class="line">        &#125;</span><br><span class="line">        return three;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>递归实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n==1 || n==2)</span><br><span class="line">            return 1;</span><br><span class="line">        return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（递归）：687-最长同值路径"><a href="#LeetCode练习（递归）：687-最长同值路径" class="headerlink" title="LeetCode练习（递归）：687.最长同值路径"></a><strong>LeetCode练习（递归）：687.最长同值路径</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。这条路径可以经过也可以不经过根节点。两个节点之间的路径长度由它们之间的边数确定。<br><code><img src="/2020/02/22/剑指Offer——07.斐波那契数列/07_687.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：<br>利用递归的思想，构造一个函数，输入一个节点，返回从这个节点往下<em>与该节点值相同的最长路径值</em>。同时，每进行一次节点的查询，就更新一遍最长相同路径值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    int longestUnivaluePath(TreeNode* root) &#123;</span><br><span class="line">        backDepth(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int backDepth(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left=backDepth(root-&gt;left);</span><br><span class="line">        int right=backDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        left=(root-&gt;left!=NULL &amp;&amp; root-&gt;left-&gt;val==root-&gt;val)?left+1:0;</span><br><span class="line">        right=(root-&gt;right!=NULL &amp;&amp; root-&gt;right-&gt;val==root-&gt;val)?right+1:0;</span><br><span class="line"></span><br><span class="line">        res=(res &gt;= left+right)?res:(left+right);</span><br><span class="line"></span><br><span class="line">        return (left &gt;= right)?left:right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（递归）：面试题16-11-跳水板"><a href="#LeetCode练习（递归）：面试题16-11-跳水板" class="headerlink" title="LeetCode练习（递归）：面试题16.11.跳水板"></a><strong>LeetCode练习（递归）：面试题16.11.跳水板</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter,长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>例如：输入short=1,longer=2,k=3;输出：{3,4,5,6}</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>需要注意当shorter==longer的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; divingBoard(int shorter, int longer, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(k==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if(shorter==longer)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(k);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        int shorter_count=k,longer_count=0;</span><br><span class="line">        for(int i=k;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp=shorter*shorter_count+longer*longer_count;</span><br><span class="line">            shorter_count--;</span><br><span class="line">            longer_count++;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（递归）：779-第K个语法字符"><a href="#LeetCode练习（递归）：779-第K个语法字符" class="headerlink" title="LeetCode练习（递归）：779.第K个语法字符"></a><strong>LeetCode练习（递归）：779.第K个语法字符</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>第N排第K个，如果K&lt;=2^(N-2),则等于N-1排第K个<br>           如果k&gt;2^(N-2),k-2^(N-2),等于N-1排第k-2^(N-2)个取反<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int res=0;</span><br><span class="line">    int kthGrammar(int N, int K) &#123;</span><br><span class="line">        if(N==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(N==2)</span><br><span class="line">        &#123;</span><br><span class="line">            return (K==1)?0:1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(K&lt;=pow(2,N-2))</span><br><span class="line">        &#123;</span><br><span class="line">            res = kthGrammar(N-1,K);</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            K=K-pow(2,N-2);</span><br><span class="line">            res = !kthGrammar(N-1,K); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——06.旋转数组的最小数字</title>
    <link href="http://hustxxj.github.io/2020/02/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9406.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://hustxxj.github.io/2020/02/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9406.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-20T06:35:31.000Z</published>
    <updated>2020-02-21T02:28:48.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>把一个数组最开始的若干元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1.<br>NOTE：给出的所有元素都大于0，若数组的大小为0，请返回0。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>方法1：利用sort()进行从小到大排序，输出第一个元素。<br>方法2：逐个遍历元素，比较其与下一个元素的大小，若出现大于的情况则返回下一个元素。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><p>方法1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size() == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(rotateArray.begin(),rotateArray.end());</span><br><span class="line">        return rotateArray[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size() == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(rotateArray.size()==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return rotateArray[0];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int res;</span><br><span class="line">        for(int i=0;i&lt;rotateArray.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(rotateArray[i]&gt;rotateArray[i+1])</span><br><span class="line">            &#123;</span><br><span class="line">                res=rotateArray[i+1];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==rotateArray.size()-1)</span><br><span class="line">            &#123;</span><br><span class="line">                res=rotateArray[0];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（查找和排序）：56-合并区间"><a href="#LeetCode练习（查找和排序）：56-合并区间" class="headerlink" title="LeetCode练习（查找和排序）：56.合并区间"></a><strong>LeetCode练习（查找和排序）：56.合并区间</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给出一个区间的集合，请合并所有重叠的区间。<br><code><img src="/2020/02/20/剑指Offer——06.旋转数组的最小数字/6_56.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li><em>先将区间集合按左边界从小到大排序</em></li><li>逐个比较两两区间是否重叠<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        int len=intervals.size();</span><br><span class="line">        </span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return intervals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(intervals.begin(), intervals.end(),</span><br><span class="line">            [&amp;, this](vector&lt;int&gt; &amp;v1, vector&lt;int&gt; &amp;v2) &#123; return v1[0] &lt; v2[0];&#125;);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        res.push_back(intervals[0]);</span><br><span class="line">        int ptr=0;</span><br><span class="line">        for(int i=1;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //区间[a1,b1]和区间[a2,b2]有交集分为两种情况</span><br><span class="line">            //1.  a2&lt;=a1&lt;=b2</span><br><span class="line">            //2.  a2&lt;=b1&lt;=b2</span><br><span class="line">            if(res[ptr][0]&gt;=intervals[i][0] &amp;&amp; res[ptr][0]&lt;=intervals[i][1])</span><br><span class="line">            &#123;</span><br><span class="line">                res[ptr][0]=intervals[i][0];</span><br><span class="line">                if(res[ptr][1]&lt;=intervals[i][1])</span><br><span class="line">                &#123;</span><br><span class="line">                    res[ptr][1]=intervals[i][1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(res[ptr][0] &lt;= intervals[i][0] &amp;&amp; res[ptr][1]&gt;=intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                if(res[ptr][1]&lt;=intervals[i][1])</span><br><span class="line">                &#123;</span><br><span class="line">                    res[ptr][1]=intervals[i][1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（查找和排序）：75-颜色分类"><a href="#LeetCode练习（查找和排序）：75-颜色分类" class="headerlink" title="LeetCode练习（查找和排序）：75.颜色分类"></a><strong>LeetCode练习（查找和排序）：75.颜色分类</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个包含红色、白色和蓝色，一共n个元素的数组，原地对它们进行排序，使相同颜色的元素相邻，并按照红色、白色、蓝色顺利排列。此题中，我们使用整数0 ，1和2分别表示红色、白色和蓝色。<br>注意：不能使用代码库中的排序函数来解决这道题。<br>示例：输入：[2,0,2,1,1,0]，输出：[0,0,1,1,2,2]</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; temp0,temp1,temp2;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                temp0.push_back(0);</span><br><span class="line">            &#125;else if(nums[i]==1)</span><br><span class="line">            &#123;</span><br><span class="line">                temp1.push_back(1);</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                temp2.push_back(2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.clear();</span><br><span class="line">        nums.insert(nums.end(),temp0.begin(),temp0.end());</span><br><span class="line">        nums.insert(nums.end(),temp1.begin(),temp1.end());</span><br><span class="line">        nums.insert(nums.end(),temp2.begin(),temp2.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（查找和排序）：148-排序链表"><a href="#LeetCode练习（查找和排序）：148-排序链表" class="headerlink" title="LeetCode练习（查找和排序）：148.排序链表"></a><strong>LeetCode练习（查找和排序）：148.排序链表</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>在O(nlogn)时间复杂度和常数级空间复杂度下，对链表进行排序。<br><code><img src="/2020/02/20/剑指Offer——06.旋转数组的最小数字/6_148.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><em>(很重要)这里先介绍链表的两个常用操作：merge(l1,l2)和cut(l,n)</em></p><ol><li><p>merge(l1,l2)实现的是链表l1和l2的归并，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ListNode* merge(ListNode* l1,ListNode* l2)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* fakehead=new ListNode(0);</span><br><span class="line">ListNode* p=fakehead;</span><br><span class="line">while(l1 &amp;&amp; l2)</span><br><span class="line">&#123;</span><br><span class="line">if(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next=l1;</span><br><span class="line">p=l1;</span><br><span class="line">l1=l1-&gt;next;</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next=l2;</span><br><span class="line">p=l2;</span><br><span class="line">l2=l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(!l1)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next=l2;</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next=l1;</span><br><span class="line">&#125;</span><br><span class="line">return fakehead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cut(l,n)实现的是将链表l切掉前n个节点，返回后半部分的链表头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListNode* cut(ListNode* head,int n)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* p=head;</span><br><span class="line">while(--n &amp;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">if(p==nullptr)</span><br><span class="line">&#123;</span><br><span class="line">return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* next=p-&gt;next;</span><br><span class="line">p-&gt;next=nullptr;   //注意：不可以省略，为了切断链表</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>回到这道题，由于空间复杂度为常数，所以不能用递归，而是用归并排序来实现：<br>举个简单的例子：[4,3,1,7,8,9,2,11,5,6].<br>step=1: (3-&gt;4)-&gt;(1-&gt;7)-&gt;(8-&gt;9)-&gt;(2-&gt;11)-&gt;(5-&gt;6)<br>step=2: (1-&gt;3-&gt;4-&gt;7)-&gt;(2-&gt;8-&gt;9-&gt;11)-&gt;(5-&gt;6)<br>step=4: (1-&gt;2-&gt;3-&gt;4-&gt;7-&gt;8-&gt;9-&gt;11)-&gt;5-&gt;6<br>step=8: (1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;11)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        ListNode* fakehead=new ListNode(0);</span><br><span class="line">        fakehead-&gt;next = head;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        int length = 0;</span><br><span class="line">        while (p) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int size = 1; size &lt; length; size &lt;&lt;= 1) &#123;</span><br><span class="line">        //size依次等于1,2,4,8,16,.....</span><br><span class="line">            ListNode* cur = fakehead-&gt;next;</span><br><span class="line">            ListNode* tail = fakehead;</span><br><span class="line">            </span><br><span class="line">            while (cur) &#123;</span><br><span class="line">                ListNode* left = cur;</span><br><span class="line">                ListNode* right = cut(left, size);</span><br><span class="line">                cur = cut(right, size);</span><br><span class="line">                </span><br><span class="line">                tail-&gt;next = merge(left, right);</span><br><span class="line">                while (tail-&gt;next) &#123;</span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return fakehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* cut(ListNode* head,int n)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        while(--n &amp;&amp; p)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* next=p-&gt;next;</span><br><span class="line">        p-&gt;next=nullptr;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* merge(ListNode* l1,ListNode* l2)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* fakehead=new ListNode(0);</span><br><span class="line">        ListNode* p=fakehead;</span><br><span class="line">        while(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=l1;</span><br><span class="line">                p=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=l2;</span><br><span class="line">                p=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!l1)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=l2;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=l1;</span><br><span class="line">        &#125;</span><br><span class="line">        return fakehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;把一个数组最开始的若干元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——05.用两个栈实现队列</title>
    <link href="http://hustxxj.github.io/2020/02/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9405.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/02/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9405.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-02-17T15:44:50.000Z</published>
    <updated>2020-02-19T09:12:59.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>栈：先进后出<br>队列：先进先出，只能从队尾添加，队头弹出</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            while(stack1.size() != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                int temp=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（栈和队列）：20-有效的括号"><a href="#LeetCode练习（栈和队列）：20-有效的括号" class="headerlink" title="LeetCode练习（栈和队列）：20.有效的括号"></a><strong>LeetCode练习（栈和队列）：20.有效的括号</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个只包括‘（’，‘）’，‘{’，‘}’，‘[’，‘]’的字符串，判断字符串是否有效。<br>有效字符串需满足：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。注意控字符串可被认为是有效字符串。<br>示例：<br>输入：“()” ;输出：true<br>输入：“()[]{}”;输出：true<br>输入：“([)]”;输出：false</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：利用栈来进行判断</p><ol><li>首先对于s为空或者s长度为奇数的情况，直接返回结果</li><li>对于一般情况，建立一个栈，先将s的第一个字符入栈。</li><li>依次遍历s的字符，如果当前字符与栈顶的字符刚好匹配成一对，则栈顶字符出栈，否则当前字符入栈。</li><li>遍历完s后，如果栈为空则返回true，不为空返回false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        if(s.size() == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(s.size() &amp; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;char&gt; sta;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sta.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(s[i]);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(sta.top()==&apos;(&apos; &amp;&amp; s[i]==&apos;)&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(sta.top()==&apos;[&apos; &amp;&amp; s[i]==&apos;]&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(sta.top()==&apos;&#123;&apos; &amp;&amp; s[i]==&apos;&#125;&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sta.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sta.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（栈和队列）：103-二叉树的锯齿形层次遍历"><a href="#LeetCode练习（栈和队列）：103-二叉树的锯齿形层次遍历" class="headerlink" title="LeetCode练习（栈和队列）：103.二叉树的锯齿形层次遍历"></a><strong>LeetCode练习（栈和队列）：103.二叉树的锯齿形层次遍历</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，返回其节点值得锯齿形层次遍历。（即先从左往右，在从右往左进行下一层遍历，依次类推，层与层之间交替进行）<br>例如：给定二叉树[3,9,20,null,null,15,7]，返回锯齿形层次遍历如下：[[3],[20,9],[15,7]]</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：利用<em>queue+deque</em>实现</p><ol><li>从第一排开始逐排遍历树，每遍历完一排就将该排存放入队列q中。</li><li>然后定义一个deque，将队列中的节点弹出放入deque中（单排push_back,双排push_front）。</li><li>最后将deque压入vector，然后遍历下一排。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int signal=1;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int n=q.size();        //不可以省略</span><br><span class="line">            deque&lt;int&gt; temp;</span><br><span class="line">            for(int i=0;i&lt;n;i++)   //这里不能用q.size()代替n</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* p=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(signal &amp; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(p-&gt;val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    temp.push_front(p-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if(p-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(p-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(vector&lt;int&gt;(temp.begin(),temp.end()));</span><br><span class="line">            signal++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（栈和队列）：150-逆波兰表达式求值"><a href="#LeetCode练习（栈和队列）：150-逆波兰表达式求值" class="headerlink" title="LeetCode练习（栈和队列）：150.逆波兰表达式求值"></a><strong>LeetCode练习（栈和队列）：150.逆波兰表达式求值</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>根据逆波兰表示法，求表达式的值。<br>说明：<br>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为0的情况。<br><code><img src="/2020/02/17/剑指Offer——05.用两个栈实现队列/5_150.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li>总体思路比较简单，但是要注意<em>将string类型转换为int类型</em>，以及<em>减法和除法是n2-n1</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int str2num(string s)</span><br><span class="line">    &#123;</span><br><span class="line">        int num;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        ss&gt;&gt;num;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(tokens.size() == 0)</span><br><span class="line">        &#123;</span><br><span class="line">           return res;</span><br><span class="line">        &#125;else if(tokens.size()==1)</span><br><span class="line">        &#123;</span><br><span class="line">           return str2num(tokens[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for(int i=0;i&lt;tokens.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">           if(tokens[i]==&quot;+&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                int n1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int n2=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int temp=n1+n2;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i]==&quot;-&quot;)&#123;</span><br><span class="line">                int n1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int n2=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int temp=n2-n1;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i]==&quot;*&quot;)&#123;</span><br><span class="line">                int n1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int n2=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int temp=n1*n2;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i]==&quot;/&quot;)&#123;</span><br><span class="line">                int n1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int n2=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int temp=(int)n2/n1;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(str2num(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=s.top();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——04.重建二叉树</title>
    <link href="http://hustxxj.github.io/2020/02/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9404.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://hustxxj.github.io/2020/02/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9404.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-14T12:38:39.000Z</published>
    <updated>2020-02-19T08:21:27.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>本题的关键在于在中序遍历序列中找到根节点的位置，然后就可以根据根节点的位置再将其分为左子树和右子树，最后进行迭代。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.size()==0)</span><br><span class="line">            return NULL;</span><br><span class="line">        TreeNode* Head = new TreeNode(pre[0]);</span><br><span class="line">        vector&lt;int&gt; pre_left,pre_right,vin_left,vin_right;</span><br><span class="line">        int base;</span><br><span class="line">        for(int i=0;i&lt;vin.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(vin[i] == pre[0])</span><br><span class="line">            &#123;</span><br><span class="line">                base = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;base;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_left.push_back(pre[j+1]);</span><br><span class="line">            vin_left.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=base+1;j&lt;vin.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_right.push_back(pre[j]);</span><br><span class="line">            vin_right.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Head-&gt;left=reConstructBinaryTree(pre_left,vin_left);</span><br><span class="line">        Head-&gt;right=reConstructBinaryTree(pre_right,vin_right);</span><br><span class="line">        </span><br><span class="line">        return Head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树）：94-二叉树的中序遍历"><a href="#LeetCode练习（树）：94-二叉树的中序遍历" class="headerlink" title="LeetCode练习（树）：94.二叉树的中序遍历"></a><strong>LeetCode练习（树）：94.二叉树的中序遍历</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，返回它的中序遍历。<br>示例：输入[1,null,2,3]，输出[1,3,2]</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li><p>二叉树的遍历用<em>递归</em>实现起来比较简单，以该题中序遍历来说：（同样对于先序遍历和后序遍历只需要改变代码次序即可。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root-&gt;left != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            inorderTraversal(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;right != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            inorderTraversal(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果想用<em>迭代</em>实现则相对比较复杂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        TreeNode* ptr=root;</span><br><span class="line">        while(ptr || s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(ptr-&gt;val);</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><em>用迭代法实现先序遍历</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        TreeNode* ptr=root;</span><br><span class="line">        while(ptr || s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(ptr-&gt;right);</span><br><span class="line">                res.push_back(ptr-&gt;val);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><em>用迭代法实现后序遍历</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        TreeNode* ptr=root;</span><br><span class="line">        TreeNode* pre=NULL;</span><br><span class="line">        while(ptr || s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=s.top();</span><br><span class="line">            if(!ptr-&gt;right || pre==ptr-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(ptr-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">                pre=ptr;</span><br><span class="line">                ptr=NULL;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=ptr-&gt;right;</span><br><span class="line">                pre=NULL;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（树）：98-验证二叉搜索树"><a href="#LeetCode练习（树）：98-验证二叉搜索树" class="headerlink" title="LeetCode练习（树）：98.验证二叉搜索树"></a><strong>LeetCode练习（树）：98.验证二叉搜索树</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>本题用递归实现，需要注意在遍历树的同时需要保留节点的上界和下界，不仅需要与子节点的值比较，还要与上下界的值比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool compare(TreeNode* root,long min,long max)</span><br><span class="line">    &#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root-&gt;val &lt;= min || root-&gt;val &gt;= max)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return compare(root-&gt;left,min,root-&gt;val) &amp;&amp; compare(root-&gt;right,root-&gt;val,max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isValidBST(struct TreeNode* root)&#123;</span><br><span class="line">      return compare(root,LONG_MIN,LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（树）：100-相同的树"><a href="#LeetCode练习（树）：100-相同的树" class="headerlink" title="LeetCode练习（树）：100.相同的树"></a><strong>LeetCode练习（树）：100.相同的树</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定两个二叉树，编写一个函数来检验他们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>简单的递归实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(p==NULL &amp;&amp; q==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if((p==NULL &amp;&amp; q!=NULL) || (p!=NULL &amp;&amp; q==NULL))</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            if(p-&gt;val != q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——03.从尾到头打印链表</title>
    <link href="http://hustxxj.github.io/2020/02/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9403.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/02/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9403.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-14T02:07:28.000Z</published>
    <updated>2020-02-14T12:36:23.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>这题比较简单，唯一需要注意的就是输出的顺序是“从尾到头”。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while(head)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：02-两数相加"><a href="#LeetCode练习（链表）：02-两数相加" class="headerlink" title="LeetCode练习（链表）：02.两数相加"></a><strong>LeetCode练习（链表）：02.两数相加</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。<br>如果，我们将这两个数2相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字0之外，这两个数都不会以0开头。<br>示例：输入（2-&gt;4-&gt;3）+(5-&gt;6-&gt;4)，输出7-&gt;0-&gt;8，原因342+465=807</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：<br><em>首先说明一种错误做法，如果想先计算两个链表代表的整数值，然后将两个整数相加再重新放入一个链表，这种方式从思路上来说是正确的，但是没有考虑整数的取值范围问题，当两数相加超过10^10的时候这种方式就会报错。</em></p><ol><li>正确的方式是逐位相加然后加入链表中，直到两个链表都遍历完并且不存在进位为止。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* head=new ListNode(-1);</span><br><span class="line">        ListNode* ptr=head;</span><br><span class="line">        bool nextadd=false;</span><br><span class="line">        while(l1 || l2 || nextadd==true)</span><br><span class="line">        &#123;</span><br><span class="line">            if(l1 &amp;&amp; l2)</span><br><span class="line">            &#123;</span><br><span class="line">                int v=l1-&gt;val + l2-&gt;val;</span><br><span class="line">                ListNode*  s;</span><br><span class="line">                if(nextadd==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=new ListNode((v+1)%10);</span><br><span class="line">                    if(v+1 &gt;= 10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=true;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    s=new ListNode(v%10);</span><br><span class="line">                    if(v &gt;= 10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=true;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ptr-&gt;next=s;</span><br><span class="line">                ptr=s;</span><br><span class="line">                </span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;else if(l1 &amp;&amp; !l2)</span><br><span class="line">            &#123;</span><br><span class="line">                int v=l1-&gt;val;</span><br><span class="line">                ListNode* s;</span><br><span class="line">                if(nextadd==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=new ListNode((v+1)%10);</span><br><span class="line">                    if(v+1 &gt;= 10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=true;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    s=new ListNode(v%10);</span><br><span class="line">                    if(v &gt;= 10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=true;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ptr-&gt;next=s;</span><br><span class="line">                ptr=s;</span><br><span class="line">                </span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;else if(!l1 &amp;&amp; l2)</span><br><span class="line">            &#123;</span><br><span class="line">                 int v=l2-&gt;val;</span><br><span class="line">                ListNode* s;</span><br><span class="line">                if(nextadd==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=new ListNode((v+1)%10);</span><br><span class="line">                    if(v+1 &gt;= 10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=true;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    s=new ListNode(v%10);</span><br><span class="line">                    if(v &gt;= 10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=true;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextadd=false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ptr-&gt;next=s;</span><br><span class="line">                ptr=s;</span><br><span class="line">                </span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;else if(!l1 &amp;&amp; !l2 &amp;&amp; nextadd==true)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* s=new ListNode(1);</span><br><span class="line">                ptr-&gt;next=s;</span><br><span class="line">                ptr=s;</span><br><span class="line">                nextadd=false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：19-删除链表的倒数第N个节点"><a href="#LeetCode练习（链表）：19-删除链表的倒数第N个节点" class="headerlink" title="LeetCode练习（链表）：19.删除链表的倒数第N个节点"></a><strong>LeetCode练习（链表）：19.删除链表的倒数第N个节点</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。（保证给定n是有效的）<br>示例：给定链表1-&gt;2-&gt;3-&gt;4-&gt;5，和n=2，当删除了导数第二个节点后，链表变为1-&gt;2-&gt;3-&gt;5</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li>利用双指针进行求解，ptr1指向头结点，ptr2指向第n个节点，两个指针同时前移，当ptr2指向最后一个节点时，ptr1指向的就是倒数第n个节点。</li><li>要注意的是在判断ptr2-&gt;next-&gt;next是否为空节点时需要先保证ptr-&gt;next存在，否则指针就会指向内存的未知区域导致错误。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        ListNode* ptr1=head;</span><br><span class="line">        ListNode* ptr2=head;</span><br><span class="line">        ListNode* res=ptr1;</span><br><span class="line"></span><br><span class="line">        while(n-1&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr2=ptr2-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(ptr2-&gt;next==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(ptr2-&gt;next-&gt;next != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1=ptr1-&gt;next;</span><br><span class="line">            ptr2=ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr1-&gt;next=ptr1-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：21-合并两个有序链表"><a href="#LeetCode练习（链表）：21-合并两个有序链表" class="headerlink" title="LeetCode练习（链表）：21.合并两个有序链表"></a><strong>LeetCode练习（链表）：21.合并两个有序链表</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：输入1-&gt;2-&gt;4，1-&gt;3-&gt;4；输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路： 思路比较简单，有一点需要注意的是在初始化head节点时ListNode* head=new ListNode(-1);才算正确的初始化方式，否则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if(l1==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;else if(l2==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* head=new ListNode(-1);</span><br><span class="line">        ListNode* ptr=head;</span><br><span class="line">        while(l1 || l2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(l1 &amp;&amp; l2)</span><br><span class="line">            &#123;</span><br><span class="line">                if(l1-&gt;val&lt;=l2-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr-&gt;next=l1;</span><br><span class="line">                    ptr=l1;</span><br><span class="line">                    l1=l1-&gt;next;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr-&gt;next=l2;</span><br><span class="line">                    ptr=l2;</span><br><span class="line">                    l2=l2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else if(l1 &amp;&amp; !l2)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next=l1;</span><br><span class="line">                ptr=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;else if(!l1 &amp;&amp; l2)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next=l2;</span><br><span class="line">                ptr=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个链表，按链表从尾到头的顺序返回一个ArrayList。&lt;/p&gt;
&lt;hr&gt;
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——02.替换空格</title>
    <link href="http://hustxxj.github.io/2020/02/11/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9402.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://hustxxj.github.io/2020/02/11/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9402.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2020-02-11T14:04:45.000Z</published>
    <updated>2020-02-14T12:34:09.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy则经过替换以后的字符串为We%20Are%20Happy</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><ol><li>遍历字符串，计算字符串中包含多少个空格</li><li>从最后一个字符开始依次赋值：判断该字符是否为空格，<br>若不是空格，该字符的位置为i，之前包含n个空格，则其位置变为i+2n<br>若是空格，则从i+2n往前依次填入‘0’‘2’‘%’</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(*(str+i) == &apos; &apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=length-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(*(str+i) != &apos; &apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                *(str+i+count*2)=*(str+i);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                *(str+i+count*2)=&apos;0&apos;;</span><br><span class="line">                *(str+i+count*2-1)=&apos;2&apos;;</span><br><span class="line">                *(str+i+count*2-2)=&apos;%&apos;;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：03-无重复字符的最长子串"><a href="#LeetCode练习（字符串）：03-无重复字符的最长子串" class="headerlink" title="LeetCode练习（字符串）：03.无重复字符的最长子串"></a><strong>LeetCode练习（字符串）：03.无重复字符的最长子串</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。<br>例如：<br>输入:”abcabcbb”,输出：3,解释：因为无重复字符的最长子串是”abc”,所以其长度为3<br>输入:”pwwkew”,输出：3</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：利用双指针求解,建立start和end两个指针,遍历从start到end，将所有字符都与end比较,如果都不相同,则value加1,end前移一位再次进行上述循环。直到end到达string队尾退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s)</span><br><span class="line">    &#123;</span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(len==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int end=1;</span><br><span class="line">        int start=0;</span><br><span class="line">        int res=1;</span><br><span class="line">        int value=1;</span><br><span class="line">        while(end&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            char target=s[end];</span><br><span class="line">            for(int index=start;index&lt;end;index++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(s[index]==target)</span><br><span class="line">                &#123;</span><br><span class="line">                    start=index+1;</span><br><span class="line">                    value=end-start;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">            value++;</span><br><span class="line">            res=(res&gt;=value)?res:value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（字符串）：13-罗马数字转整数"><a href="#LeetCode练习（字符串）：13-罗马数字转整数" class="headerlink" title="LeetCode练习（字符串）：13.罗马数字转整数"></a><strong>LeetCode练习（字符串）：13.罗马数字转整数</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/02/11/剑指Offer——02.替换空格/2_13.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：遍历字符串字符,对三种特殊字符特殊考虑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int romanToInt(string s) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        int size=s.size();</span><br><span class="line">        if(size==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&apos;I&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i+1&lt;size)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s[i+1]==&apos;V&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=4;</span><br><span class="line">                        i+=1;</span><br><span class="line">                    &#125;else if(s[i+1]==&apos;X&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=9;</span><br><span class="line">                        i+=1;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=1;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(s[i]==&apos;V&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=5;</span><br><span class="line">            &#125;else if(s[i]==&apos;X&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i+1&lt;size)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s[i+1]==&apos;L&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=40;</span><br><span class="line">                        i+=1;</span><br><span class="line">                    &#125;else if(s[i+1]==&apos;C&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=90;</span><br><span class="line">                        i+=1;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=10;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(s[i]==&apos;L&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=50;</span><br><span class="line">            &#125;else if(s[i]==&apos;C&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i+1&lt;size)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s[i+1]==&apos;D&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=400;</span><br><span class="line">                        i+=1;</span><br><span class="line">                    &#125;else if(s[i+1]==&apos;M&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=900;</span><br><span class="line">                        i+=1;</span><br><span class="line">                    &#125;else</span><br><span class="line">                    &#123;</span><br><span class="line">                        res+=100;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=100;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(s[i]==&apos;D&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=500;</span><br><span class="line">            &#125;else if(s[i]==&apos;M&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=1000;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（字符串）：5-最长回文子串"><a href="#LeetCode练习（字符串）：5-最长回文子串" class="headerlink" title="LeetCode练习（字符串）：5.最长回文子串"></a><strong>LeetCode练习（字符串）：5.最长回文子串</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个字符串s,找到s中最长的回文子串。你可以假设s的最大长度为1000.<br>示例1:输入”babad”,输出”bab”,注意：”aba”也是一个有效答案。<br>示例2:输入”acbbcad”,输出”acbbca”</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：动态规划<br>以”acbbcad”为例：dp[i][j]==1,表示i到j是一个回文串;<br>                   a   c   b   b   c   a   d<br>                  [0] [1] [2] [3] [4] [5] [6]<br>dp[0][0]=1,dp[0][1]=,dp[0][2]=,dp[0][3]=,dp[0][4]=,dp[0][5]=1,dp[0][6]=;<br>dp[1][0]=,dp[1][1]=1,dp[1][2]=,dp[1][3]=,dp[1][4]=1,dp[1][5]=,dp[1][6]=;<br>dp[2][0]=,dp[2][1]=,dp[2][2]=1,dp[2][3]=1,dp[2][4]=,dp[2][5]=,dp[2][6]=;<br>dp[3][0]=,dp[3][1]=,dp[3][2]=,dp[3][3]=1,dp[3][4]=,dp[3][5]=,dp[3][6]=;<br>dp[4][0]=,dp[4][1]=,dp[4][2]=,dp[4][3]=,dp[4][4]=1,dp[4][5]=,dp[4][6]=;<br>dp[5][0]=,dp[5][1]=,dp[5][2]=,dp[5][3]=,dp[5][4]=,dp[5][5]=1,dp[5][6]=;<br>dp[6][0]=,dp[6][1]=,dp[6][2]=,dp[6][3]=,dp[6][4]=,dp[6][5]=,dp[6][6]=1;<br>                        max=5,start=0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">        &#123;</span><br><span class="line">        return s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int max(1),start(0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len));</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        dp[i][i]=1;</span><br><span class="line">        if(s[i]==s[i+1] &amp;&amp; i&lt;len-1)</span><br><span class="line">        &#123;</span><br><span class="line">        max=2;</span><br><span class="line">        dp[i][i+1]=1;</span><br><span class="line">        start=i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int win=3;win&lt;=len;win++)</span><br><span class="line">        &#123;</span><br><span class="line">        for(int i=0;i+win-1&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        int j=i+win-1;</span><br><span class="line">        if(s[i]==s[j] &amp;&amp; dp[i+1][j-1]==1)</span><br><span class="line">        &#123;</span><br><span class="line">        max=win;</span><br><span class="line">        dp[i][j]=1;</span><br><span class="line">        start=i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return s.substr(start,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We 
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——01.二维数组中的查找</title>
    <link href="http://hustxxj.github.io/2020/02/09/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9401.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://hustxxj.github.io/2020/02/09/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9401.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-09T09:28:23.000Z</published>
    <updated>2020-02-14T12:34:14.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>获取数组的行数和列数，遍历数组的每个元素，比较数组元素和目标整数的大小，如果相同直接返回true。遍历完成返回false。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">   bool Find(int target,vector&lt;vector&lt;int&gt;&gt; array)&#123;</span><br><span class="line">      int rows=array.size();</span><br><span class="line">      int cols=array[0].size();</span><br><span class="line">      for(int i=0;i&lt;rows;i++)</span><br><span class="line">      &#123;</span><br><span class="line">        for(int j=0;j&lt;cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">        if(array[i][j]==target)</span><br><span class="line">           return true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：04-寻找两个有序数组的中位数"><a href="#LeetCode练习（数组）：04-寻找两个有序数组的中位数" class="headerlink" title="LeetCode练习（数组）：04.寻找两个有序数组的中位数"></a><strong>LeetCode练习（数组）：04.寻找两个有序数组的中位数</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定两个大小为m和n的有序数组num1和num2,请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m+n)),你可以假设num1和num2不会同时为空。<br>示例：num1=[1,3],num2=[2],中位数是2.0<br>      num1=[1,2],num2=[3,4],中位数是2.5</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        if(nums1.size()==0 &amp;&amp; nums2.size()==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; add;</span><br><span class="line">        for(int i=0;i&lt;nums1.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add.push_back(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;nums2.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            add.push_back(nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(add.begin(),add.end());</span><br><span class="line">        int size=add.size();</span><br><span class="line">        double res=0;</span><br><span class="line">        if(size%2==0)</span><br><span class="line">        &#123;</span><br><span class="line">            res=(double)(add[size/2]+add[size/2 - 1])/2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res=(double)add[size/2];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组）：41-缺失的一个正数"><a href="#LeetCode练习（数组）：41-缺失的一个正数" class="headerlink" title="LeetCode练习（数组）：41.缺失的一个正数"></a><strong>LeetCode练习（数组）：41.缺失的一个正数</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br>示例：输入[1,2,0],输出3<br>     输入[3,4,-1,1],输出2<br>     输入[7,8,9,11,12],输出1</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：1.将数组从小到大进行排序<br>     2.如果第一个数字大于1，返回1<br>     3.开始遍历数组<br>     首先判断值是否小于等于0，如果是则直接continue，否则，如果是第一个大于0的数字则判断其是否大于1，若是则直接返回1。<br>     判断是否存在下一个元素，如果否，返回当前元素值+1；否则判断该元素和下一个元素的差值，如果差值大于1，则返回当前元素值+1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size()&lt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        if(nums[0]&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res=1;</span><br><span class="line">        bool isfirst=true;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]&lt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i]&gt;1 &amp;&amp; isfirst==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                isfirst=false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(i+1&gt;=nums.size())</span><br><span class="line">            &#123;</span><br><span class="line">                res = nums[i]+1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i+1]-nums[i] &gt; 1 &amp;&amp; nums[i]&gt;=0)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = nums[i]+1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组）：42-接雨水"><a href="#LeetCode练习（数组）：42-接雨水" class="headerlink" title="LeetCode练习（数组）：42.接雨水"></a><strong>LeetCode练习（数组）：42.接雨水</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定n个非负整数表示每个宽度为1的柱子的高度，计算按此排列的柱子，下雨之后能接多少雨水。<br> <code><img src="/2020/02/09/剑指Offer——01.二维数组中的查找/1_42.jpg" title="示例图"></code><br>输入：[0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>方法一思路：1.按行进行计算，从第一行开始计算逐行的存水量。（该方法时间复杂度过高，无法通过编译）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int size=height.size();</span><br><span class="line">        if(size&lt;=2)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int maxValue = *max_element(height.begin(),height.end()); </span><br><span class="line">        if(maxValue&lt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bool isfirst=true;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int j=0;j&lt;maxValue;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int ptr=size-1;</span><br><span class="line">            for(int i=size-1;i&gt;=0;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                if(height[i]&gt;=j+1)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr=i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(int i=0;i&lt;ptr;i++)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                if(height[i]&lt;=j &amp;&amp; isfirst==true)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                isfirst=false;</span><br><span class="line"></span><br><span class="line">                if(height[i]&lt;j+1)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    res++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            isfirst=true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法二思路：1.按列进行计算，从第一行开始计算逐列的存水量。<br>只有当当前列的值同时小于其左边和右边列的最大值时，才可能存水，存水量等于左右列最大值中的较小者m减去当前列值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int size=height.size();</span><br><span class="line">        if(size&lt;=2)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=1;i&lt;size-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int lmax=0;</span><br><span class="line">            for(int j=i-1;j&gt;=0;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                if(height[j]&gt;lmax)</span><br><span class="line">                &#123;</span><br><span class="line">                    lmax=height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int rmax=0;</span><br><span class="line">            for(int j=i+1;j&lt;=size-1;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(height[j]&gt;rmax)</span><br><span class="line">                &#123;</span><br><span class="line">                    rmax=height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            int min=(lmax&gt;=rmax)?rmax:lmax;</span><br><span class="line">            if(height[i]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=min-height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法三思路：1.与二相同，也是按列计算，但是为了优化二中的计算效率，引入了动态规划。利用动态规划先计算出每个点i对应的左边和右边的最大值，并分别存入lmax和rmax数组中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int size=height.size();</span><br><span class="line">        if(size&lt;=2)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res=0;</span><br><span class="line">        //动态规划，定义两个vector存储当前i的左右最大值</span><br><span class="line">        int *rmax=new int[size]();</span><br><span class="line">        int *lmax=new int[size]();</span><br><span class="line">        for(int i=1;i&lt;size-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lmax[i]=(lmax[i-1]&gt;=height[i-1])?lmax[i-1]:height[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=size-2;j&gt;=0;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            rmax[j]=(rmax[j+1]&gt;=height[j+1])?rmax[j+1]:height[j+1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int k=1;k&lt;size-1;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            int min=(rmax[k]&gt;=lmax[k])?lmax[k]:rmax[k];</span><br><span class="line">            if(height[k]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=min-height[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>用CNN进行MNIST手写字符识别</title>
    <link href="http://hustxxj.github.io/2019/07/12/%E7%94%A8CNN%E8%BF%9B%E8%A1%8CMNIST%E6%89%8B%E5%86%99%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"/>
    <id>http://hustxxj.github.io/2019/07/12/%E7%94%A8CNN%E8%BF%9B%E8%A1%8CMNIST%E6%89%8B%E5%86%99%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/</id>
    <published>2019-07-12T02:34:17.000Z</published>
    <updated>2019-07-12T02:47:44.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用CNN进行MNIST手写字符识别"><a href="#用CNN进行MNIST手写字符识别" class="headerlink" title="用CNN进行MNIST手写字符识别"></a><strong>用CNN进行MNIST手写字符识别</strong></h1><hr><p>如果想了解卷积神经网络的基本概念和网络结构，在此推荐一篇博文，写的非常详细也很易懂。</p><blockquote><p><a href="https://www.jianshu.com/p/49b70f6480d1" target="_blank" rel="noopener">https://www.jianshu.com/p/49b70f6480d1</a></p></blockquote><p>在上一篇文章中贴出的用最简单的三层神经网络进行手写数字识别，最后得到的模型分类准确性只能达到85%左右，对于这个最简单的数据集准确性显然是不够的。而用CNN进行分类准确度可以达到95%左右，下面贴出我用CNN在MNIST数据集上进行手写字符识别的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"></span><br><span class="line">mnist=input_data.read_data_sets(&apos;MNIST_data&apos;,one_hot=True)</span><br><span class="line"></span><br><span class="line">#计算分类准确度</span><br><span class="line">def compute_accuracy(v_xs,v_ys):</span><br><span class="line">global prediction #全局化prediction</span><br><span class="line">y_pre=sess.run(prediction,feed_dict=&#123;xs:v_xs,keep_prob:0.5&#125;) #输入样本v_xs得到预测值y_pre</span><br><span class="line">correct_prediction=tf.equal(tf.argmax(y_pre,1),tf.argmax(v_ys,1)) #计算预测值和真实值是否相等</span><br><span class="line">accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</span><br><span class="line">result=sess.run(accuracy,feed_dict=&#123;xs:v_xs,ys:v_ys&#125;)</span><br><span class="line">return result</span><br><span class="line"></span><br><span class="line">#定义随机变量w(权重)</span><br><span class="line">def weight_variable(shape):</span><br><span class="line">initial=tf.truncated_normal(shape,stddev=0.1)</span><br><span class="line">return tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">#定义随机变量b(偏置)</span><br><span class="line">def bias_variable(shape):</span><br><span class="line">initial=tf.constant(0.1,shape=shape) #b的初始值设置为常量0.1</span><br><span class="line">return tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">#定义卷积层</span><br><span class="line">def conv2d(x,W):</span><br><span class="line">#stride[1,x_movement,y_movement,1]</span><br><span class="line">#padding=&apos;SAME&apos;:不改变x的大小</span><br><span class="line">#padding=&apos;VALID&apos;:缩小x的大小</span><br><span class="line">return tf.nn.conv2d(x,W,strides=[1,1,1,1],padding=&apos;SAME&apos;)</span><br><span class="line"></span><br><span class="line">#定义池化层(最大池化)</span><br><span class="line">def max_pool_2x2(x):</span><br><span class="line">return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&apos;SAME&apos;)</span><br><span class="line"></span><br><span class="line">#定义placeholder用于神经网络输入</span><br><span class="line">xs=tf.placeholder(tf.float32,[None,784]) #28*28</span><br><span class="line">ys=tf.placeholder(tf.float32,[None,10])</span><br><span class="line">keep_prob=tf.placeholder(tf.float32)  #定义dropout防止模型过拟合</span><br><span class="line">x_image=tf.reshape(xs,[-1,28,28,1]) #[-1:n_sample样本数量,28,28,1:图片只有一个通道]</span><br><span class="line"></span><br><span class="line">#定义第一个卷积层</span><br><span class="line">W_conv1=weight_variable([5,5,1,32])#patch 5x5,out size 1x32</span><br><span class="line">b_conv1=bias_variable([32])</span><br><span class="line">h_conv1=tf.nn.relu(conv2d(x_image,W_conv1)+b_conv1)#output size 28x28x32</span><br><span class="line">h_pool1=max_pool_2x2(h_conv1)                      #output size 14x14x32</span><br><span class="line"></span><br><span class="line">#定义第二个卷积层</span><br><span class="line">W_conv2=weight_variable([5,5,32,64])#patch 5x5, in size 32,out size 1x64</span><br><span class="line">b_conv2=bias_variable([64])</span><br><span class="line">h_conv2=tf.nn.relu(conv2d(h_pool1,W_conv2)+b_conv2)#output size 14x14x64</span><br><span class="line">h_pool2=max_pool_2x2(h_conv2)                      #output size 7x7x64</span><br><span class="line"></span><br><span class="line">#定义第一个全连接层</span><br><span class="line">W_fcl=weight_variable([7*7*64,1024])</span><br><span class="line">b_fcl=bias_variable([1024])</span><br><span class="line">h_pool2_flat=tf.reshape(h_pool2,[-1,7*7*64]) #[n_samples,7,7,64]-&gt;[n_samples,7*7*64]</span><br><span class="line">h_fcl=tf.nn.relu(tf.matmul(h_pool2_flat,W_fcl)+b_fcl)</span><br><span class="line">h_fcl_drop=tf.nn.dropout(h_fcl,keep_prob)</span><br><span class="line"></span><br><span class="line">#定义第二个全连接层</span><br><span class="line">W_fc2=weight_variable([1024,10])</span><br><span class="line">b_fc2=bias_variable([10])</span><br><span class="line">prediction=tf.nn.softmax(tf.matmul(h_fcl_drop,W_fc2)+b_fc2)</span><br><span class="line"></span><br><span class="line">#计算预测值与真实值之间的误差(loss)这里的loss就是‘cross_entropy’</span><br><span class="line">cross_entropy=tf.reduce_mean(-tf.reduce_sum(ys*tf.log(prediction),reduction_indices=[1]))</span><br><span class="line">#用GradientDescentOptimizer,以1e-4的速率更新loss使得loss更小</span><br><span class="line">train_step=tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line">#建立session,初始化参数</span><br><span class="line">saver = tf.train.Saver()  #定义saver用于存储模型</span><br><span class="line">init=tf.initialize_all_variables()</span><br><span class="line">sess=tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line">#开始训练</span><br><span class="line">for i in range(1000):</span><br><span class="line">batch_xs,batch_ys=mnist.train.next_batch(100) #分批学习，每次学习100个数据</span><br><span class="line">sess.run(train_step,feed_dict=&#123;xs:batch_xs,ys:batch_ys,keep_prob:0.5&#125;)</span><br><span class="line">if i%50==0:</span><br><span class="line">print(compute_accuracy(mnist.test.images,mnist.test.labels))</span><br><span class="line"></span><br><span class="line">#存储模型，存储地址为&quot;my_net/CNN_MNIST.ckpt&quot;</span><br><span class="line">save_path=saver.save(sess,&quot;my_net/CNN_MNIST.ckpt&quot;)</span><br><span class="line">print(&quot;Save to path:&quot;,save_path)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用CNN进行MNIST手写字符识别&quot;&gt;&lt;a href=&quot;#用CNN进行MNIST手写字符识别&quot; class=&quot;headerlink&quot; title=&quot;用CNN进行MNIST手写字符识别&quot;&gt;&lt;/a&gt;&lt;strong&gt;用CNN进行MNIST手写字符识别&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="学习" scheme="http://hustxxj.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TensorFlow" scheme="http://hustxxj.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>用最简单的神经网络进行MNIST手写数字识别</title>
    <link href="http://hustxxj.github.io/2019/07/12/%E7%94%A8%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%BF%9B%E8%A1%8CMNIST%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://hustxxj.github.io/2019/07/12/%E7%94%A8%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%BF%9B%E8%A1%8CMNIST%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</id>
    <published>2019-07-12T02:24:01.000Z</published>
    <updated>2019-07-12T02:30:02.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用最简单的神经网络进行MNIST手写数字识别"><a href="#用最简单的神经网络进行MNIST手写数字识别" class="headerlink" title="用最简单的神经网络进行MNIST手写数字识别"></a><strong>用最简单的神经网络进行MNIST手写数字识别</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"></span><br><span class="line">mnist=input_data.read_data_sets(&apos;MNIST_data&apos;,one_hot=True)</span><br><span class="line"></span><br><span class="line">def add_layer(inputs,in_size,out_size,activation_function=None):</span><br><span class="line">Weights=tf.Variable(tf.random_normal([in_size,out_size]))</span><br><span class="line">bias=tf.Variable(tf.zeros([1,out_size])+0.1)</span><br><span class="line">Wx_plus_b=tf.matmul(inputs,Weights)+bias</span><br><span class="line">if activation_function is None:</span><br><span class="line">outputs=Wx_plus_b</span><br><span class="line">else:</span><br><span class="line">outputs=activation_function(Wx_plus_b)</span><br><span class="line">return outputs</span><br><span class="line"></span><br><span class="line">def compute_accuracy(v_xs,v_ys):</span><br><span class="line">global prediction #全局化prediction</span><br><span class="line">y_pre=sess.run(prediction,feed_dict=&#123;xs:v_xs&#125;) #输入样本v_xs得到预测值y_pre</span><br><span class="line">correct_prediction=tf.equal(tf.argmax(y_pre,1),tf.argmax(v_ys,1)) #计算预测值和真实值是否相等</span><br><span class="line">accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</span><br><span class="line">result=sess.run(accuracy,feed_dict=&#123;xs:v_xs,ys:v_ys&#125;)</span><br><span class="line">return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#定义placeholder用于神经网络输入</span><br><span class="line">xs=tf.placeholder(tf.float32,[None,784]) #28*28</span><br><span class="line">ys=tf.placeholder(tf.float32,[None,10])</span><br><span class="line"></span><br><span class="line">#添加输出层</span><br><span class="line">prediction=add_layer(xs,784,10,activation_function=tf.nn.softmax)</span><br><span class="line"></span><br><span class="line">#计算预测值与真实值之间的误差(loss)这里的loss就是‘cross_entropy’</span><br><span class="line">cross_entropy=tf.reduce_mean(-tf.reduce_sum(ys*tf.log(prediction),reduction_indices=[1]))</span><br><span class="line">#用GradientDescentOptimizer,以0.5的速率更新loss使得loss更小</span><br><span class="line">train_step=tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line">#建立session,初始化参数</span><br><span class="line">init=tf.initialize_all_variables()</span><br><span class="line">sess=tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line">#开始训练</span><br><span class="line">for i in range(1000):</span><br><span class="line">batch_xs,batch_ys=mnist.train.next_batch(100) #分批学习，每次学习100个数据</span><br><span class="line">sess.run(train_step,feed_dict=&#123;xs:batch_xs,ys:batch_ys&#125;)</span><br><span class="line">if i%50==0:</span><br><span class="line">print(compute_accuracy(mnist.test.images,mnist.test.labels))</span><br></pre></td></tr></table></figure><p><em>训练结果</em>：最后的识别准确度在0.87左右</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用最简单的神经网络进行MNIST手写数字识别&quot;&gt;&lt;a href=&quot;#用最简单的神经网络进行MNIST手写数字识别&quot; class=&quot;headerlink&quot; title=&quot;用最简单的神经网络进行MNIST手写数字识别&quot;&gt;&lt;/a&gt;&lt;strong&gt;用最简单的神经网络进行M
      
    
    </summary>
    
    
      <category term="学习" scheme="http://hustxxj.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TensorFlow" scheme="http://hustxxj.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>搭建第一个神经网络并可视化</title>
    <link href="http://hustxxj.github.io/2019/07/08/%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://hustxxj.github.io/2019/07/08/%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2019-07-08T09:26:37.000Z</published>
    <updated>2019-07-08T11:57:06.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建第一个神经网络并可视化"><a href="#搭建第一个神经网络并可视化" class="headerlink" title="搭建第一个神经网络并可视化"></a><strong>搭建第一个神经网络并可视化</strong></h1><hr><p><em>神经网络根据给出的训练数据自动拟合出一条二元函数曲线</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">def add_layer(inputs,in_size,out_size,activation_function=None):</span><br><span class="line">Weights=tf.Variable(tf.random_normal([in_size,out_size]))</span><br><span class="line">bias=tf.Variable(tf.zeros([1,out_size])+0.1)</span><br><span class="line">Wx_plus_b=tf.matmul(inputs,Weights)+bias</span><br><span class="line">if activation_function is None:</span><br><span class="line">outputs=Wx_plus_b</span><br><span class="line">else:</span><br><span class="line">outputs=activation_function(Wx_plus_b)</span><br><span class="line">return outputs</span><br><span class="line"></span><br><span class="line">#自己产生一个数据集</span><br><span class="line">x_data=np.linspace(-1,1,300)[:,np.newaxis]</span><br><span class="line">noise=np.random.normal(0,0.05,x_data.shape)</span><br><span class="line">y_data=np.square(x_data)-0.5+noise</span><br><span class="line"></span><br><span class="line">#构建神经网络层,共有三层结构（输入层（1个节点），一层隐藏层（10个节点），输出层（1个节点））</span><br><span class="line">xs=tf.placeholder(tf.float32,[None,1])</span><br><span class="line">ys=tf.placeholder(tf.float32,[None,1])</span><br><span class="line">layer1=add_layer(xs,1,10,activation_function=tf.nn.relu)#隐藏层</span><br><span class="line">prediction=add_layer(layer1,10,1,activation_function=None)#输出层</span><br><span class="line"></span><br><span class="line">#计算预测值与真实值之间的误差(loss)</span><br><span class="line">loss=tf.reduce_mean(tf.reduce_sum(tf.square(ys-prediction),reduction_indices=[1]))</span><br><span class="line">#用GradientDescentOptimizer,以0.1的速率更新loss使得loss更小</span><br><span class="line">train_step=tf.train.GradientDescentOptimizer(0.1).minimize(loss)</span><br><span class="line"></span><br><span class="line">#用于结果可视化</span><br><span class="line">fig=plt.figure()</span><br><span class="line">ax=fig.add_subplot(1,1,1)</span><br><span class="line">ax.scatter(x_data,y_data)</span><br><span class="line">plt.ion()</span><br><span class="line">plt.show()</span><br><span class="line">#用于结果可视化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#建立session,初始化参数</span><br><span class="line">init=tf.initialize_all_variables()</span><br><span class="line">sess=tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line">#开始训练</span><br><span class="line">for i in range(1000):</span><br><span class="line">sess.run(train_step,feed_dict=&#123;xs:x_data,ys:y_data&#125;)</span><br><span class="line">if i%50==0:</span><br><span class="line">print(sess.run(loss,feed_dict=&#123;xs:x_data,ys:y_data&#125;))</span><br><span class="line">#可视化预测数据</span><br><span class="line">try:</span><br><span class="line">ax.lines.remove(lines[0])</span><br><span class="line">except Exception:</span><br><span class="line">pass</span><br><span class="line">prediction_value=sess.run(prediction,feed_dict=&#123;xs:x_data&#125;)</span><br><span class="line">lines=ax.plot(x_data,prediction_value,&apos;r-&apos;,lw=5)</span><br><span class="line">plt.pause(0.1)</span><br></pre></td></tr></table></figure><p>[训练loss及可视化结果] (<a href="https://www.bilibili.com/video/av58349016" target="_blank" rel="noopener">https://www.bilibili.com/video/av58349016</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建第一个神经网络并可视化&quot;&gt;&lt;a href=&quot;#搭建第一个神经网络并可视化&quot; class=&quot;headerlink&quot; title=&quot;搭建第一个神经网络并可视化&quot;&gt;&lt;/a&gt;&lt;strong&gt;搭建第一个神经网络并可视化&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;em&gt;
      
    
    </summary>
    
    
      <category term="学习" scheme="http://hustxxj.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TensorFlow" scheme="http://hustxxj.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow初探</title>
    <link href="http://hustxxj.github.io/2019/07/08/TensorFlow%E5%88%9D%E6%8E%A2/"/>
    <id>http://hustxxj.github.io/2019/07/08/TensorFlow%E5%88%9D%E6%8E%A2/</id>
    <published>2019-07-08T09:16:45.000Z</published>
    <updated>2019-07-08T09:24:30.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TensorFlow初探"><a href="#TensorFlow初探" class="headerlink" title="TensorFlow初探"></a><strong>TensorFlow初探</strong></h1><hr><h2 id="第一个TensorFlow例子"><a href="#第一个TensorFlow例子" class="headerlink" title="第一个TensorFlow例子"></a><strong>第一个TensorFlow例子</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#create data</span><br><span class="line">x_data=np.random.rand(100).astype(np.float32)</span><br><span class="line">y_data=x_data*0.1+0.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#create tensorflow structure start</span><br><span class="line">Weights=tf.Variable(tf.random_uniform([1],-1.0,1.0))</span><br><span class="line">bias=tf.Variable(tf.zeros([1]))</span><br><span class="line"></span><br><span class="line">y=Weights*x_data+bias</span><br><span class="line"></span><br><span class="line">loss=tf.reduce_mean(tf.square(y-y_data))</span><br><span class="line">optimizer=tf.train.GradientDescentOptimizer(0.5)</span><br><span class="line">train=optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line">init=tf.initialize_all_variables()</span><br><span class="line"></span><br><span class="line">#激活神经网络</span><br><span class="line">sess=tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line">for step in range(201):</span><br><span class="line">sess.run(train)</span><br><span class="line">if step%20==0:</span><br><span class="line">print(step,sess.run(Weights),sess.run(bias))</span><br></pre></td></tr></table></figure><h2 id="了解Session"><a href="#了解Session" class="headerlink" title="了解Session"></a><strong>了解Session</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">matrix1=tf.constant([[3,3]])</span><br><span class="line">matrix2=tf.constant([[2],</span><br><span class="line">                 [2]])</span><br><span class="line">product=tf.matmul(matrix1,matrix2)</span><br><span class="line"></span><br><span class="line">#方法一</span><br><span class="line">sess=tf.Session()</span><br><span class="line">result=sess.run(product)</span><br><span class="line">print(&apos;result:&apos;,result)</span><br><span class="line">sess.close()</span><br><span class="line"></span><br><span class="line">#方法二</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">result2=sess.run(product)</span><br><span class="line">print(&apos;result2:&apos;,result2)</span><br></pre></td></tr></table></figure><h2 id="Variable变量"><a href="#Variable变量" class="headerlink" title="Variable变量"></a><strong>Variable变量</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">state=tf.Variable(0,name=&quot;counter&quot;) #定义一个变量&quot;state&quot;</span><br><span class="line">#print(state.name)</span><br><span class="line">one=tf.constant(1)  #定义一个常量“1”</span><br><span class="line"></span><br><span class="line">new_value=tf.add(state,one)</span><br><span class="line">update=tf.assign(state,new_value) #将“new_value”赋值给“state”</span><br><span class="line"></span><br><span class="line">init=tf.initialize_all_variables()</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">sess.run(init)</span><br><span class="line">for _ in range(3):</span><br><span class="line">sess.run(update)</span><br><span class="line">print(sess.run(state))</span><br></pre></td></tr></table></figure><h2 id="了解PlaceHold"><a href="#了解PlaceHold" class="headerlink" title="了解PlaceHold"></a><strong>了解PlaceHold</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">input1=tf.placeholder(tf.float32)</span><br><span class="line">input2=tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line">output=tf.add(input1,input2)</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">print(sess.run(output,feed_dict=&#123;input1:[7.],input2:[3.]&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TensorFlow初探&quot;&gt;&lt;a href=&quot;#TensorFlow初探&quot; class=&quot;headerlink&quot; title=&quot;TensorFlow初探&quot;&gt;&lt;/a&gt;&lt;strong&gt;TensorFlow初探&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;第一个
      
    
    </summary>
    
    
      <category term="学习" scheme="http://hustxxj.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TensorFlow" scheme="http://hustxxj.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>健身房人脸识别系统</title>
    <link href="http://hustxxj.github.io/2019/07/08/%E5%81%A5%E8%BA%AB%E6%88%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/"/>
    <id>http://hustxxj.github.io/2019/07/08/%E5%81%A5%E8%BA%AB%E6%88%BF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/</id>
    <published>2019-07-08T07:10:30.000Z</published>
    <updated>2019-07-12T03:28:44.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="健身房人脸识别系统"><a href="#健身房人脸识别系统" class="headerlink" title="健身房人脸识别系统"></a><strong>健身房人脸识别系统</strong></h1><hr><p>该人脸识别系统是健身房管理系统的一个子模块，主要负责对健身房来访客户进行人脸识别，将识别到的人脸与本地人脸库进行比对进而控制闸机开关。同时在前台显示客户的一系列信息，包括当前会员卡状态等等。<br>该子模块主要涉及四个部分：</p><ul><li><strong>安卓人脸识别端</strong></li><li><strong>本地服务器端</strong></li><li><strong>前台工作台</strong></li><li><strong>闸机控制</strong></li></ul><hr><h2 id="安卓人脸识别端"><a href="#安卓人脸识别端" class="headerlink" title="安卓人脸识别端"></a><strong>安卓人脸识别端</strong></h2><hr><p>本模块是用于人脸的采集和上传，是用一个普通的安卓平板实现的。关于人脸识别的实现方法，是调用了百度云的人脸识别离线SDK。这个人脸识别的离线SDK是需要收费的，好像是299可以购买永久使用权（只能与一个设备绑定）。由于实验室经费有限，我们是申请的试用，如果试用期到了可以再申请延期。（已经申请延期三次了，目前为止白嫖了一年。）<br>[百度云人脸识别]（ <a href="https://cloud.baidu.com/product/face" target="_blank" rel="noopener">https://cloud.baidu.com/product/face</a> ）<br>这一部分代码是用Java写的，开发环境是用的AndroidStudio，程序的基本框架使用了官方给的一个Demo,然后在里面修改了一下界面并且添加了通信模块用于将采集到的人脸上传到本地服务器。这里附上安卓端向C++服务器上传照片的代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">private void saveFace(FaceInfo faceInfo, ImageFrame imageFrame) &#123;</span><br><span class="line">       final Bitmap bitmap = FaceCropper.getFace(imageFrame.getArgb(), faceInfo, imageFrame.getWidth());</span><br><span class="line">       if (source == RegActivity.SOURCE_REG) &#123;</span><br><span class="line">           // 注册来源保存到注册人脸目录</span><br><span class="line">           File faceDir = FileUitls.getFaceDirectory();</span><br><span class="line">           if (faceDir != null) &#123;</span><br><span class="line">               String imageName = UUID.randomUUID().toString();</span><br><span class="line">               File file = new File(faceDir, imageName);</span><br><span class="line">               // 压缩人脸图片至300 * 300，减少网络传输时间</span><br><span class="line">               ImageUtils.resize(bitmap, file, 300, 300);</span><br><span class="line">               Intent intent = new Intent();</span><br><span class="line">               intent.putExtra(&quot;file_path&quot;, file.getAbsolutePath());</span><br><span class="line">               setResult(Activity.RESULT_OK, intent);</span><br><span class="line">               finish();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               toast(&quot;注册人脸目录未找到&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               // 其他来源保存到临时目录</span><br><span class="line">               final File file = File.createTempFile(UUID.randomUUID().toString() + &quot;&quot;, &quot;.jpg&quot;);</span><br><span class="line">               // 人脸识别不需要整张图片。可以对人脸区别进行裁剪。减少流量消耗和，网络传输占用的时间消耗。</span><br><span class="line">               ImageUtils.resize(bitmap, file, 300, 300);</span><br><span class="line">               Intent intent = new Intent();</span><br><span class="line">               intent.putExtra(&quot;file_path&quot;, file.getAbsolutePath());</span><br><span class="line">               setResult(Activity.RESULT_OK, intent);</span><br><span class="line">               String picPath = intent.getStringExtra(&quot;file_path&quot;);</span><br><span class="line">               Bitmap bitmap1 = BitmapFactory.decodeFile(picPath);</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   faceDetectManager.setUseDetect(false);</span><br><span class="line">                   // 创建文件流，指向该路径，文件名叫做fileName</span><br><span class="line">                   File file1 = new File(FILE_PATH, newName);</span><br><span class="line">                   // file其实是图片，它的父级File是文件夹，判断一下文件夹是否存在，如果不存在，创建文件夹</span><br><span class="line">                   File fileParent = file1.getParentFile();</span><br><span class="line">                   if (!fileParent.exists()) &#123;</span><br><span class="line">                       // 文件夹不存在</span><br><span class="line">                       fileParent.mkdirs();// 创建文件夹</span><br><span class="line">                   &#125;</span><br><span class="line">                   // 将图片保存到本地</span><br><span class="line">                   bitmap1.compress(Bitmap.CompressFormat.JPEG, 100,</span><br><span class="line">                           new FileOutputStream(file1));</span><br><span class="line">               &#125; catch (Exception e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private String filter(FaceInfo faceInfo, ImageFrame imageFrame) &#123;</span><br><span class="line"></span><br><span class="line">       String tip = &quot;&quot;;</span><br><span class="line">       if (faceInfo.mConf &lt; 0.8) &#123;</span><br><span class="line">           tip = &quot;人脸置信度太低&quot;;</span><br><span class="line">           return tip;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       float[] headPose = faceInfo.headPose;</span><br><span class="line">       if (Math.abs(headPose[0]) &gt; 20 || Math.abs(headPose[1]) &gt; 20 || Math.abs(headPose[2]) &gt; 20) &#123;</span><br><span class="line">           tip = &quot;人脸置角度太大，请正对屏幕&quot;;</span><br><span class="line">           return tip;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int width = imageFrame.getWidth();</span><br><span class="line">       int height = imageFrame.getHeight();</span><br><span class="line">       // 判断人脸大小，若人脸超过屏幕二分一，则提示文案“人脸离手机太近，请调整与手机的距离”；</span><br><span class="line">       // 若人脸小于屏幕三分一，则提示“人脸离手机太远，请调整与手机的距离”</span><br><span class="line">       float ratio = (float) faceInfo.mWidth / (float) height;</span><br><span class="line">       Log.i(&quot;liveness_ratio&quot;, &quot;ratio=&quot; + ratio);</span><br><span class="line">       if (ratio &gt; 0.9) &#123;</span><br><span class="line">           tip = &quot;人脸离屏幕太近，请调整与屏幕的距离&quot;;</span><br><span class="line">           return tip;</span><br><span class="line">       &#125; else if (ratio &lt; 0.1) &#123;</span><br><span class="line">           tip = &quot;人脸离屏幕太远，请调整与屏幕的距离&quot;;</span><br><span class="line">           return tip;</span><br><span class="line">       &#125; else if (faceInfo.mCenter_x &gt; width * 3 / 4 ) &#123;</span><br><span class="line">           tip = &quot;人脸在屏幕中太靠右&quot;;</span><br><span class="line">           return tip;</span><br><span class="line">       &#125; else if (faceInfo.mCenter_x &lt; width / 4 ) &#123;</span><br><span class="line">           tip = &quot;人脸在屏幕中太靠左&quot;;</span><br><span class="line">           return tip;</span><br><span class="line">       &#125; else if (faceInfo.mCenter_y &gt; height * 3 / 4 ) &#123;</span><br><span class="line">           tip = &quot;人脸在屏幕中太靠下&quot; ;</span><br><span class="line">           return tip;</span><br><span class="line">       &#125; else if (faceInfo.mCenter_x &lt; height / 4 ) &#123;</span><br><span class="line">           tip = &quot;人脸在屏幕中太靠上&quot;;</span><br><span class="line">           return tip;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int liveType = PreferencesUtil.getInt(LivenessSettingActivity.TYPE_LIVENSS, LivenessSettingActivity</span><br><span class="line">               .TYPE_NO_LIVENSS);</span><br><span class="line">       if (liveType ==  LivenessSettingActivity.TYPE_NO_LIVENSS) &#123;</span><br><span class="line">           saveFace(faceInfo, imageFrame);</span><br><span class="line">           connection Connection=new connection();</span><br><span class="line">           Connection.start();</span><br><span class="line">           try  &#123;</span><br><span class="line">               Thread.currentThread().sleep(2000);</span><br><span class="line">           &#125;  catch  ( InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace () ;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(&quot;人脸得分为：&quot; + SendFileThread.feedBackScore);</span><br><span class="line">           faceDetectManager.setUseDetect(true);</span><br><span class="line">           if (SendFileThread.feedBackScore &gt;= 90)</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(&quot;阻断五秒&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.currentThread().sleep(count1);</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (SendFileThread.feedBackScore &lt; 90)</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(&quot;阻断一秒&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                       Thread.currentThread().sleep(count2);</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           File file2 = new File(FILE_PATH, newName);</span><br><span class="line">           file2.delete();</span><br><span class="line">       &#125; else if (liveType ==  LivenessSettingActivity.TYPE_RGB_LIVENSS) &#123;</span><br><span class="line"></span><br><span class="line">           if (rgbLiveness(imageFrame, faceInfo) &gt; 0.9) &#123;</span><br><span class="line">               saveFace(faceInfo, imageFrame);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               toast(&quot;rgb活体分数过低&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return tip;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> public class SendFileThread extends Thread implements Runnable &#123;</span><br><span class="line">    static float feedBackScore;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    private NetDataCommand dataCommand;</span><br><span class="line">    private NetDataTypeTransform transform = new NetDataTypeTransform();</span><br><span class="line">    public SendFileThread(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DataInputStream fromServerStream = new DataInputStream(socket.getInputStream());</span><br><span class="line">            DataOutputStream toServerStream = new DataOutputStream(socket.getOutputStream());</span><br><span class="line">//初始化文件信息</span><br><span class="line">            File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/cache/pics/12345678.jpg&quot;);</span><br><span class="line">            FileInputStream fileInputStream = new FileInputStream(file);</span><br><span class="line">            int fileLen = (int)file.length();</span><br><span class="line">            System.out.print(file.length());</span><br><span class="line">            System.out.print(&quot;\r\n&quot;);</span><br><span class="line">//1.发送文件的长度</span><br><span class="line">            toServerStream.write(transform.IntToByteArray(fileLen));</span><br><span class="line">            toServerStream.flush();</span><br><span class="line">//2.确认服务器端已经做好准备</span><br><span class="line">            Boolean isOk;</span><br><span class="line">            isOk = fromServerStream.readBoolean();</span><br><span class="line">            System.out.println(isOk);</span><br><span class="line">            byte[] toServerByte = new byte[4096];</span><br><span class="line">            int len;//每次发送长度</span><br><span class="line">            long sendLen=0;//已经发送的总长度</span><br><span class="line">            while((len = fileInputStream.read(toServerByte))&gt;0)&#123;</span><br><span class="line">                toServerStream.write(toServerByte,0,len);</span><br><span class="line">                toServerStream.flush();</span><br><span class="line">                sendLen+=len;</span><br><span class="line">                System.out.println(&quot;len = &quot;+len);</span><br><span class="line">                System.out.println(&quot;发送进度：&quot;+sendLen*1.0/fileLen*1.0*100+&quot;%&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(10);</span><br><span class="line">            if (sendLen == fileLen) &#123;</span><br><span class="line">                System.out.println(&quot;success&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;send over!&quot;);</span><br><span class="line">            byte buffer[] = new byte[536];</span><br><span class="line">            while (fromServerStream.read(buffer, 0, 536) &gt; -1)</span><br><span class="line">            &#123;</span><br><span class="line">                String mm=new String(buffer);</span><br><span class="line">                String score=mm.substring(0,5);</span><br><span class="line">                feedBackScore=Float.parseFloat(score);</span><br><span class="line">                System.out.println(feedBackScore);</span><br><span class="line">                System.out.println(&quot;接收成功！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> public class connection extends Thread implements Runnable &#123;</span><br><span class="line">    private static DataOutputStream toServerStream;</span><br><span class="line">    private static NetDataCommand dataCommand;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Socket socket = new Socket(&quot;IP地址&quot;, 端口号);</span><br><span class="line">            Socket socket = new Socket(&quot;IP地址&quot;, 端口号);</span><br><span class="line">            toServerStream = new DataOutputStream(socket.getOutputStream());</span><br><span class="line">//发送要发送文件的指令</span><br><span class="line">            int id = 1;</span><br><span class="line">            String tempStr = &quot;12345678.jpg&quot;;</span><br><span class="line">            dataCommand = new NetDataCommand(id, tempStr);</span><br><span class="line">            toServerStream.write(dataCommand.getByteArrayData());</span><br><span class="line">            toServerStream.flush();</span><br><span class="line">//启动发送文件线程</span><br><span class="line">            SendFileThread sendFileThread = new SendFileThread(socket);</span><br><span class="line">            sendFileThread.start();</span><br><span class="line">            try  &#123;</span><br><span class="line">                sendFileThread.join();</span><br><span class="line">            &#125;  catch  ( InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace () ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="本地服务器端"><a href="#本地服务器端" class="headerlink" title="本地服务器端"></a><strong>本地服务器端</strong></h2><hr><p>本地服务器主要有以下几个功能：</p><ul><li><em>人脸注册</em></li><li><em>人脸识别及信息转发</em></li></ul><h3 id="1-人脸注册"><a href="#1-人脸注册" class="headerlink" title="1. 人脸注册"></a>1. 人脸注册</h3><p>百度给的离线人脸识别SDK(Windows)中提供了批量人脸注册的接口，将所有已有会员的人脸照片存放在指定文件夹中然后运行该函数就可以实现人脸注册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test_face_manager(BaiduFaceApi* api)</span><br><span class="line">&#123;</span><br><span class="line">    Manager *mgrptr = new Manager();</span><br><span class="line">    // 批量注册</span><br><span class="line">    mgrptr-&gt;batch_user_add(api, &quot;d:\\FaceStock&quot;);</span><br><span class="line">    delete mgrptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-人脸识别及信息转发"><a href="#2-人脸识别及信息转发" class="headerlink" title="2. 人脸识别及信息转发"></a>2. 人脸识别及信息转发</h3><p>该部分是服务器主要要完成的功能，即接收从平板传递过来的人脸，在服务器进行人脸识别后解析出该人脸对应的会员号，然后将会员号发送给前台控制台。其中涉及到两部分的通信，一个是平板和本地服务器的通信，另一个是本地服务器和前台控制台的通信。</p><p>平板和本地服务器通信（其中为了防止平板端向服务器发送人脸的频率太高造成服务器崩溃，引入了Mutex线程锁机制，来保护每一个发送人脸的线程独立）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">void InitSocket() &#123;</span><br><span class="line">    SOCKET serverSocket;</span><br><span class="line">    SOCKET listenSocket;</span><br><span class="line">    sockaddr_in serveraddr = initSockaddr_in();</span><br><span class="line">    sockaddr_in clientaddr;</span><br><span class="line">    //创建socket</span><br><span class="line">    serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    //进行绑定</span><br><span class="line">    ::bind(serverSocket, (sockaddr*)&amp;serveraddr, sizeof(serveraddr));</span><br><span class="line">    //进行监听</span><br><span class="line">    listen(serverSocket, 5);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;server start&quot; &lt;&lt; endl;</span><br><span class="line">    int len = sizeof(clientaddr);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (listenSocket = accept(serverSocket, (sockaddr*)&amp;clientaddr, &amp;len));</span><br><span class="line">        &#123;</span><br><span class="line">            //启动会话线程</span><br><span class="line">            CreateThread(NULL, NULL, SListen, (LPVOID)listenSocket, NULL, NULL);</span><br><span class="line">            //添加线程锁</span><br><span class="line">            DWORD dwRet = WaitForSingleObject(CreateThread, INFINITE);</span><br><span class="line">            if (dwRet == WAIT_TIMEOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                TerminateThread(CreateThread, 0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; &quot;CreateThread is start&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in initSockaddr_in() &#123;</span><br><span class="line">    sockaddr_in sockaddr_in;</span><br><span class="line">    int port = 8888;</span><br><span class="line">    sockaddr_in.sin_family = AF_INET;</span><br><span class="line">    sockaddr_in.sin_port = htons(port);//主机字节序转网络字节序</span><br><span class="line">    sockaddr_in.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line">    return sockaddr_in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI SListen(LPVOID lparam) &#123;</span><br><span class="line">    SOCKET socket = (SOCKET)lparam;</span><br><span class="line">    COMMAND command;</span><br><span class="line">    control = 1;</span><br><span class="line">    while (control == 1) &#123;</span><br><span class="line">        memset(&amp;command, 0, sizeof(command));</span><br><span class="line">        int ret;</span><br><span class="line">        ret = recv(socket, (char*)&amp;command, sizeof(command), 0);</span><br><span class="line">        if (ret == SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;接收命令错误或溢出！&quot; &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            cout &lt;&lt; &quot;接收到命令：&quot; &lt;&lt; command.ID &lt;&lt; endl;</span><br><span class="line">            switch (command.ID)</span><br><span class="line">            &#123;</span><br><span class="line">            case FileInfo:</span><br><span class="line">                break;</span><br><span class="line">            case SendFile:</span><br><span class="line">            &#123;</span><br><span class="line">                char* str = (char*)command.lparam;</span><br><span class="line">                cout &lt;&lt; &quot;原文件名&quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">                //开始接收文件</span><br><span class="line">                recvFile(socket);</span><br><span class="line">                //发送人脸得分给平板端</span><br><span class="line">                char scores[20];</span><br><span class="line">                sprintf(scores, &quot;%f&quot;, score);</span><br><span class="line">                send(socket, scores, 200, NULL);</span><br><span class="line">                cout &lt;&lt; &quot;scores=&quot; &lt;&lt; scores &lt;&lt; endl;</span><br><span class="line">                //向客户端发送会员号</span><br><span class="line">                SendUserNumber();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            case StopSendFile:</span><br><span class="line">                break;</span><br><span class="line">            case SendString:</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recvFile(SOCKET socket) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    char buffer[BUF_LEN];</span><br><span class="line">    //接收文件长度</span><br><span class="line">    long long fileLenght = 0;</span><br><span class="line">    cout &lt;&lt; fileLenght &lt;&lt; endl;</span><br><span class="line">    while (fileLenght == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = recv(socket, (char*)&amp;fileLenght, sizeof(fileLenght), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    //  ret = recv(socket, (char*)&amp;fileLenght, sizeof(fileLenght), 0);</span><br><span class="line">    if (ret == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;接收文件长度失败&quot; &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; fileLenght &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;文件长度为：&quot; &lt;&lt; fileLenght &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //告诉客户端可以发送文件了</span><br><span class="line">    bool isOk = true;</span><br><span class="line">    //启动线程锁保护要传输的文件</span><br><span class="line">    CLock lock(g_Lock);</span><br><span class="line"></span><br><span class="line">    ret = send(socket, (char*)&amp;isOk, sizeof(isOk), 0);</span><br><span class="line">    if (ret == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;发送信息失败！&quot; &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //文件路径</span><br><span class="line">    char fileName[20];</span><br><span class="line">    string filePath;</span><br><span class="line">    SYSTEMTIME sys;</span><br><span class="line">    GetLocalTime(&amp;sys);</span><br><span class="line">    sprintf_s(fileName, &quot;test.jpg&quot;/*, sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond*/);</span><br><span class="line">    filePath = &quot;D:\\&quot;;</span><br><span class="line">    filePath += fileName;</span><br><span class="line">    //打开文件</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(filePath, ios::out | ios::binary);//传输图片使用二进制格式打开</span><br><span class="line">    if (!outfile) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;fail to open file!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    long recvTotalLen = 0;</span><br><span class="line">    while (recvTotalLen &lt; fileLenght) &#123;</span><br><span class="line">        memset(buffer, 0, sizeof(buffer));</span><br><span class="line">        ret = recv(socket, buffer, sizeof(buffer), 0);</span><br><span class="line">        if (ret == SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Error:&quot; &lt;&lt; GetLastError() &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;socket fail when recv file fail !&quot; &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        outfile.write(buffer, ret);</span><br><span class="line">        recvTotalLen += ret;</span><br><span class="line">        cout &lt;&lt; &quot;已接收：&quot; &lt;&lt; (recvTotalLen*1.0 / fileLenght*1.0) * 100 &lt;&lt; &quot;%&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (recvTotalLen == fileLenght)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;recv file success !&quot; &lt;&lt; endl;</span><br><span class="line">        control = 2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;recv file error !&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">   //获取会员号，显示对比结果</span><br><span class="line">    std::string res = api-&gt;identify(&quot;d:\\test.jpg&quot;, 2, &quot;test_group2&quot;, &quot;&quot;);</span><br><span class="line">    std::cout &lt;&lt; &quot;---identify res is:&quot; &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    char* id = parse_id(res);</span><br><span class="line">    score = parse_score(res);</span><br><span class="line">    memset(useNumber, &apos;\0&apos;, sizeof(useNumber));</span><br><span class="line">    for (int i = 0; i &lt; 12; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        useNumber[i] = id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;userNumber=&quot; &lt;&lt; useNumber &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务器与前台控制台通信，向前台控制台发送会员号：由于我人脸库中的人脸命名是以会员号命名的（会员号是健身房会员的唯一标识），所以在识别到人脸后，解析出该人脸对应的会员号(以JSON格式保存，需要对其进行解析)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">char * parse_id(const std::string &amp; res) //解析会员号</span><br><span class="line">&#123;</span><br><span class="line">    if (res.length() &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        // 若出现json::reader编译不过，请用下面代码</span><br><span class="line">        Json::Value root;</span><br><span class="line">        Json::Reader reader;</span><br><span class="line">        if (reader.parse(res, root))</span><br><span class="line">        &#123;</span><br><span class="line">            int err = root[&quot;errno&quot;].asInt();</span><br><span class="line">            if (err == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                Json::Value result = root[&quot;data&quot;];</span><br><span class="line">                if (result.size() &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::string user_id = result[&quot;result&quot;][0][&quot;user_id&quot;].asString();</span><br><span class="line">                    const char *id = user_id.c_str();</span><br><span class="line">                    strcpy(user_ID, id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                strcpy(user_ID, &quot;读取ID错误&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return user_ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float parse_score(const std::string &amp; res)  //解析出人脸得分</span><br><span class="line">&#123;</span><br><span class="line">    float score = 0;</span><br><span class="line">    if (res.length() &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        // 若出现json::reader编译不过，请用下面代码</span><br><span class="line">        Json::Value root;</span><br><span class="line">        Json::Reader reader;</span><br><span class="line">        if (reader.parse(res, root))</span><br><span class="line">        &#123;</span><br><span class="line">            int err = root[&quot;errno&quot;].asInt();</span><br><span class="line">            if (err == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                Json::Value result = root[&quot;data&quot;];</span><br><span class="line">                if (result.size() &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    //std::string sss = result[&quot;score&quot;].asString();</span><br><span class="line">                    std::string sss = result[&quot;result&quot;][0][&quot;score&quot;].asString();</span><br><span class="line">                    std::cout &lt;&lt; &quot;score=&quot; &lt;&lt; sss &lt;&lt; std::endl;</span><br><span class="line">                    score = atof(sss.c_str());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                score = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SendUserNumber()</span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData; </span><br><span class="line">    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);//初始化 </span><br><span class="line">    SOCKET s = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP); </span><br><span class="line">    sockaddr_in sockaddr; </span><br><span class="line">    sockaddr.sin_family = PF_INET; </span><br><span class="line">    sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); </span><br><span class="line">    sockaddr.sin_port = htons(234);//设置要连接的IP和端口 </span><br><span class="line">    connect(s,(SOCKADDR*)&amp;sockaddr,sizeof(SOCKADDR));//tcp连接 </span><br><span class="line">    if (score &gt; 90.0)</span><br><span class="line">    &#123;</span><br><span class="line">        send(s, useNumber, 200, NULL);</span><br><span class="line">        printf(useNumber);</span><br><span class="line">        cout &lt;&lt; &quot;人脸得分合格！&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;会员号发送成功&quot; &lt;&lt; endl;</span><br><span class="line">        WSACleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;人脸得分太低！&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;健身房人脸识别系统&quot;&gt;&lt;a href=&quot;#健身房人脸识别系统&quot; class=&quot;headerlink&quot; title=&quot;健身房人脸识别系统&quot;&gt;&lt;/a&gt;&lt;strong&gt;健身房人脸识别系统&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;该人脸识别系统是健身房管理系统的一个子模
      
    
    </summary>
    
    
      <category term="项目" scheme="http://hustxxj.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="健身房" scheme="http://hustxxj.github.io/tags/%E5%81%A5%E8%BA%AB%E6%88%BF/"/>
    
  </entry>
  
</feed>
