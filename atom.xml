<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江江的小跟班.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hustxxj.github.io/"/>
  <updated>2020-03-26T02:34:10.131Z</updated>
  <id>http://hustxxj.github.io/</id>
  
  <author>
    <name>Xuxuejie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer——28.数组中出现次数超过一半的数字（876-999-f17.16）</title>
    <link href="http://hustxxj.github.io/2020/03/26/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9428.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://hustxxj.github.io/2020/03/26/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9428.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-03-26T01:06:15.000Z</published>
    <updated>2020-03-26T02:34:10.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用map对每个数字出现的次数进行计数，并且判断计数是否超过长度的一半。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cot[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(cot[numbers[i]]&gt;(len/<span class="number">2</span>))</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：999-车的可用捕获量"><a href="#LeetCode练习（数组）：999-车的可用捕获量" class="headerlink" title="LeetCode练习（数组）：999.车的可用捕获量"></a><strong>LeetCode练习（数组）：999.车的可用捕获量</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p><p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p><p>返回车能够在一次移动中捕获到的卒的数量。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hang=board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(hang==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lie=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> location_x,location_y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hang;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator it=<span class="built_in">find</span>(board[i].<span class="built_in">begin</span>(),board[i].<span class="built_in">end</span>(),<span class="string">'R'</span>);</span><br><span class="line">            <span class="keyword">if</span>(it!=board[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                location_x=i;</span><br><span class="line">                location_y=it-board[i].<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//'R'的坐标为board[location_x][location_y]</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左找'p',如果找到'p'之前先遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_y<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_y+<span class="number">1</span>;i&lt;=lie<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_x<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向下找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_x+<span class="number">1</span>;i&lt;=hang<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（快慢指针）：876-链表的中间结点"><a href="#LeetCode练习（快慢指针）：876-链表的中间结点" class="headerlink" title="LeetCode练习（快慢指针）：876.链表的中间结点"></a><strong>LeetCode练习（快慢指针）：876.链表的中间结点</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针实现，需要注意while结束边界条件</span></span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：面试题17-16-按摩师"><a href="#LeetCode练习（动态规划）：面试题17-16-按摩师" class="headerlink" title="LeetCode练习（动态规划）：面试题17.16.按摩师"></a><strong>LeetCode练习（动态规划）：面试题17.16.按摩师</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i][0]表示当前预约不接，所获得最大钱数</span></span><br><span class="line"><span class="comment">dp[i][0]=max&#123;dp[i-1][0],dp[i-1][1]&#125;;</span></span><br><span class="line"><span class="comment">dp[i][1]表示当前预约接，所获得最大钱数</span></span><br><span class="line"><span class="comment">dp[i][1]=dp[i-1][0]+nums[i];</span></span><br><span class="line"><span class="comment">result=max&#123;dp[len-1][0],dp[len-1][1]&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[len<span class="number">-1</span>][<span class="number">0</span>],dp[len<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>基础查找算法整理</title>
    <link href="http://hustxxj.github.io/2020/03/23/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://hustxxj.github.io/2020/03/23/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-03-23T12:19:40.000Z</published>
    <updated>2020-03-24T12:39:46.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5种基础的查找算法"><a href="#5种基础的查找算法" class="headerlink" title="5种基础的查找算法"></a><strong>5种基础的查找算法</strong></h1><hr><p>本文对7种基础的查找算法做了整理，包括顺序查找（不做讨论）、二分查找、插值查找、哈希查找、二叉搜索树查找以及红黑树。实现了这5中查找算法的代码并讨论了各自的时间复杂度和空间复杂度。</p><hr><h2 id="01-二分查找"><a href="#01-二分查找" class="headerlink" title="#01.二分查找"></a><strong>#01.二分查找</strong></h2><hr><p>对于一个常规的<em>有序</em>数组而言，进行二分查找的思路比较简单。将所要查找的元素每次和数组的中间元素进行比较，如果大于中间元素值，则对数组的后半部分进行二分查找；如果小于中间元素，则对数组的前半部分进行二分查找。</p><p>二分查找的时间复杂度为O(logN)，空间复杂度为O(1)，要求数组是有序的。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">        &#123;</span><br><span class="line">            index=mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//简单二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>简单二分查找要求数组需要是一个常规有序数组，现在考虑利用二分查找对一个<em>旋转有序数组</em>进行查找。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//旋转数组二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_Rotate_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=a[left])   <span class="comment">//左边有序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=a[left] &amp;&amp; target&lt;a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右边有序</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;=a[right] &amp;&amp; target&gt;a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_Rotate_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="02-插值查找"><a href="#02-插值查找" class="headerlink" title="#02.插值查找"></a><strong>#02.插值查找</strong></h2><hr><p>插值查找是对二分查找的改进，适用于数组数据分布比较均匀的情况，但是如果数组分布较极端那么插值查找的效率反而不如二分查找。</p><p>二分查找的公式为：</p><p><code><img src="/2020/03/23/基础查找算法整理/02_01.jpg" title="示例图"></code></p><p>插值查找的公式为：</p><p><code><img src="/2020/03/23/基础查找算法整理/02_02.jpg" title="示例图"></code></p><p>插值查找的平均期望复杂度为O(loglogN)，空间复杂度为O(1)，要求数组是有序的。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=left+((target-a[left])/(a[right]-a[left]))*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="03-哈希查找"><a href="#03-哈希查找" class="headerlink" title="#03.哈希查找"></a><strong>#03.哈希查找</strong></h2><hr><p>哈希查找是指：将所要查找的值带入哈希函数中，直接索引出值的位置。即：index=H(value)，H()表示哈希函数。</p><p><strong>哈希函数的构造方式</strong>：哈希函数的构造方式通常有五种</p><p>1&gt;直接定址法：H(value)=a x value+b，这种形式适合于表较小且连续的情况。</p><p>2&gt;数字分析法</p><p>3&gt;平方取中法</p><p>4&gt;折叠法</p><p>5&gt;除数留余法：H(value)=value MOD p （p&lt;=m，m为表长）。该方法是用的最多的方法。</p><p><strong>解决哈希冲突的方法</strong>：解决哈希冲突的方法通常有四种，开放定制法，链地址法，公共溢出区法，再散列法。主要介绍前两种常见方法。</p><p>1&gt;<strong>开放定制法</strong>：如果两个数value_x（前），value_y（后）的哈希函数值发生冲突，H(value_x)==H(value_y)，那么H(value_y)会改为H(value_y)+D </p><p>D的取值有三种取法：</p><p>①线性探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_01.jpg" title="示例图"></code></p><p>②平方探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_02.jpg" title="示例图"></code></p><p>③随机探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_03.jpg" title="示例图"></code></p><p>2&gt; <strong>链地址法</strong>：产生哈希冲突后再存储数据后面加一个指针，指向后面冲突的数据</p><p><code><img src="/2020/03/23/基础查找算法整理/03_04.jpg" title="示例图"></code></p><p>需要注意的是哈希表在删除元素时：链地址法可以直接删除；<em>但是对于开放定制法，如果直接删除前面的元素就会导致后面的元素无法索引到，所以需要在删除时插入一个原来不存在的数据如-1。</em></p><p>哈希查找的时间复杂度为O(1)，空间复杂度为O(n)，对于要查找的数组是否有序没有要求。</p><hr><h2 id="04-二叉搜索树查找"><a href="#04-二叉搜索树查找" class="headerlink" title="#04.二叉搜索树查找"></a><strong>#04.二叉搜索树查找</strong></h2><hr><p>首先介绍一下<strong>什么是二叉搜索树</strong>，二叉搜索树满足以下条件：</p><p>①若它的左子树不为空，则<strong>左子树上所有节点</strong>的值均小于它根节点的值</p><p>②若它的右子树不为空，则<strong>右子树上所有节点</strong>的值均大于它根节点的值</p><p><code><img src="/2020/03/23/基础查找算法整理/04_01.jpg" title="示例图"></code></p><p>二叉搜索树的查找时间复杂度受树的深度影响，平均时间复杂度为O(logN)</p><hr><p>1&gt;二叉搜索树查找最大值：从根节点一直往右走，直到无路可走，遍可访问到最大值节点。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchMax</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> SearchMax(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>2&gt;二叉搜索树查找最小值：从根节点一直往左走，直到无路可走，遍可以访问到最小值节点。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchMin</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(rooy-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> SearchMin(root-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3&gt;二叉搜索数进行一般查找</p><p>①递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchValue</span><span class="params">(TreeNode* root,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val==target)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; target)</span><br><span class="line">        <span class="keyword">return</span> SearchValue(root-&gt;left,target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; target)</span><br><span class="line">        <span class="keyword">return</span> SearchValue(root-&gt;right,target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②非递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchValue</span><span class="params">(TreeNode* root,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode* ptr=root;</span><br><span class="line">    <span class="keyword">while</span>(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;val==target)</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        </span><br><span class="line">        ptr=(root-&gt;val &gt; target)?ptr-&gt;left:ptr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="05-红黑树"><a href="#05-红黑树" class="headerlink" title="#05.红黑树"></a><strong>#05.红黑树</strong></h2><hr><p><a href="https://www.jianshu.com/p/104fa73c81b3" target="_blank" rel="noopener">https://www.jianshu.com/p/104fa73c81b3</a></p><p><a href="https://blog.csdn.net/hackbuteer1/article/details/7740956" target="_blank" rel="noopener">https://blog.csdn.net/hackbuteer1/article/details/7740956</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5种基础的查找算法&quot;&gt;&lt;a href=&quot;#5种基础的查找算法&quot; class=&quot;headerlink&quot; title=&quot;5种基础的查找算法&quot;&gt;&lt;/a&gt;&lt;strong&gt;5种基础的查找算法&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;本文对7种基础的查找算法做了整理，包括顺
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://hustxxj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://hustxxj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——27.字符串的排列（67-136-f40）</title>
    <link href="http://hustxxj.github.io/2020/03/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9427.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9427.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2020-03-20T07:10:48.000Z</published>
    <updated>2020-03-23T13:50:53.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>a,b,c全排列得出的所有字符串，可以看做：</p><ol><li><p>以a开头，（b,c）全排列得出的字符串</p></li><li><p>以b开头，（a,c）全排列得出的字符串</p></li><li><p>以c开头，（a,b）全排列得出的字符串</p></li></ol><p>   <em>定义Permutation1（string str,int begin,vector<string>result）：</string></em></p><p>   表示从str的第begin个字符开始，计算str的全排列，将结果放入result中。</p><p>   显然，当begin==str.size()-1的时候，全排列只存在一种，就是当下的str，所以将str放入result中。</p><p>   而当begin!=str.size()时：</p><p>   ​       ①交换a和a的顺序，计算（b，c）的全排列</p><p>   ​       ②交换a和b的顺序，计算（a，c）的全排列</p><p>   ​       ③交换a和c的顺序，计算（b，a）的全排列</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(str.empty()) <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">        Permutation1(str,result,<span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 此时得到的result中排列并不是字典顺序，可以单独再排下序</span></span><br><span class="line">        sort(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Permutation1</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result,<span class="keyword">int</span> <span class="built_in">begin</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == str.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="comment">// 递归结束条件：索引已经指向str最后一个元素时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>(),str) == result.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果result中不存在str，才添加；避免aa和aa重复添加的情况</span></span><br><span class="line">                result.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一次循环i与begin相等，相当于第一个位置自身交换，关键在于之后的循环，</span></span><br><span class="line">            <span class="comment">// 之后i != begin，则会交换两个不同位置上的字符，直到begin==str.size()-1，进行输出；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">begin</span>;i&lt;str.<span class="built_in">size</span>();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(str[i],str[<span class="built_in">begin</span>]);</span><br><span class="line">                Permutation1(str,result,<span class="built_in">begin</span>+<span class="number">1</span>);</span><br><span class="line">                swap(str[i],str[<span class="built_in">begin</span>]); <span class="comment">// 复位，用以恢复之前字符串顺序，达到第一位依次跟其他位交换的目的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> &amp;fir,<span class="keyword">char</span> &amp;sec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = fir;</span><br><span class="line">        fir = sec;</span><br><span class="line">        sec = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：面试题40-最小的K个数"><a href="#LeetCode练习（数组）：面试题40-最小的K个数" class="headerlink" title="LeetCode练习（数组）：面试题40.最小的K个数"></a><strong>LeetCode练习（数组）：</strong>面试题40.最小的K个数</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：67-二进制求和"><a href="#LeetCode练习（字符串）：67-二进制求和" class="headerlink" title="LeetCode练习（字符串）：67.二进制求和"></a><strong>LeetCode练习（字符串）：67.二进制求和</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/20/剑指Offer——27.字符串的排列/27_67.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> max_len=(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())?b.<span class="built_in">size</span>():a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=b.<span class="built_in">size</span>();i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            b=temp+b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a.<span class="built_in">size</span>();i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            a=temp+a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isadd=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'0'</span> &amp;&amp; b[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                isadd=<span class="literal">false</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'0'</span> &amp;&amp; b[i]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">false</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'1'</span> &amp;&amp; b[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">false</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'1'</span> &amp;&amp; b[i]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isadd==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：136-只出现一次的数字"><a href="#LeetCode练习（数组）：136-只出现一次的数字" class="headerlink" title="LeetCode练习（数组）：136.只出现一次的数字"></a><strong>LeetCode练习（数组）：136.只出现一次的数字</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/20/剑指Offer——27.字符串的排列/27_136.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                out = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]==nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                out = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>基础排序算法整理</title>
    <link href="http://hustxxj.github.io/2020/03/19/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://hustxxj.github.io/2020/03/19/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-03-19T01:46:35.000Z</published>
    <updated>2020-03-23T08:09:47.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9种基础的排序算法"><a href="#9种基础的排序算法" class="headerlink" title="9种基础的排序算法"></a><strong>9种基础的排序算法</strong></h1><hr><p>撰写本文意在帮助自己复习巩固基础的10大排序算法，分析每种排序算法的原理及实现思路。同时对各个排序算法的时间复杂度，空间复杂度以及稳定性进行了总结。</p><hr><h2 id="01-冒泡排序"><a href="#01-冒泡排序" class="headerlink" title="#01.冒泡排序"></a><strong>#01.冒泡排序</strong></h2><hr><p>冒泡排序的基本思想就是对数值进行两两比较，如果出现反序，则交换两个数值的位置。一直到序列中没有反序为止。<br>实现过程：（以将数据从小到大排序为目标）</p><ol><li>从数组起始点开始，比较相邻的两个数据，如果后一个数据<em>小于</em>前一个数据，则交换两个数据的位置。</li><li>继续以上步骤，知道遍历完数组元素。完成第一次遍历。</li><li>从数组的第二个元素开始，再次两两比较，如果后一个数据<em>小于</em>前一个数据，则交换两个数据的位置。</li><li>重复上述步骤直到数组完全有序。</li></ol><hr><p>实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//冒泡排序(从小到大)</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每比较完一轮，就会将最大值放到数组的尾部，所以剩余需要比较的数为len-1-i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&gt;ex[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=ex[j];</span><br><span class="line">                ex[j]=ex[j+<span class="number">1</span>];</span><br><span class="line">                ex[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>时间复杂度：</p><ol><li>按照上述基本方法进行冒泡排序，需要进行n次循环，第一循环需要进行n-1次比较，第二次循环需要进行n-2次比较，以此类推… （1+2+3+…+n-1）=n(n-1)/2，所以最好最坏的时间复杂度都是O(n2)；</li><li>如果对上述方法进行优化，<em>最好情况下</em>，时间复杂度为O(n)。</li></ol><p>空间复杂度：</p><ol><li>由于完成排序没有利用新的内存空间，所以空间复杂度是O(1)。</li></ol><p>稳定性：</p><ol><li>排序后没有影响数据的位置关系，是稳定的。</li></ol><hr><h2 id="02-选择排序"><a href="#02-选择排序" class="headerlink" title="#02.选择排序"></a><strong>#02.选择排序</strong></h2><hr><p>选择排序的基本思想是（从小到大排序）：</p><ol><li>第一次遍历n-1个数，找出最小的元素与第1个数进行位置交换</li><li>第二次遍历n-2个数，找出最小值与第2个数进行位置交换。<br>…</li><li>第n-1次遍历，找到最小元素与第n-1个元素进行交换<br>排序完成</li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//得出第i轮遍历找到的最小值</span></span><br><span class="line">        <span class="keyword">int</span> min_value=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&lt;ex[min_value])</span><br><span class="line">            &#123;</span><br><span class="line">                min_value=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换位置</span></span><br><span class="line">        <span class="keyword">int</span> temp=ex[i];</span><br><span class="line">        ex[i]=ex[min_value];</span><br><span class="line">        ex[min_value]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>第一遍排序，需要进行n-1次比较；第二遍排序，需要进行n-2次比较；…第n-2轮排序，需要进行1次比较。<br>1+2+3+…+n-1=n(n-1)/2，所以时间复杂度为O(n2)</li></ol><p>空间复杂度：</p><ol><li>没有开辟新的内存空间，所以O(1)</li></ol><p>稳定性：</p><ol><li>不是稳定的。两个相等的元素，在排序前后相对位置有可能发生变化</li></ol><hr><h2 id="03-插入排序"><a href="#03-插入排序" class="headerlink" title="#03.插入排序"></a><strong>#03.插入排序</strong></h2><hr><p>插入排序的基本思路是：</p><ol><li>对于一个数组，假定前n-1个数据是已经排序好的。</li><li>现在将第n个元素插入到前面已序的n-1个数据中，使得这n个数据已序。</li><li>令n=1，2，… ，反复循环直到全部排序好。</li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&lt;ex[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=ex[j];</span><br><span class="line">                ex[j]=ex[j<span class="number">-1</span>];</span><br><span class="line">                ex[j<span class="number">-1</span>]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复制度：</p><ol><li>最好的情况，如果数组已经是一个已序数组，那么只需要经过n次比较就可以得出结果，时间复杂度为O(n)。</li><li>最坏的情况，如果数组是一个逆序数组，那么需要比较1+2+3+…+n-1=n(n-1)/2次，时间复杂度为O(n2)。</li></ol><p>空间复杂度：</p><ol><li>没有利用新的空间，空间复杂度为O(1)。</li></ol><p>算法稳定性：</p><ol><li>相等数据在排序前后，相对位置没有发生变化，所以是稳定的。</li></ol><hr><h2 id="04-快速排序"><a href="#04-快速排序" class="headerlink" title="#04.快速排序"></a><strong>#04.快速排序</strong></h2><hr><p>快速排序的基本思想是利用分治法：</p><ol><li><p>选基准数。先从数列中取出一个数作为基准数</p></li><li><p>分区过程。将比基准数大的数全部放到它的右边，比基准数小的数全部放到它的左边。</p></li><li><p>迭代。对左右分区再进行上述操作。</p><p><em>具体代码实现思路（挖坑填数）：</em></p><ol><li>取i=L（区间左边界），j=R（区间右边界）。将基准数BASE设为a[i]，作为第一个坑。</li><li>j–从右向左搜寻，找到小于BASE的数则挖出这个数，填入坑a[i]中。</li><li>i++从左往右搜寻，找到大于BASE的数则挖出这个数，填入前一步挖出的坑a[j]中。</li><li>重复执行2,3步直到i==j，然后将BASE放入a[i]中。</li></ol></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fast_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=right;</span><br><span class="line">        <span class="keyword">int</span> BASE=a[i];</span><br><span class="line">        <span class="keyword">while</span>(i!=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;i;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;BASE)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i]=a[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;j;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;BASE)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[j]=a[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i]=BASE;</span><br><span class="line"></span><br><span class="line">        Fast_sort(a,left,i<span class="number">-1</span>);</span><br><span class="line">        Fast_sort(a,i+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    Fast_sort(ex,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li><p>如果数组本身已经是一个有序的数组，最好情况下时间复杂度为O(n*logn)。</p></li><li><p>如果数组是个逆序数组，那么此时时间复杂度最高，为O(n^2)。</p></li></ol><p>   空间复杂度：</p><ol><li>没有利用新的空间，空间复杂度O(1)。</li></ol><pre><code>算法稳定性：1. 不稳定</code></pre><hr><h2 id="05-堆排序"><a href="#05-堆排序" class="headerlink" title="#05.堆排序"></a><strong>#05.堆排序</strong></h2><hr><p>堆排序的基本原理：</p><ol><li><p>将一个无序序列构建成一个堆，如果需要序后的数组为升序排列则构建成大顶堆，如果序后数组为降序排列则构建成小顶堆。</p><p>（以升序排列为例）</p></li><li><p>将堆顶元素与末尾元素交换，将最大元素下沉到数组末端。</p></li><li><p>重新调整结构，使其满足大顶堆的定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换，知道整个序列有序。</p></li></ol><p>   <em>原理说明可以参考下面的博客：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></em></p><p>   <em>代码实现参考下面博客：<a href="https://www.cnblogs.com/skywang12345/p/3602162.html#a42" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3602162.html#a42</a></em></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxtopheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> sta,<span class="keyword">int</span> en)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current=sta;             <span class="comment">//当前节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> left=sta*<span class="number">2</span>+<span class="number">1</span>;            <span class="comment">//当前节点左子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> value=a[current];        <span class="comment">//当前节点的值</span></span><br><span class="line">    <span class="keyword">for</span>(;left&lt;en;current=left,left=left*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[left]&lt;a[left+<span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;=a[left])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[current]=a[left];</span><br><span class="line">            a[left]=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_ASCSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将数组a构成大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(length/<span class="number">2</span>)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        maxtopheap(a,i,length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换+继续重组成大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];</span><br><span class="line">        a[i]=a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>]=temp;</span><br><span class="line">        maxtopheap(a,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序(从小到大)</span></span><br><span class="line">    Heap_ASCSort(ex,len);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>堆排序最优情况下，最差情况下以及平均时间复杂度都为O(n*logn)</li></ol><p>   空间复杂度:</p><ol><li>只涉及元素直接的调换，空间复杂度为O(1)</li></ol><pre><code>算法稳定性：1. 不稳定</code></pre><hr><h2 id="06-归并排序"><a href="#06-归并排序" class="headerlink" title="#06.归并排序"></a><strong>#06.归并排序</strong></h2><hr><p>归并排序的基本原理：</p><p><em>归并排序时基于两组已序的数组进行合并，时间复杂度为O(n)这一事实实现的</em></p><ol><li><p>将数据分为A，B两组，如果这A，B分别都是已序数组，那么就可以很方便的将两组数据合并成一个有序数组。</p></li><li><p>如何实现A，B数组的已序？就是再对A，B进行划分，直到每个小组只有1个元素，那么就可以任务这个小组组内有序了。</p></li><li><p>然后再逐层合并实现整体的已序。</p><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/6_1.jpg" title="示例图"></code></p></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; before,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; after)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(before[i]&lt;before[j])</span><br><span class="line">        &#123;</span><br><span class="line">            after[k++]=before[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            after[k++]=before[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">        after[k++]=before[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        after[k++]=before[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并以后还需要反向赋值回原数组，以便留给后续迭代使用</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        before[left + i] = after[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; before,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; after)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        Merge_sort(before,left,mid,after);          <span class="comment">//左边归并排序</span></span><br><span class="line">        Merge_sort(before,mid+<span class="number">1</span>,right,after);       <span class="comment">//右边归并排序</span></span><br><span class="line">        MergeArray(before,left,mid,right,after);    <span class="comment">//合并左右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; af(<span class="number">20</span>);</span><br><span class="line">    Merge_sort(ex,<span class="number">0</span>,len<span class="number">-1</span>,af);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>任何情况下归并排序的时间复杂度为O(n*logn)。假设数量长为n，将数列分开成小数列一共要logn步，每一步都是一个合并有序数列的过程，合并有序数列时间复杂度为O(n)。</li></ol><p>   空间复杂度：</p><ol><li>空间复杂度为O(n)，因为借用了一个数组af[]用于暂存已序的数组。</li></ol><pre><code>稳定性：1. 稳定</code></pre><hr><h2 id="07-希尔排序"><a href="#07-希尔排序" class="headerlink" title="#07.希尔排序"></a><strong>#07.希尔排序</strong></h2><hr><p>希尔排序的基本原理：</p><p>希尔排序可以理解为是堆插入排序的改进，改进的思路是：把数组按<em>下标的增量进行分组</em>，对每组使用直接插入排序；随着增量的逐渐减少，每组包含的元素越来越多，<em>当增量减至1时</em>，整个数组正好为一组，算法终止。</p><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/7_1.jpg" title="示例图"></code></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> distance=len;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        distance=distance/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;distance;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=k+distance;i&lt;len;i+=distance)   <span class="comment">//i+=distance需要注意</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;k;j-=distance)    <span class="comment">//j&gt;k这个也需要注意</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ex[j]&lt;ex[j-distance])</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=ex[j];</span><br><span class="line">                        ex[j]=ex[j-distance];</span><br><span class="line">                        ex[j-distance]=temp;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(distance==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>希尔排序的时间复杂度取决于增量选取，最坏情况下希尔排序的时间复杂度会到O(n2)，平均时间复杂度为O(n*logn2)。</li></ol><p>   空间复杂度：</p><ol><li>与插入排序一样都是O(1)。</li></ol><pre><code>算法稳定性：1.  尽管插入排序是稳定的，但是由于希尔排序涉及到分组，相同的元素被分到不同的组中然后各自进行插入排序有可能会改变它们之间的位置关系，所以希尔排序时不稳定的。</code></pre><hr><h2 id="08-计数排序"><a href="#08-计数排序" class="headerlink" title="#08.计数排序"></a><strong>#08.计数排序</strong></h2><hr><p>计数排序的基本原理：</p><p><em>计数排序是一种非比较的排序，它适用于<strong>一定范围</strong>的整数排序。在取值范围不是很大的情况下，它的性能甚至会快过O(nlogn)的排序方法</em></p><p>计数排序的算法步骤：</p><ol><li><p>找出待排序数组的最大值和最小值。</p></li><li><p>构建一个数组C，统计原数组中每个元素i出现的次数k，将k存入数组C的第i项中。</p></li><li><p>对C中的所有计数累加。</p></li><li><p>反向填充原数组。</p></li></ol><p>   <em>原理参考图：</em></p><p>   <code><img src="/2020/03/19/基础排序算法整理/8_1.jpg" title="示例图"></code></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//计数排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> v_min=ex[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> v_max=ex[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ex[i]&gt;v_max)</span><br><span class="line">        &#123;</span><br><span class="line">            v_max=ex[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ex[i]&lt;v_min)</span><br><span class="line">        &#123;</span><br><span class="line">            v_min=ex[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> range=v_max-v_min+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countArray(range,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArray[ex[j]-v_min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ptr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;range;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;countArray[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ex[ptr++]=i+v_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li><p>计数排序的时间复杂度受到数组中最大值和最小值的差值影响。</p></li><li><p>设max-min=m，则时间复杂度为O(m+n)</p></li></ol><p>   空间复杂度:</p><ol><li>空间复杂度同样取决于数组最大和最小值得差值，设max-min=m，则空间复杂度为O(m)。</li></ol><pre><code>算法稳定性：1. 稳定</code></pre><hr><h2 id="09-基数排序"><a href="#09-基数排序" class="headerlink" title="#09. 基数排序"></a><strong>#09. 基数排序</strong></h2><hr><p>基数排序的原理：</p><ol><li>将整数按位数切割成不同的数字，然后按每个位数分别比较。</li></ol><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/9_1.gif" title="示例图"></code></p><p><code><img src="/2020/03/19/基础排序算法整理/9_2.jpg" title="示例图"></code></p><p><em>ex：基数排序还有前面的计数排序都可以看做是桶排序的特殊形式，三者的差异在于：</em></p><p><em>1.基数排序：根据元素的每<strong>位</strong>数字来分配桶。</em></p><p><em>2.计数排序：每个桶只存在单一元素。</em></p><p><em>3.桶排序：每个桶凑存储一定范围的元素。</em></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span>;             <span class="comment">//指数，用来区分每次排序是按哪一位，exp=1表示按个位排序，ex=10表示按十位排序...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> v_max=vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]&gt;v_max)</span><br><span class="line">        &#123;</span><br><span class="line">            v_max=vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从个位开始，对数组进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">exp</span>=<span class="number">1</span>;v_max/<span class="built_in">exp</span>&gt;<span class="number">0</span>;<span class="built_in">exp</span>*=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> buckets[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(length,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i]+=buckets[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]<span class="number">-1</span>]=vec[i];</span><br><span class="line">            buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    radix_sort(ex,len);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>基数排序的时间复杂度取决于数组中最大数有多少位，设最大数有k位，则时间复杂度为O(kn)</li></ol><p>   空间复杂度：</p><ol><li>这里开辟了一个包含10个整型的数组，空间复杂度为O(1)</li></ol><pre><code>算法稳定性：1. 稳定</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9种基础的排序算法&quot;&gt;&lt;a href=&quot;#9种基础的排序算法&quot; class=&quot;headerlink&quot; title=&quot;9种基础的排序算法&quot;&gt;&lt;/a&gt;&lt;strong&gt;9种基础的排序算法&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;撰写本文意在帮助自己复习巩固基础的10大
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://hustxxj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://hustxxj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——26.二叉搜索树和双向链表（23-33-836）</title>
    <link href="http://hustxxj.github.io/2020/03/18/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9426.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/03/18/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9426.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-18T04:48:28.000Z</published>
    <updated>2020-03-23T13:50:27.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>思路与迭代法实现二叉树的中序遍历类似，可以参考剑指Offer——04.二叉树的重建</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRootOfTree==nullptr)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; sta;</span><br><span class="line">        TreeNode* ptr=pRootOfTree;</span><br><span class="line">        TreeNode* res=new TreeNode(-1);</span><br><span class="line">        TreeNode* res_ptr=res;</span><br><span class="line">        bool isFirst=true;</span><br><span class="line">        while(ptr!=nullptr || !sta.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr!=nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            res_ptr-&gt;right=ptr;</span><br><span class="line">            if(isFirst==false)</span><br><span class="line">              ptr-&gt;left=res_ptr;</span><br><span class="line">            res_ptr=ptr;</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">            isFirst=false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：836-矩阵重叠"><a href="#LeetCode练习（数组）：836-矩阵重叠" class="headerlink" title="LeetCode练习（数组）：836.矩阵重叠"></a><strong>LeetCode练习（数组）：836.矩阵重叠</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_836.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123;</span><br><span class="line">        bool res=false;</span><br><span class="line">        </span><br><span class="line">        if(rec2[0]&lt;rec1[2] &amp;&amp; rec2[1]&lt;rec1[3] &amp;&amp; rec2[2]&gt;rec1[0] &amp;&amp; rec2[3]&gt;rec1[1])</span><br><span class="line">           res=true;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：23-合并K个排序链表"><a href="#LeetCode练习（链表）：23-合并K个排序链表" class="headerlink" title="LeetCode练习（链表）：23.合并K个排序链表"></a><strong>LeetCode练习（链表）：23.合并K个排序链表</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_23.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        int len=lists.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return nullptr;</span><br><span class="line">        if(len==1)</span><br><span class="line">           return lists[0];</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* ptr=lists[i];</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                vec.push_back(ptr-&gt;val);</span><br><span class="line">                ptr=ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(vec.begin(),vec.end());</span><br><span class="line">        ListNode* res=new ListNode(-1);</span><br><span class="line">        ListNode* res_ptr=res;</span><br><span class="line">        for(int i=0;i&lt;vec.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tempnode=new ListNode(vec[i]);</span><br><span class="line">            res_ptr-&gt;next=tempnode;</span><br><span class="line">            res_ptr=tempnode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：33-搜索旋转排序数组"><a href="#LeetCode练习（数组）：33-搜索旋转排序数组" class="headerlink" title="LeetCode练习（数组）：33.搜索旋转排序数组"></a><strong>LeetCode练习（数组）：33.搜索旋转排序数组</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_33.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) </span><br><span class="line">    &#123;</span><br><span class="line">        int low=0,high=nums.size()-1;</span><br><span class="line">        </span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=low+(high-low)/2;</span><br><span class="line">            if(target==nums[mid]) return mid;</span><br><span class="line"></span><br><span class="line">            if(nums[low]&lt;=nums[mid])  /////左区间有序</span><br><span class="line">            &#123;</span><br><span class="line">                if(target&gt;=nums[low]&amp;&amp;target&lt;nums[mid])   ////target在左区间</span><br><span class="line">                    high=mid-1;</span><br><span class="line">                else low=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else                     ///右区间有序</span><br><span class="line">            &#123;</span><br><span class="line">                if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[high])    ////target在右区间</span><br><span class="line">                    low=mid+1;</span><br><span class="line">                else high=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——25.复制链表的复制（46-62-1160）</title>
    <link href="http://hustxxj.github.io/2020/03/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9425.%E5%A4%8D%E5%88%B6%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>http://hustxxj.github.io/2020/03/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9425.%E5%A4%8D%E5%88%B6%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
    <published>2020-03-17T12:58:55.000Z</published>
    <updated>2020-03-18T04:45:18.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><ol><li>在每个节点后面复制一个和当前节点一模一样的节点（节点值，下一节点地址，随机节点地址都一样）</li><li>将复制的节点拿出来单独组成一个链表</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    struct RandomListNode *next, *random;</span><br><span class="line">    RandomListNode(int x) :</span><br><span class="line">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        </span><br><span class="line">        clo(pHead);</span><br><span class="line">        setrandomptr(pHead);</span><br><span class="line">        return depart(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void clo(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode* ptr=head;</span><br><span class="line">        while(ptr!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* cloneNode=new RandomListNode(ptr-&gt;label);</span><br><span class="line">            cloneNode-&gt;next=ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next=cloneNode;</span><br><span class="line">            ptr=cloneNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void setrandomptr(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode *pNode = head;</span><br><span class="line">     </span><br><span class="line">        while (pNode != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode *pClone = pNode-&gt;next;</span><br><span class="line">            if (pNode-&gt;random)</span><br><span class="line">            &#123;</span><br><span class="line">                pClone-&gt;random = pNode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pClone-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RandomListNode* depart(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode* ptr=head;</span><br><span class="line">        RandomListNode* res=head-&gt;next;</span><br><span class="line">        while(ptr!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* ptr_res=ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next=ptr_res-&gt;next;</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">            if(ptr!=nullptr)</span><br><span class="line">              ptr_res-&gt;next=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（哈希表）：1160-拼写单词"><a href="#LeetCode练习（哈希表）：1160-拼写单词" class="headerlink" title="LeetCode练习（哈希表）：1160.拼写单词"></a><strong>LeetCode练习（哈希表）：1160.拼写单词</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/17/剑指Offer——25.复制链表的复制/25_1160.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123;</span><br><span class="line">        if(words.size()==0 || chars.size()==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        map&lt;char,int&gt; mp;</span><br><span class="line">        for(int i=0;i&lt;chars.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[chars[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;words.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(words[i].size() &gt; chars.size())</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(words[i].begin(),words[i].end());</span><br><span class="line">            int target=0,count=0;</span><br><span class="line">            bool isRight=true;</span><br><span class="line">            for(int j=0;j&lt;words[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[words[i][j]]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    isRight=false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(words[i][j]==words[i][target])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(count&gt;mp[words[i][target]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        isRight=false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        target=j;</span><br><span class="line">                        count=1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&gt;mp[words[i][target]])</span><br><span class="line">            &#123;</span><br><span class="line">                isRight=false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isRight==true)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=words[i].size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：46-全排列"><a href="#LeetCode练习（数组）：46-全排列" class="headerlink" title="LeetCode练习（数组）：46.全排列"></a><strong>LeetCode练习（数组）：46.全排列</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        do&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;while(next_permutation(nums.begin(),nums.end()));</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：62-不同路径"><a href="#LeetCode练习（动态规划）：62-不同路径" class="headerlink" title="LeetCode练习（动态规划）：62.不同路径"></a><strong>LeetCode练习（动态规划）：62.不同路径</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/17/剑指Offer——25.复制链表的复制/25_62.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if(m&lt;=1 || n&lt;=1)</span><br><span class="line">           return 1;</span><br><span class="line">        int dp[n][m]=&#123;0&#125;;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[0][i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][0]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][m-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——24.二叉树中和为某一值得路径（22-695-f01.06）</title>
    <link href="http://hustxxj.github.io/2020/03/16/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9424.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E5%BE%97%E8%B7%AF%E5%BE%84/"/>
    <id>http://hustxxj.github.io/2020/03/16/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9424.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E5%BE%97%E8%B7%AF%E5%BE%84/</id>
    <published>2020-03-16T04:10:32.000Z</published>
    <updated>2020-03-18T04:45:48.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用递归实现：</p><ol><li>如果当前节点是叶子节点，且节点值等于目标值，则将该子数组放入最后的结果中</li><li>如果当前节点值小于目标值，但是还存在子节点，则迭代，目标值相应递减。</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;val == expectNumber &amp;&amp; root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        if(root-&gt;val &lt; expectNumber &amp;&amp; root-&gt;left!=nullptr)</span><br><span class="line">            FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        if(root-&gt;val &lt; expectNumber &amp;&amp; root-&gt;right!=nullptr)</span><br><span class="line">            FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-深度优先遍历）：695-岛屿的最大面积"><a href="#LeetCode练习（数组-深度优先遍历）：695-岛屿的最大面积" class="headerlink" title="LeetCode练习（数组/深度优先遍历）：695.岛屿的最大面积"></a><strong>LeetCode练习（数组/深度优先遍历）：695.岛屿的最大面积</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_695.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路： 遍历数组，每当发现一个1，就从该元素出发搜索周围四个方向是否存在1，将该元素以及周围为1的元素都置0，顺便计数一共置0了多少个1（代表岛屿的面积）。遍历完后返回最大岛屿面积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int area;</span><br><span class="line">public:</span><br><span class="line">    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int rows=grid.size();</span><br><span class="line">        if(rows==0)</span><br><span class="line">           return 0;</span><br><span class="line">        int cols=grid[0].size();</span><br><span class="line">        if(cols==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;rows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;cols;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    area=0;</span><br><span class="line">                    find_1(grid,i,j);</span><br><span class="line">                    res=(area&gt;res)?area:res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void find_1(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int i,int j)</span><br><span class="line">    &#123;</span><br><span class="line">        if(grid[i][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j]=0;</span><br><span class="line">            area++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i-1&gt;=0 &amp;&amp; grid[i-1][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i-1,j);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i+1&lt;grid.size() &amp;&amp; grid[i+1][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i+1,j);</span><br><span class="line">        &#125;</span><br><span class="line">        if(j-1&gt;=0 &amp;&amp; grid[i][j-1]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i,j-1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(j+1&lt;grid[0].size() &amp;&amp; grid[i][j+1]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i,j+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（字符串）：面试题01-06-字符串压缩"><a href="#LeetCode练习（字符串）：面试题01-06-字符串压缩" class="headerlink" title="LeetCode练习（字符串）：面试题01.06.字符串压缩"></a><strong>LeetCode练习（字符串）：面试题01.06.字符串压缩</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_f0106.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>数字转字符串 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss&lt;&lt;a;</span><br><span class="line">string str=ss.str();</span><br><span class="line">或</span><br><span class="line">int a=10;</span><br><span class="line">string str=to_string(a);</span><br></pre></td></tr></table></figure></p><p>字符串转数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int stoi(const strings str, size_t* pos = 0/*返回第一个无法转换的字符位置*/, int base = 10/*表示按10进制转换为整数*/)</span><br><span class="line">long stol(const strings str, size_t* pos = 0, int base = 10)</span><br><span class="line">float stof(const strings str, size_t* pos = 0)</span><br><span class="line">double stod(const strings str, size_t* pos = 0)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string compressString(string S) &#123;</span><br><span class="line">        int len=S.size();</span><br><span class="line">        if(len&lt;=1)</span><br><span class="line">          return S;</span><br><span class="line">        </span><br><span class="line">        int target=0;</span><br><span class="line">        int count=0;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(S[i]==S[target])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(S[target]);</span><br><span class="line">                res+=to_string(count);</span><br><span class="line">                target=i;</span><br><span class="line">                count=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(S[target]);</span><br><span class="line">        res+=to_string(count);</span><br><span class="line"></span><br><span class="line">        res=(res.size()&gt;=len)?S:res;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯算法）：22-括号生成"><a href="#LeetCode练习（回溯算法）：22-括号生成" class="headerlink" title="LeetCode练习（回溯算法）：22.括号生成"></a><strong>LeetCode练习（回溯算法）：22.括号生成</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_22.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><ol><li>在str中放入n个”()”</li><li>利用next_permutation对str进行全排列，然后检查每个排列是否合法（调用next_permutation之前先要对str进行sort排序，否则会出错）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if(n==0)</span><br><span class="line">           return res;</span><br><span class="line">        if(n==1)</span><br><span class="line">        &#123;</span><br><span class="line">            string ss=&quot;()&quot;;</span><br><span class="line">            res.push_back(ss);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ss=&quot;&quot;;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ss+=&quot;()&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ss.begin(),ss.end());</span><br><span class="line"></span><br><span class="line">        do&#123;</span><br><span class="line">            if(IsLegal(ss))</span><br><span class="line">               res.push_back(ss);</span><br><span class="line">        &#125;while(next_permutation(ss.begin(),ss.end()));</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool IsLegal(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        int len=str.size();</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==&apos;(&apos;)</span><br><span class="line">               count++;</span><br><span class="line">            else</span><br><span class="line">               count--;</span><br><span class="line">            </span><br><span class="line">            if(count&lt;0)</span><br><span class="line">               return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——23.二叉搜索树的后序遍历序列（6-34-300）</title>
    <link href="http://hustxxj.github.io/2020/03/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9423.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9423.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-14T11:43:59.000Z</published>
    <updated>2020-03-14T14:46:46.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><pre><code>采用自顶向下的方式进行运算如果vector是二叉搜索树的后续遍历序列，那么vector{a1,....,a2,b1,.....,b2,c1}一定满足a1~a2小于c1,b1~b2大于c1如果以上条件满足，那么再将a1~a2,b1~b2分别作为输入验证他们是否满足</code></pre><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool isFirstIn=true;</span><br><span class="line">public:</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">        int len=sequence.size();</span><br><span class="line">        if(len==0 &amp;&amp; isFirstIn==true)</span><br><span class="line">            return false;</span><br><span class="line">        if(len &lt;=2)</span><br><span class="line">            return true;</span><br><span class="line">        isFirstIn=false;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; left,right;</span><br><span class="line">        int root=sequence[len-1];</span><br><span class="line">        int ptr;</span><br><span class="line">        for(int i=0;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sequence[i] &lt; root)</span><br><span class="line">                left.push_back(sequence[i]);</span><br><span class="line">            if(sequence[i] &gt; root)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==len-2)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=i+1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=ptr;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sequence[i]&gt;root)</span><br><span class="line">                right.push_back(sequence[i]);</span><br><span class="line">            if(sequence[i]&lt;root)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return VerifySquenceOfBST(left) &amp;&amp; VerifySquenceOfBST(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：300-最长的上升子序列"><a href="#LeetCode练习（动态规划）：300-最长的上升子序列" class="headerlink" title="LeetCode练习（动态规划）：300.最长的上升子序列"></a><strong>LeetCode练习（动态规划）：300.最长的上升子序列</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_300.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>状态转移方程：设dp[n]表示从第n个数字往左，最长上升子序列的长度            则，dp[n]=max(dp[j])+1; 0&lt;=j&lt;n;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return len;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; dp(len,0);</span><br><span class="line">        for(int j=0;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=1;</span><br><span class="line">            for(int i=0;i&lt;j;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i] &lt; nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j]=max(dp[j],dp[i]+1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：6-Z字形变换"><a href="#LeetCode练习（字符串）：6-Z字形变换" class="headerlink" title="LeetCode练习（字符串）：6.Z字形变换"></a><strong>LeetCode练习（字符串）：6.Z字形变换</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_6.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convert(string s, int numRows) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        if(s==&quot;&quot; || numRows==0)</span><br><span class="line">           return res;</span><br><span class="line">        </span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len &lt;=numRows || numRows==1)</span><br><span class="line">           return s;</span><br><span class="line">        vector&lt;string&gt; ss(numRows);</span><br><span class="line">        bool isDown=true;</span><br><span class="line">        int stairs=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isDown==true)</span><br><span class="line">            &#123;</span><br><span class="line">                ss[stairs].push_back(s[i]);</span><br><span class="line">                stairs++;</span><br><span class="line">                if(stairs==numRows)</span><br><span class="line">                &#123;</span><br><span class="line">                    isDown=false;</span><br><span class="line">                    stairs-=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ss[stairs].push_back(s[i]);</span><br><span class="line">                stairs--;</span><br><span class="line">                if(stairs&lt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    isDown=true;</span><br><span class="line">                    stairs+=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=ss[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode练习（数组）：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode练习（数组）：34. 在排序数组中查找元素的第一个和最后一个位置"></a><strong>LeetCode练习（数组）：34. 在排序数组中查找元素的第一个和最后一个位置</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_6.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;int&gt;::iterator it1=find(nums.begin(),nums.end(),target);</span><br><span class="line">        if(it1==nums.end())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(-1);</span><br><span class="line">            res.push_back(-1);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(it1-nums.begin());</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">        vector&lt;int&gt;::iterator it2=find(nums.begin(),nums.end(),target);</span><br><span class="line">        res.push_back(nums.size()-(it2-nums.begin())-1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Ye
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——22.从上往下打印二叉树（58-169-322）</title>
    <link href="http://hustxxj.github.io/2020/03/13/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9422.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://hustxxj.github.io/2020/03/13/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9422.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-13T08:46:04.000Z</published>
    <updated>2020-03-13T17:54:55.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>简单的利用队列实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt;  res;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left!=nullptr)</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                if(temp-&gt;right!=nullptr)</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：169-多数元素"><a href="#LeetCode练习（数组）：169-多数元素" class="headerlink" title="LeetCode练习（数组）：169.多数元素"></a><strong>LeetCode练习（数组）：169.多数元素</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_169.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        int count=0;int target=nums[0];</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==target)</span><br><span class="line">               count++;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(count &gt; len/2)</span><br><span class="line">                   return target;</span><br><span class="line">                count=1;</span><br><span class="line">                target=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：322-零钱兑换"><a href="#LeetCode练习（动态规划）：322-零钱兑换" class="headerlink" title="LeetCode练习（动态规划）：322.零钱兑换"></a><strong>LeetCode练习（动态规划）：322.零钱兑换</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_322.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>动态规划问题最重要的就是列出状态转移方程设dp[n]表示凑出n块钱，所需要的硬币个数最小值  那么就有dp[n]=min(dp[n-coin]+1)，即需要凑出n-coin块钱需要的硬币个数+1个面额为coin的硬币n=0时,dp[0]=0;n&lt;0时,dp[n]=-1;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        int num=coins.size();</span><br><span class="line">        if(num==0)</span><br><span class="line">           return -1;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(amount+1,amount+1);</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for(int i=0;i&lt;amount+1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;num;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i-coins[j] &lt; 0)</span><br><span class="line">                   continue;</span><br><span class="line">                dp[i]=min(dp[i-coins[j]]+1,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (dp[amount]==amount+1)?-1:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：58-最后一个单词的长度"><a href="#LeetCode练习（数组）：58-最后一个单词的长度" class="headerlink" title="LeetCode练习（数组）：58.最后一个单词的长度"></a><strong>LeetCode练习（数组）：58.最后一个单词的长度</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_58.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=len-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&apos; &apos;)</span><br><span class="line">               continue;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=i;j&gt;=0;j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s[j]==&apos; &apos;)</span><br><span class="line">                      break;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;从上往下打印出二叉树的每个节点，同层节点从左至右打印。&lt;/p&gt;
&lt;hr&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——21.栈的弹入弹出序列（38-283-1071）</title>
    <link href="http://hustxxj.github.io/2020/03/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9421.%E6%A0%88%E7%9A%84%E5%BC%B9%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9421.%E6%A0%88%E7%9A%84%E5%BC%B9%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-12T08:37:14.000Z</published>
    <updated>2020-03-12T11:24:18.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>记录弹出序列中逆序的数量，当逆序数大于等于2时则表示该序列不可能是弹出序列。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        int num=pushV.size();</span><br><span class="line">        if(num==0)</span><br><span class="line">            return true;</span><br><span class="line">        if(num==1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pushV[0]!=popV[0])</span><br><span class="line">                return false;</span><br><span class="line">            else</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int reversetime=0;</span><br><span class="line">        for(int i=0;i&lt;num-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int a=popV[i];</span><br><span class="line">            int b=popV[i+1];</span><br><span class="line">            vector&lt;int&gt;::iterator ptra=find(pushV.begin(),pushV.end(),a);</span><br><span class="line">            vector&lt;int&gt;::iterator ptrb=find(pushV.begin(),pushV.end(),b);</span><br><span class="line">            if(ptra==pushV.end() || ptrb==pushV.end())</span><br><span class="line">                return false;</span><br><span class="line">            if((ptra-pushV.begin())&lt;(ptrb-pushV.begin()))</span><br><span class="line">                reversetime++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(reversetime&gt;=2)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：1071-字符串的最大公因子"><a href="#LeetCode练习（字符串）：1071-字符串的最大公因子" class="headerlink" title="LeetCode练习（字符串）：1071.字符串的最大公因子"></a><strong>LeetCode练习（字符串）：1071.字符串的最大公因子</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_1071.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string gcdOfStrings(string str1, string str2) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        int len1=str1.size();</span><br><span class="line">        int len2=str2.size();</span><br><span class="line">        int M=gcd(len1,len2);           //gcd(x,y)求x，y的最大公约数</span><br><span class="line">        for(int i=0;i&lt;M;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str1[i]==str2[i])</span><br><span class="line">               res.push_back(str1[i]);</span><br><span class="line">            else</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str1[i]!=res[i%M])</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str2[i]!=res[i%M])</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：38-外观数列"><a href="#LeetCode练习（数组）：38-外观数列" class="headerlink" title="LeetCode练习（数组）：38.外观数列"></a><strong>LeetCode练习（数组）：38.外观数列</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_38.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string res=&quot;1&quot;;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=transform(res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string transform(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        string res;</span><br><span class="line">        int len=str.size();</span><br><span class="line">        int ptr=0;</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==str[ptr])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count+&apos;0&apos;);</span><br><span class="line">                res.push_back(str[ptr]);</span><br><span class="line">                ptr=i;</span><br><span class="line">                count=0;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(count+&apos;0&apos;);</span><br><span class="line">        res.push_back(str[ptr]);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：283-移动零"><a href="#LeetCode练习（数组）：283-移动零" class="headerlink" title="LeetCode练习（数组）：283.移动零"></a><strong>LeetCode练习（数组）：283.移动零</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_283.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">               count++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.push_back(0);</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                i--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——20.包含min函数的栈（17-88-1013）</title>
    <link href="http://hustxxj.github.io/2020/03/11/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9420.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>http://hustxxj.github.io/2020/03/11/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9420.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</id>
    <published>2020-03-11T06:34:41.000Z</published>
    <updated>2020-03-11T12:18:51.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度为o(1)）。注意：测试样例中保证不在栈为空的时候，调用pop()或者min()或者top方法。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>要想在时间复杂度为o(1)的情况下找出栈中最小的元素，那么就需要另外开辟一个栈空间，用来存放最小值。<br>记原始栈为sta1,存放最小值的栈为sta2，存放的规则为：</p><ol><li>sta1正常进行push,pop等操作。</li><li>当sta2为empty时，向sta2中正常push元素；当sta2不为empty时，需要比较当前push的元素与sta2的栈顶元素的大小，只有当前要push的元素小于栈顶元素，才能push入sta2。</li><li>当需要pop时，当sta1弹出的元素为栈中的最小元素时，sta2也要跟着弹出栈顶元素（因为sta1弹出栈中最小元素意味着min值已经改变，所以sta2的栈顶最为记录min的栈，栈顶值也要改变。）<br><em>特别的：需要理解sta2从栈底到栈顶依次记录的是，sta1每次push后栈中的最小元素</em></li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">stack&lt;int&gt; sta1,sta2;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        sta1.push(value);</span><br><span class="line">        if(sta2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sta2.push(value);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(sta2.top() &gt; value)</span><br><span class="line">            &#123;</span><br><span class="line">                sta2.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(sta1.top()==sta2.top())</span><br><span class="line">            sta2.pop();</span><br><span class="line">        sta1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return sta1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return sta2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：1013-将数组分成和相等的三个部分"><a href="#LeetCode练习（数组）：1013-将数组分成和相等的三个部分" class="headerlink" title="LeetCode练习（数组）：1013. 将数组分成和相等的三个部分"></a><strong>LeetCode练习（数组）：1013. 将数组分成和相等的三个部分</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_1013.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li>根据题意：只有将数组分成三等份，且三等份每份的和相等才能返回true，否则返回false。</li><li>将数组分为三等份，需要两个指针实现。</li><li>例如[0,2,1,-6,6,-7,9,1,2,0,1],初始化定义第一个指针指向第一个元素，第二个指针指向最后一个元素</li><li>判断每个区间的和与目标值是否相等，相等则指针不动，不相等则指针移动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int len=A.size();</span><br><span class="line">        if(len&lt;=2)</span><br><span class="line">            return false;</span><br><span class="line">        int sum = accumulate(A.begin(), A.end(), 0);</span><br><span class="line">        int target;</span><br><span class="line">        if(sum%3 != 0)</span><br><span class="line">           return false;</span><br><span class="line">        else</span><br><span class="line">           target=sum/3;</span><br><span class="line"></span><br><span class="line">        int left_ptr=0,right_ptr=len-1;</span><br><span class="line">        int sum_left=A[left_ptr],sum_right=A[right_ptr];</span><br><span class="line">        while(left_ptr+1&lt;right_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum_left==target &amp;&amp; sum_right==target)</span><br><span class="line">               return true;</span><br><span class="line">            if(sum_left!=target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum_left+=A[++left_ptr];</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum_right!=target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum_right+=A[--right_ptr];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：88-合并两个有序数组"><a href="#LeetCode练习（数组）：88-合并两个有序数组" class="headerlink" title="LeetCode练习（数组）：88.合并两个有序数组"></a><strong>LeetCode练习（数组）：88.合并两个有序数组</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_88.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        for(int i=m;i&lt;m+n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i]=nums2[i-m];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1.erase((nums1.begin()+m+n),nums1.end());</span><br><span class="line">        sort(nums1.begin(),nums1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯算法）：17-电话号码的字母组合"><a href="#LeetCode练习（回溯算法）：17-电话号码的字母组合" class="headerlink" title="LeetCode练习（回溯算法）：17.电话号码的字母组合"></a><strong>LeetCode练习（回溯算法）：17.电话号码的字母组合</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_17.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>遍历digits的每个字符，将每个字符下面索引出的所有元素都与res里的每个元素进行相加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        int len=digits.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        res=&#123;&quot;&quot;&#125;;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            if(digits[i]==&apos;2&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;a&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;b&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;c&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;3&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;d&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;e&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;f&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;4&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;g&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;h&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;i&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;5&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;j&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;k&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;l&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;6&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;m&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;n&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;o&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;7&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;p&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;q&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;r&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;s&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;8&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;t&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;u&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;v&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;9&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;w&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;x&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;y&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;z&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——19.顺时针打印矩阵（11-15-543）</title>
    <link href="http://hustxxj.github.io/2020/03/10/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9419.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://hustxxj.github.io/2020/03/10/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9419.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</id>
    <published>2020-03-10T00:05:02.000Z</published>
    <updated>2020-03-10T05:59:21.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4x4矩阵：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16则依次打印出数字1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>从最外圈顺时针逐渐向内圈遍历，利用四个指针限定出最外圈的四个角，遍历完最外圈后将四个角点内移，然后重新遍历。直到左右角重叠或者上下角重叠则退出循环。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(matrix.size()==0 || matrix[0].size()==0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        int left=0,right=matrix[0].size()-1,top=0,bottom=matrix.size()-1;</span><br><span class="line">        while(left&lt;=right &amp;&amp; top&lt;=bottom)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=left;i&lt;=right;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i=top+1;i&lt;=bottom;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            //避免横向重复遍历同一行</span><br><span class="line">            if(top!=bottom)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int i=right-1;i&gt;=left;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //避免纵向重复遍历同一页</span><br><span class="line">            if(left!=right)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int i=bottom-1;i&gt;top;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（二叉树）：543-二叉树的直径"><a href="#LeetCode练习（二叉树）：543-二叉树的直径" class="headerlink" title="LeetCode练习（二叉树）：543.二叉树的直径"></a><strong>LeetCode练习（二叉树）：543.二叉树的直径</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_543.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int max=0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp_node=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp_node-&gt;left!=nullptr)</span><br><span class="line">                   q.push(temp_node-&gt;left);</span><br><span class="line">                if(temp_node-&gt;right!=nullptr)</span><br><span class="line">                   q.push(temp_node-&gt;right);</span><br><span class="line">                int v=depth(temp_node-&gt;left)+depth(temp_node-&gt;right);</span><br><span class="line">                if(v&gt;max)</span><br><span class="line">                   max=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int depth(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)</span><br><span class="line">            return 1;</span><br><span class="line">        </span><br><span class="line">        int depth_l=depth(root-&gt;left)+1;</span><br><span class="line">        int depth_r=depth(root-&gt;right)+1;</span><br><span class="line"></span><br><span class="line">        return max(depth_l,depth_r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-双指针）：15-三数之和"><a href="#LeetCode练习（数组-双指针）：15-三数之和" class="headerlink" title="LeetCode练习（数组/双指针）：15.三数之和"></a><strong>LeetCode练习（数组/双指针）：15.三数之和</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_15.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        if(nums.size()&lt;3 )</span><br><span class="line">            return res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int now=nums[i];</span><br><span class="line">            if(now &gt; 0)</span><br><span class="line">                break;</span><br><span class="line">            int ptr_left=i+1;</span><br><span class="line">            int ptr_right=nums.size()-1;</span><br><span class="line">            while(ptr_left&lt;ptr_right)</span><br><span class="line">            &#123;</span><br><span class="line">                int add=nums[ptr_left]+nums[ptr_right];</span><br><span class="line">                if(add+now&lt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr_left++;</span><br><span class="line">                &#125;else if(add+now&gt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr_right--;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;int&gt; temp;</span><br><span class="line">                    temp.push_back(now);</span><br><span class="line">                    temp.push_back(nums[ptr_left]);</span><br><span class="line">                    temp.push_back(nums[ptr_right]);</span><br><span class="line">                    res.push_back(temp);</span><br><span class="line">                    //去重</span><br><span class="line">                    int intLo=nums[ptr_left];</span><br><span class="line">                    int intHi=nums[ptr_right];</span><br><span class="line">                    while (ptr_left &lt; ptr_right &amp;&amp; nums[ptr_left] == intLo)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ptr_left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while (ptr_left &lt; ptr_right &amp;&amp; nums[ptr_right] == intHi)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ptr_right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //去重</span><br><span class="line">            while (i + 1 &lt; nums.size()-2 &amp;&amp; nums[i] == nums[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-双指针）：11-盛最多水的容器"><a href="#LeetCode练习（数组-双指针）：11-盛最多水的容器" class="headerlink" title="LeetCode练习（数组/双指针）：11.盛最多水的容器"></a><strong>LeetCode练习（数组/双指针）：11.盛最多水的容器</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_11.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int left=0,right=height.size()-1;</span><br><span class="line">        int max=0;</span><br><span class="line">        while(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            int v_min;</span><br><span class="line">            int width=right-left;</span><br><span class="line">            if(height[left]&lt;height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                v_min=height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                v_min=height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            int temp=v_min*width;</span><br><span class="line">            if(temp&gt;max)</span><br><span class="line">               max=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——18.二叉树的镜像（8-28-35）</title>
    <link href="http://hustxxj.github.io/2020/03/09/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9418.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>http://hustxxj.github.io/2020/03/09/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9418.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</id>
    <published>2020-03-09T07:33:13.000Z</published>
    <updated>2020-03-09T12:25:47.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用递归实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //记Mirror函数为：交换pRoot两颗子树的位置</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot == nullptr)</span><br><span class="line">            return;</span><br><span class="line">        if(pRoot-&gt;left!=nullptr || pRoot-&gt;right!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tempNode=pRoot-&gt;right;</span><br><span class="line">            pRoot-&gt;right=pRoot-&gt;left;</span><br><span class="line">            pRoot-&gt;left=tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：35-搜索插入的位置"><a href="#LeetCode练习（数组）：35-搜索插入的位置" class="headerlink" title="LeetCode练习（数组）：35.搜索插入的位置"></a><strong>LeetCode练习（数组）：35.搜索插入的位置</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_35.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>暴力解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.size()==0)</span><br><span class="line">           return 0;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] == target || nums[i] &gt; target)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>二分查找：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.size()==0 || target &lt; nums[0])</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        if(target &gt; nums[nums.size()-1])</span><br><span class="line">           return nums.size();</span><br><span class="line"></span><br><span class="line">        int ptr_begin=0,ptr_end=nums.size()-1;</span><br><span class="line">        while(ptr_begin &lt; ptr_end)</span><br><span class="line">        &#123;</span><br><span class="line">            int ptr_mid=(ptr_begin+ptr_end)/2;</span><br><span class="line">            if(nums[ptr_mid]==target)</span><br><span class="line">               return ptr_mid;</span><br><span class="line">            else if(nums[ptr_mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr_begin=ptr_mid+1;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ptr_end=ptr_mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ptr_begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（双指针）：28-实现strStr"><a href="#LeetCode练习（双指针）：28-实现strStr" class="headerlink" title="LeetCode练习（双指针）：28.实现strStr()"></a><strong>LeetCode练习（双指针）：28.实现strStr()</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_28.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><em>双指针实现：重点在于找到循环退出条件</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        int n = haystack.size(), m = needle.size();</span><br><span class="line">        for(int i = 0; i &lt; n - m + 1; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for( ; j &lt; m; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(haystack[i + j] !=  needle[j])</span><br><span class="line">                //为了保证在这个循环里haystack的索引也跟着needle索引一起向前推进，i的含义设置为起始点，i + j才是haystack的索引</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j == m)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组）：8-字符串转换整数（atoi）"><a href="#LeetCode练习（数组）：8-字符串转换整数（atoi）" class="headerlink" title="LeetCode练习（数组）：8.字符串转换整数（atoi）"></a><strong>LeetCode练习（数组）：8.字符串转换整数（atoi）</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_8.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(string str) &#123;</span><br><span class="line">        int begin=0;</span><br><span class="line">        for(int i=0;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==&apos; &apos;)</span><br><span class="line">               continue;</span><br><span class="line">            else</span><br><span class="line">               begin=i;</span><br><span class="line">               break;</span><br><span class="line">        &#125;</span><br><span class="line">        int res=0;</span><br><span class="line">        int flag;</span><br><span class="line">        string sav;</span><br><span class="line">        if((str[begin]&gt;=&apos;0&apos;&amp;&amp;str[begin]&lt;=&apos;9&apos;) || str[begin]==&apos;-&apos; || str[begin]==&apos;+&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[begin]&gt;=&apos;0&apos;&amp;&amp;str[begin]&lt;=&apos;9&apos;)  //开头是数字</span><br><span class="line">            &#123;</span><br><span class="line">                flag=1;</span><br><span class="line">                for(int j=begin;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                    else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(str[begin]==&apos;-&apos;)   //开头是负号</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                if(begin==str.size()-1)</span><br><span class="line">                    return 0;</span><br><span class="line">                sav.push_back(&apos;-&apos;);</span><br><span class="line">                for(int j=begin+1;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                     if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                     else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(str[begin]==&apos;+&apos;)   //开头是正号</span><br><span class="line">            &#123;</span><br><span class="line">                flag=3;</span><br><span class="line">                if(begin==str.size()-1)</span><br><span class="line">                    return 0;</span><br><span class="line">                sav.push_back(&apos;+&apos;);</span><br><span class="line">                for(int j=begin+1;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                     if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                     else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int len=sav.size();</span><br><span class="line">        if(flag==1)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1)&gt;INT_MAX)</span><br><span class="line">                    return INT_MAX;</span><br><span class="line">                else</span><br><span class="line">                    res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(flag==2)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1) &gt; INT_MAX)</span><br><span class="line">                   return INT_MIN;</span><br><span class="line">                else</span><br><span class="line">                   res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">            res=-res;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(flag==3)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1) &gt; INT_MAX)</span><br><span class="line">                   return INT_MAX;</span><br><span class="line">                else</span><br><span class="line">                   res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——17.树的子结构（112-198-f57）</title>
    <link href="http://hustxxj.github.io/2020/03/07/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9417.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://hustxxj.github.io/2020/03/07/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9417.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</id>
    <published>2020-03-07T07:46:11.000Z</published>
    <updated>2020-03-07T13:28:17.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两棵二叉树A、B，判断B是不是A的子结构（约定：空树不是任意一个数的子结构）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>该题用递归实现</p><ol><li>定义一个函数isSameStruct(root1,root2)，用于判断从root1和root2开始，两个树是否完全一样。</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot1==nullptr || pRoot2==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return isSameStruct(pRoot1,pRoot2) || HasSubtree(pRoot1-&gt;left,pRoot2) || HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //判断从root1和root2这两个节点开始，两棵树是不是一样的</span><br><span class="line">    bool isSameStruct(TreeNode* root1, TreeNode* root2)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果root2(表示子树)先结束并没有返回false,那么代表root2是root1的子树，返回true</span><br><span class="line">        if(root2==nullptr)</span><br><span class="line">            return true;</span><br><span class="line">        //如果root1先返回，表示root2不是root1的子树</span><br><span class="line">        if(root1==nullptr)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(root1-&gt;val != root2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果两个值相等，再比较他们的左右节点</span><br><span class="line">        return isSameStruct(root1-&gt;left,root2-&gt;left) &amp;&amp; isSameStruct(root1-&gt;right,root2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树）：112-路径总和"><a href="#LeetCode练习（树）：112-路径总和" class="headerlink" title="LeetCode练习（树）：112.路径总和"></a><strong>LeetCode练习（树）：112.路径总和</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/07/剑指Offer——17.树的子结构/17_112.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：经典的用queue来迭代完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">           return false;</span><br><span class="line">        </span><br><span class="line">        queue&lt;int&gt; save_value;</span><br><span class="line">        queue&lt;TreeNode*&gt; save_node;</span><br><span class="line">        save_node.push(root);</span><br><span class="line">        save_value.push(root-&gt;val);</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while(!save_node.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=save_node.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=save_node.front();</span><br><span class="line">                int temp_value=save_value.front();</span><br><span class="line">                save_node.pop();</span><br><span class="line">                save_value.pop();</span><br><span class="line">                if(temp-&gt;left==nullptr &amp;&amp; temp-&gt;right==nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(temp_value);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    save_node.push(temp-&gt;left);</span><br><span class="line">                    save_value.push(temp-&gt;left-&gt;val+temp_value);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right!=nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    save_node.push(temp-&gt;right);</span><br><span class="line">                    save_value.push(temp-&gt;right-&gt;val+temp_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;::iterator ptr=find(res.begin(),res.end(),sum);</span><br><span class="line">        return (ptr==res.end())?false:true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组）：198-打家劫舍"><a href="#LeetCode练习（数组）：198-打家劫舍" class="headerlink" title="LeetCode练习（数组）：198.打家劫舍"></a><strong>LeetCode练习（数组）：198.打家劫舍</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/07/剑指Offer——17.树的子结构/17_198.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>思路：动态规划类型题目关键在于找到状态转移方程设f(n)表示劫犯遍历完第n家共获得的最高金额若偷第n家，那么第n-1家必然不能偷，所以f(n)=nums[n]+f(n-2);若不偷第n家，那么遍历完第n家所获得最大金额就等于遍历完第n-1家所获得最大金额，即f(n)=f(n-1);综上，若想f(n)最大，则得出状态转移方程f(n)=max(nums[n]+f(n-2),f(n-1));</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        else if(len==1)</span><br><span class="line">           return nums[0];</span><br><span class="line"></span><br><span class="line">        int a=0,b=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=max(nums[i]+a,b);</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（滑动窗口）：面试题57-II-和为s的连续正数序列"><a href="#LeetCode练习（滑动窗口）：面试题57-II-和为s的连续正数序列" class="headerlink" title="LeetCode练习（滑动窗口）：面试题57-II.和为s的连续正数序列"></a><strong>LeetCode练习（滑动窗口）：面试题57-II.和为s的连续正数序列</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>利用滑动窗口求解的题目，要注意<em>循环退出条件</em>，还有<em>窗口的边界</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        if(target==0)</span><br><span class="line">           return res;</span><br><span class="line">        </span><br><span class="line">        int left=1,right=1;</span><br><span class="line">        int border=target/2 + 1;</span><br><span class="line">        int sum=0;</span><br><span class="line">        while(left &lt; border)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;else if(sum &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum-=left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;int&gt; temp;</span><br><span class="line">                for(int i=left;i&lt;right;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                sum+=right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两棵二叉树A、B，判断B是不是A的子结构（约定：空树不是任意一个数的子结构）
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——16.合并两个排序的链表（70-121-1103）</title>
    <link href="http://hustxxj.github.io/2020/03/05/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9416.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/03/05/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9416.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-05T07:07:27.000Z</published>
    <updated>2020-03-07T13:26:58.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两个单调递增的链表，输出两个链表合成后的链表，合成后的链表满足单调不减规则。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p><em>略</em></p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead1==nullptr)</span><br><span class="line">            return pHead2;</span><br><span class="line">        else if(pHead2==nullptr)</span><br><span class="line">            return pHead1;</span><br><span class="line">        </span><br><span class="line">        ListNode* f_head=new ListNode(-1);</span><br><span class="line">        ListNode* f_ptr=f_head;</span><br><span class="line">        ListNode* ptr1=pHead1;</span><br><span class="line">        ListNode* ptr2=pHead2;</span><br><span class="line">        while(ptr1 &amp;&amp; ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp_node;</span><br><span class="line">            if(ptr1-&gt;val &lt;= ptr2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_node=ptr1;</span><br><span class="line">                ptr1=ptr1-&gt;next;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                temp_node=ptr2;</span><br><span class="line">                ptr2=ptr2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            f_ptr-&gt;next=temp_node;</span><br><span class="line">            f_ptr=temp_node;</span><br><span class="line">        &#125;</span><br><span class="line">        f_ptr-&gt;next=(ptr1)?ptr1:ptr2;</span><br><span class="line">        return f_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：1103-分糖果II"><a href="#LeetCode练习（动态规划）：1103-分糖果II" class="headerlink" title="LeetCode练习（动态规划）：1103.分糖果II"></a><strong>LeetCode练习（动态规划）：1103.分糖果II</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/05/剑指Offer——16.合并两个排序的链表/16_1103.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; distributeCandies(int candies, int num_people) &#123;</span><br><span class="line">        vector&lt;int&gt; res(num_people);</span><br><span class="line">        if(num_people==1)</span><br><span class="line">        &#123;</span><br><span class="line">            res[0]=candies;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int num_candy=1;</span><br><span class="line">        for(int i=0;i&lt;num_people;i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            if(candies&gt;=num_candy)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]+=num_candy;</span><br><span class="line">                candies-=num_candy;</span><br><span class="line">                num_candy++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]+=candies;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(i==num_people-1)</span><br><span class="line">                i=-1;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：70-爬楼梯"><a href="#LeetCode练习（动态规划）：70-爬楼梯" class="headerlink" title="LeetCode练习（动态规划）：70.爬楼梯"></a><strong>LeetCode练习（动态规划）：70.爬楼梯</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>该题与青蛙跳台阶一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n==1 || n==2)</span><br><span class="line">           return n;</span><br><span class="line">        </span><br><span class="line">        int a=1,b=2;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=3;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（动态规划）：121-买卖股票的最佳时机"><a href="#LeetCode练习（动态规划）：121-买卖股票的最佳时机" class="headerlink" title="LeetCode练习（动态规划）：121.买卖股票的最佳时机"></a><strong>LeetCode练习（动态规划）：121.买卖股票的最佳时机</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/05/剑指Offer——16.合并两个排序的链表/16_121.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>dp[i][0]:第i天，不持股，手上所得最大利润dp[i][1]:第i天，持股，手上所得最大利润</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int len=prices.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int dp_i_0=0,dp_i_1=INT_MIN; //初始化，dp_i_0=0表示-1天未持股所能获得最大利润，dp_i_1=INT_MIN表示-1天持股所能获得最大利润为不可能事件</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_i_0=max(dp_i_0,dp_i_1+prices[i]);</span><br><span class="line">            dp_i_1=max(dp_i_1,-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp_i_0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，合成后的链表满足单调不减规则。
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——15.反转链表（53-66-994）</title>
    <link href="http://hustxxj.github.io/2020/03/04/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9415.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/03/04/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9415.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-04T07:02:12.000Z</published>
    <updated>2020-03-07T13:26:33.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个链表，反转链表后，输出新链表的表头。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>常规的利用双指针实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        if(pHead==nullptr || pHead-&gt;next==nullptr)</span><br><span class="line">            return pHead;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre_node=pHead;</span><br><span class="line">        ListNode* bak_node=NULL;</span><br><span class="line">        </span><br><span class="line">        while(pre_node-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp_node=pre_node-&gt;next;</span><br><span class="line">            pre_node-&gt;next=bak_node;</span><br><span class="line">            bak_node=pre_node;</span><br><span class="line">            pre_node=temp_node;</span><br><span class="line">        &#125;</span><br><span class="line">        pre_node-&gt;next=bak_node;</span><br><span class="line">        return pre_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：66-加一"><a href="#LeetCode练习（数组）：66-加一" class="headerlink" title="LeetCode练习（数组）：66.加一"></a><strong>LeetCode练习（数组）：66.加一</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/04/剑指Offer——15.反转链表/15_66.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：该题如果想先将数组中的元素转换为整数，加1后再重新转换为数组，这种思路会受整数范围的限制造成溢出的问题。所以还是应该在原数组上进行更改，只是要特别考虑几种情况。例如输入【9,9,9】，输出则是【1,0,0,0】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;</span><br><span class="line">        int len=digits.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; res;</span><br><span class="line">            res.push_back(1);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(digits[len-1]&lt;9)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[len-1]=digits[len-1]+1;</span><br><span class="line">            return digits;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            int ptr=len-1;</span><br><span class="line">            while(digits[ptr]==9)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[ptr]=0;</span><br><span class="line">                ptr--;</span><br><span class="line">                if(ptr&lt;0)</span><br><span class="line">                   break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ptr&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[ptr]+=1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                digits.push_back(1);</span><br><span class="line">                reverse(digits.begin(),digits.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（广度优先搜索）：994-腐烂的橘子"><a href="#LeetCode练习（广度优先搜索）：994-腐烂的橘子" class="headerlink" title="LeetCode练习（广度优先搜索）：994.腐烂的橘子"></a><strong>LeetCode练习（广度优先搜索）：994.腐烂的橘子</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/04/剑指Offer——15.反转链表/15_994.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>队列实现 BFS 的方法相对固定，大致分三步：</p><pre><code>初始化队列；最开始的坏橘子全部入队，具体是橘子的坐标和 timetimetime；循环：当队列不为空时，先弹出队首元素，然后将这个元素能够腐烂的橘子全部入队。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int arr[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">public:</span><br><span class="line">    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int row = grid.size();</span><br><span class="line">        if(row == 0) return -1;</span><br><span class="line">        int col = grid[0].size();</span><br><span class="line">        list&lt;pair&lt;int, int&gt;&gt; que;</span><br><span class="line">        int fresh = 0;</span><br><span class="line">        for(int i = 0; i &lt; row; ++i)</span><br><span class="line">            for(int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">                if(grid[i][j] == 2) &#123;</span><br><span class="line">                    que.push_back(make_pair(i, j));</span><br><span class="line">                    grid[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(grid[i][j] == 1)</span><br><span class="line">                    ++fresh;</span><br><span class="line">            &#125;</span><br><span class="line">        if(!fresh) return 0;</span><br><span class="line">        int res = -1;</span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            int nums = que.size();</span><br><span class="line">            ++res;</span><br><span class="line">            while(nums--) &#123;</span><br><span class="line">                int cur_i = que.front().first;</span><br><span class="line">                int cur_j = que.front().second;</span><br><span class="line">                que.pop_front();</span><br><span class="line">                for(int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                    int i = cur_i + arr[k][0];</span><br><span class="line">                    int j = cur_j + arr[k][1];</span><br><span class="line">                    if(i &lt; 0 || j &lt; 0 || i &gt;= row || j &gt;= col)</span><br><span class="line">                        continue;</span><br><span class="line">                    if(grid[i][j]) &#123;</span><br><span class="line">                        que.push_back(make_pair(i, j));</span><br><span class="line">                        grid[i][j] = 0;</span><br><span class="line">                        --fresh;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return fresh ? -1 : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-动态规划）：53-最大子序和"><a href="#LeetCode练习（数组-动态规划）：53-最大子序和" class="headerlink" title="LeetCode练习（数组/动态规划）：53.最大子序和"></a><strong>LeetCode练习（数组/动态规划）：53.最大子序和</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/04/剑指Offer——15.反转链表/15_53.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果时间复杂度：O(n)以【-2,1,-3,4,-1,2,1】为例:初始化：最大连续子序列【-2】，最大值-2，当前序列【 】；第一轮：最大连续子序列【-2】，最大值-2，当前序列【-2】；第二轮：最大连续子序列【1】，最大值1，当前序列【1】；第三轮：最大连续子序列【1】，最大值1，当前序列【1，-3】；第四轮：最大连续子序列【4】，最大值4，当前序列【4】；第五轮：最大连续子序列【4】，最大值4，当前序列【4，-1】；第六轮：最大连续子序列【4，-1，2】，最大值5，当前序列【4，-1，2】；第七轮：最大连续子序列【4，-1，2，1】，最大值6，当前序列【4，-1，2，1】；</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        if(len==1)</span><br><span class="line">           return nums[0];</span><br><span class="line">        </span><br><span class="line">        int sum=0,ans=nums[0];</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum&lt;=0)    </span><br><span class="line">            &#123;</span><br><span class="line">            //若sum&lt;=0，说明不存在增益了，那不如直接替换成当前元素，从当前元素开始重新计算</span><br><span class="line">                sum=nums[i];     </span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">            //sum&gt;0，说明当前sum对于后续数组依然存在增益</span><br><span class="line">                sum+=nums[i];    </span><br><span class="line">            &#125;</span><br><span class="line">            ans=(ans&gt;=sum)?ans:sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——14.链表中倒数第K个结点（14-26-27）</title>
    <link href="http://hustxxj.github.io/2020/03/03/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9414.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://hustxxj.github.io/2020/03/03/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9414.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2020-03-03T06:59:54.068Z</published>
    <updated>2020-03-07T13:20:49.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个链表，输出该链表中倒数第K个结点。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用双指针实现，求倒数第K个结点，可以先定义一个指针pre指向正数第K个结点，然后定义一个bak指向头结点。然后两个指针同时前移，当pre为NULL时，对应的bak正好指向倒数第K个结点。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        if(pListHead==nullptr || k==0)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        int len=0;</span><br><span class="line">        ListNode* c_node=pListHead;</span><br><span class="line">        while(c_node)</span><br><span class="line">        &#123;</span><br><span class="line">            c_node=c_node-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(k&gt;len)</span><br><span class="line">            return nullptr;</span><br><span class="line">        else if(k==len)</span><br><span class="line">            return pListHead;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre_node=pListHead;</span><br><span class="line">        ListNode* bak_node=pListHead;</span><br><span class="line">        while(pre_node)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_node=pre_node-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">            if(k==0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        while(pre_node)</span><br><span class="line">        &#123;</span><br><span class="line">            bak_node=bak_node-&gt;next;</span><br><span class="line">            pre_node=pre_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return bak_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-双指针）：26-删除排序数组中的重复项"><a href="#LeetCode练习（数组-双指针）：26-删除排序数组中的重复项" class="headerlink" title="LeetCode练习（数组/双指针）：26.删除排序数组中的重复项"></a><strong>LeetCode练习（数组/双指针）：26.删除排序数组中的重复项</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/03/剑指Offer——14.链表中倒数第K个结点/14_26.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return len;</span><br><span class="line">        </span><br><span class="line">        int res=1;</span><br><span class="line">        int current_num=0;</span><br><span class="line">        vector&lt;int&gt;::iterator it=nums.begin();</span><br><span class="line">        for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]!=nums[current_num])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                current_num=i;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                nums.erase(it+i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：14-最长公共前缀"><a href="#LeetCode练习（字符串）：14-最长公共前缀" class="headerlink" title="LeetCode练习（字符串）：14.最长公共前缀"></a><strong>LeetCode练习（字符串）：14.最长公共前缀</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/03/剑指Offer——14.链表中倒数第K个结点/14_14.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>注意理解题意，这里是求最长公共<em>前缀</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        if(strs.size()==0)</span><br><span class="line">           return res;</span><br><span class="line">        else if(strs.size()==1)</span><br><span class="line">           return strs[0];</span><br><span class="line">        </span><br><span class="line">        int a_size=(strs[0].size()&gt;=strs[1].size())?strs[1].size():strs[0].size();</span><br><span class="line">        for(int i=0;i&lt;a_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(strs[0][i]!=strs[1][i])</span><br><span class="line">                break;</span><br><span class="line">            else</span><br><span class="line">                res.push_back(strs[0][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=2;i&lt;strs.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp;</span><br><span class="line">            for(int j=0;j&lt;res.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(strs[i][j]==res[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(strs[i][j]);</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组-双指针）：27-移除元素"><a href="#LeetCode练习（数组-双指针）：27-移除元素" class="headerlink" title="LeetCode练习（数组/双指针）：27.移除元素"></a><strong>LeetCode练习（数组/双指针）：27.移除元素</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/03/剑指Offer——14.链表中倒数第K个结点/14_27.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        vector&lt;int&gt;::iterator it=nums.begin();</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.erase(it+i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第K个结点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;解
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer——13.调整数组顺序使奇数位于偶数前面（392-1046-1221）</title>
    <link href="http://hustxxj.github.io/2020/03/02/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9413.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://hustxxj.github.io/2020/03/02/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9413.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</id>
    <published>2020-03-02T03:49:26.000Z</published>
    <updated>2020-03-07T13:25:16.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>用两个栈来实现，定义两个栈，将数组中的元素根据奇偶分别放入两个栈中，然后再重新放回数组。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">        int len=array.size();</span><br><span class="line">        stack&lt;int&gt; ji,ou;</span><br><span class="line">        for(int i=len-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(array[i] &amp; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                ji.push(array[i]);</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ou.push(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            array.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        while(!ji.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            array.push_back(ji.top());</span><br><span class="line">            ji.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while(!ou.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            array.push_back(ou.top());</span><br><span class="line">            ou.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（贪心算法）：392-判断子序列"><a href="#LeetCode练习（贪心算法）：392-判断子序列" class="headerlink" title="LeetCode练习（贪心算法）：392.判断子序列"></a><strong>LeetCode练习（贪心算法）：392.判断子序列</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/02/剑指Offer——13.调整数组顺序使奇数位于偶数前面/13_392.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：<br>依照次序，对s中的字符，依次在t中寻找相等的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubsequence(string s, string t) &#123;</span><br><span class="line">        if(s.size()==0)</span><br><span class="line">           return true;</span><br><span class="line">        </span><br><span class="line">        int tag=0;</span><br><span class="line">        for(int i=0;i&lt;t.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(t[i]==s[tag])</span><br><span class="line">            &#123;</span><br><span class="line">                tag++;</span><br><span class="line">                if(tag&gt;=s.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（贪心算法）：1221-分割平衡字符串"><a href="#LeetCode练习（贪心算法）：1221-分割平衡字符串" class="headerlink" title="LeetCode练习（贪心算法）：1221.分割平衡字符串"></a><strong>LeetCode练习（贪心算法）：1221.分割平衡字符串</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/02/剑指Offer——13.调整数组顺序使奇数位于偶数前面/13_1221.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>平衡字符串不要求对称，只要求数量R和L相等。例如“RLRRRLLRLL”可以分割成两个“RL”和“RRRLLRLL”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int balancedStringSplit(string s) &#123;</span><br><span class="line">        int Rnum = 0,Lnum = 0,n = 0;</span><br><span class="line">        for(int i = 0;i &lt;s.size();i++)&#123;</span><br><span class="line">            if(s[i] == &apos;R&apos;)</span><br><span class="line">                Rnum++;</span><br><span class="line">            if(s[i] == &apos;L&apos;)</span><br><span class="line">                Lnum++;</span><br><span class="line">            if(Rnum == Lnum)</span><br><span class="line">                n++;</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（贪心算法）：1046-最后一块石头的重量"><a href="#LeetCode练习（贪心算法）：1046-最后一块石头的重量" class="headerlink" title="LeetCode练习（贪心算法）：1046.最后一块石头的重量"></a><strong>LeetCode练习（贪心算法）：1046.最后一块石头的重量</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/02/剑指Offer——13.调整数组顺序使奇数位于偶数前面/13_1046.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>由于每次都需要取最重的两个元素，所以数据每次取出时必须是一个有序排列。如果使用sort每次取出前都排序依次，时间复杂度太高。这里使用了优先队列来解决这个问题。<br>具体的priority_queue底层是用堆来实现的，它将存储在vector或者deque中的数据利用大顶堆这种数据结构重新组织从而实现优先队列的功能。参考链接：<a href="http://c.biancheng.net/view/7010.html" target="_blank" rel="noopener">http://c.biancheng.net/view/7010.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lastStoneWeight(vector&lt;int&gt;&amp; stones) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; pq;</span><br><span class="line">        for(int i:stones)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(pq.size()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            int st1=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            int st2=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            if(st1!=st2)</span><br><span class="line">            &#123;</span><br><span class="line">                int new_stone=abs(st1-st2);</span><br><span class="line">                pq.push(new_stone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return (pq.size()==0)?0:pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——12.数值的整数次方（55-122-225）</title>
    <link href="http://hustxxj.github.io/2020/03/01/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9412.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>http://hustxxj.github.io/2020/03/01/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9412.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</id>
    <published>2020-03-01T05:22:28.000Z</published>
    <updated>2020-03-07T13:24:51.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0；</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>需要注意exponent为负数的情况</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        double res=1;</span><br><span class="line">        if(base == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        else if(exponent==0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;abs(exponent);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(exponent &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            res=1.0/res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（贪心算法）：225-用队列实现栈"><a href="#LeetCode练习（贪心算法）：225-用队列实现栈" class="headerlink" title="LeetCode练习（贪心算法）：225.用队列实现栈"></a><strong>LeetCode练习（贪心算法）：225.用队列实现栈</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>使用队列实现栈的下列操作：push(x)，pop()，top()，empty();</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><em>队列：queue,数组 ：vector,双向数组：deque,列表：list</em><br>这里要求用队列实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;int&gt; q1;</span><br><span class="line">    queue&lt;int&gt; q2;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        q2.push(x);</span><br><span class="line">        while(!q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q2.push(q1.front());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q1.push(q2.front());</span><br><span class="line">            q2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int res=q1.front();</span><br><span class="line">        q1.pop();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        int res;</span><br><span class="line">        if(q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res=0;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            res=q1.front();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return q1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（贪心算法）：122-买卖股票的最近时机II"><a href="#LeetCode练习（贪心算法）：122-买卖股票的最近时机II" class="headerlink" title="LeetCode练习（贪心算法）：122.买卖股票的最近时机II"></a><strong>LeetCode练习（贪心算法）：122.买卖股票的最近时机II</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获得的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><code><img src="/2020/03/01/剑指Offer——12.数值的整数次方/12_122.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：由于可以知道股票何时涨跌，所以要想赚最多的钱只需要在股票涨的前一天买入，股票跌的前一天卖出即可。</p><ol><li>先买一支股票，那么在哪一天买进呢？从第一天开始，追踪股票涨势，如果第二天涨，则头一天买入。</li><li>买进以后什么时候卖出？从买进当天开始观望，追踪股票涨势，在出现下跌的前一天卖出。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size()&lt;=1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(prices.size()==2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[1]&gt;prices[0])</span><br><span class="line">               return prices[1]-prices[0];</span><br><span class="line">            else</span><br><span class="line">               return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res=0;</span><br><span class="line">        int len=prices.size();</span><br><span class="line">        int buyPrice=0;bool already_buy=false;</span><br><span class="line">        int sailPrice=0;</span><br><span class="line">        for(int i=0;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int bak=prices[i];</span><br><span class="line">            int pre=prices[i+1];</span><br><span class="line">            if(pre&gt;bak &amp;&amp; already_buy==false) //明天股票要涨了，赶快买</span><br><span class="line">            &#123;</span><br><span class="line">                buyPrice=bak;</span><br><span class="line">                already_buy=true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(pre&lt;bak &amp;&amp; already_buy==true) //明天要跌了，赶快卖</span><br><span class="line">            &#123;</span><br><span class="line">                res+=prices[i]-buyPrice;</span><br><span class="line">                already_buy=false;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            if(i==len-2 &amp;&amp; pre&gt;=bak &amp;&amp; already_buy==true)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=pre-buyPrice;  //股市闭市,手上还有股票则全部抛售</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（贪心算法）：55-跳跃游戏"><a href="#LeetCode练习（贪心算法）：55-跳跃游戏" class="headerlink" title="LeetCode练习（贪心算法）：55.跳跃游戏"></a><strong>LeetCode练习（贪心算法）：55.跳跃游戏</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个非负数整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。<br><code><img src="/2020/03/01/剑指Offer——12.数值的整数次方/12_55.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：本题题意有个地方需要理解清楚，不然容易产生混淆。即“每个元素代表你在该位置<em>可以跳跃的最大长度</em>”。并且还有一点，需要前移多少格，由该位置的<em>权重值</em>决定，这个权重值指“位置i+位置的值nums[i]”。只有当该点的权重值大于它所覆盖的每个点的权重值时，才会能走几格走几格，否则会走向它所覆盖的位置中权重最大的点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;len;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0 &amp;&amp; i!=len-1)</span><br><span class="line">               return false;</span><br><span class="line">            </span><br><span class="line">            if(i==len-1)</span><br><span class="line">               return true;</span><br><span class="line"></span><br><span class="line">            if(i+nums[i]&gt;=len-1)</span><br><span class="line">               return true;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int V_Max=i+nums[i];</span><br><span class="line">                for(int j=i+1;j&lt;=i+nums[i];j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(nums[j]+j&gt;V_Max)</span><br><span class="line">                    &#123;</span><br><span class="line">                        i=j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(j==i+nums[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        i+=nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;给定一个double类型的浮点数base和int类型的整数exponent。求b
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——11.二进制中1的个数（83-106-234）</title>
    <link href="http://hustxxj.github.io/2020/02/29/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9411.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/02/29/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9411.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2020-02-29T07:11:10.000Z</published>
    <updated>2020-03-07T13:24:26.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br>+5（原码：00000101，反码：00000101，补码：00000101）<br>-5（原码：10000101，反码：11111010，补码：11111011）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p><em>整数在内存中是用补码表示的</em><br>用m=1与给的数n逐位&amp;运算，每运行完一次，判断运算结果是否大于0，如果是则计数+1，否则不加。与此同时，m左移一位再次&amp;运算直到m==0为止</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int res=0;</span><br><span class="line">         int flag=1;</span><br><span class="line">         while(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             if(flag &amp; n)</span><br><span class="line">             &#123;</span><br><span class="line">                 res++;</span><br><span class="line">             &#125;</span><br><span class="line">             flag&lt;&lt;=1;</span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：234-回文链表"><a href="#LeetCode练习（链表）：234-回文链表" class="headerlink" title="LeetCode练习（链表）：234.回文链表"></a><strong>LeetCode练习（链表）：234.回文链表</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>请判断一个链表是否为回文链表。<br>示例1：输入1-&gt;2,输出false;输入1-&gt;2-&gt;2-&gt;1,输出true。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：这题可以用deque来实现，先遍历链表将其都放入deque中，然后每次弹出第一个和最后一个元素进行比较，如果不相同则直接返回false。如果直到deque为空还没有返回则返回true。<em>弹出前需要先判断deque中是否还有两个或两个以上元素</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">          return true;</span><br><span class="line">        </span><br><span class="line">        deque&lt;ListNode*&gt; de;</span><br><span class="line">        ListNode* ptr=head;</span><br><span class="line">        while(ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            de.push_back(ptr);</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!de.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            if(de.size()==1)</span><br><span class="line">               break;</span><br><span class="line">            ListNode* begin_node=de[0];</span><br><span class="line">            ListNode* end_node=de[de.size()-1];</span><br><span class="line">            de.pop_back();</span><br><span class="line">            de.pop_front();</span><br><span class="line">            if(begin_node-&gt;val != end_node-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（链表）：106-相交链表"><a href="#LeetCode练习（链表）：106-相交链表" class="headerlink" title="LeetCode练习（链表）：106.相交链表"></a><strong>LeetCode练习（链表）：106.相交链表</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>编写一个程序，找到两个单链表相交的起始节点，要求时间复杂度O(n)，空间复杂度O(1)。如图所示：<br><code><img src="/2020/02/29/剑指Offer——11.二进制中1的个数/11_160.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><code><img src="/2020/02/29/剑指Offer——11.二进制中1的个数/11_160_1.jpg" title="示例图"></code><br><code><img src="/2020/02/29/剑指Offer——11.二进制中1的个数/11_160_2.jpg" title="示例图"></code><br><code><img src="/2020/02/29/剑指Offer——11.二进制中1的个数/11_160_3.jpg" title="示例图"></code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if(headA==nullptr || headB==nullptr)</span><br><span class="line">           return NULL;</span><br><span class="line">        </span><br><span class="line">        ListNode* ptrA=headA;</span><br><span class="line">        ListNode* ptrB=headB;</span><br><span class="line"></span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ptrA==ptrB)</span><br><span class="line">               return ptrA;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ptrA=ptrA-&gt;next;</span><br><span class="line">                ptrB=ptrB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(ptrA==nullptr &amp;&amp; ptrB==nullptr)</span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line">            if(ptrA==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                ptrA=headB;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(ptrB==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                ptrB=headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（链表）：83-删除排序链表中的重复元素"><a href="#LeetCode练习（链表）：83-删除排序链表中的重复元素" class="headerlink" title="LeetCode练习（链表）：83.删除排序链表中的重复元素"></a><strong>LeetCode练习（链表）：83.删除排序链表中的重复元素</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br>例如：输入1-&gt;1-&gt;2-&gt;3-&gt;3，输出1-&gt;2-&gt;3</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>该题可以利用双指针来实现，定义一个前指针和一个后指针，判断两个指针的值是否相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">           return head;</span><br><span class="line"></span><br><span class="line">        ListNode* pre_ptr=head-&gt;next;</span><br><span class="line">        ListNode* bak_ptr=head;</span><br><span class="line">        while(pre_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pre_ptr-&gt;val==bak_ptr-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre_ptr=pre_ptr-&gt;next;</span><br><span class="line">                bak_ptr-&gt;next=pre_ptr;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                pre_ptr=pre_ptr-&gt;next;</span><br><span class="line">                bak_ptr=bak_ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;br&gt;+5（原
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
