<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江江的小跟班.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hustxxj.github.io/"/>
  <updated>2020-04-03T02:14:07.245Z</updated>
  <id>http://hustxxj.github.io/</id>
  
  <author>
    <name>Xuxuejie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer——32.把数组排成最小的数（48-69-289）</title>
    <link href="http://hustxxj.github.io/2020/04/02/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9432.%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/04/02/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9432.%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</id>
    <published>2020-04-02T02:51:27.000Z</published>
    <updated>2020-04-03T02:14:07.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>需要理解灵活使用sort()函数的用法</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> B=<span class="string">""</span>;</span><br><span class="line">        A+=to_string(a);</span><br><span class="line">        A+=to_string(b);</span><br><span class="line">        B+=to_string(b);</span><br><span class="line">        B+=to_string(a);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> A&lt;B;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">""</span>;</span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(),numbers.<span class="built_in">end</span>(),compare);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：289-生命游戏"><a href="#LeetCode练习（数组）：289-生命游戏" class="headerlink" title="LeetCode练习（数组）：289.生命游戏"></a><strong>LeetCode练习（数组）：289.生命游戏</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><pre><code>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</code></pre><p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>示例：</p><p>输入：<br>[<br>  [0,1,0],<br>  [0,0,1],<br>  [1,1,1],<br>  [0,0,0]<br>]<br>输出：<br>[<br>  [0,0,0],<br>  [1,0,1],<br>  [0,1,1],<br>  [0,1,0]<br>]</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=board.<span class="built_in">size</span>()+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n=board[<span class="number">0</span>].<span class="built_in">size</span>()+<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; copy(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;m<span class="number">-2</span> &amp;&amp; j&lt;n<span class="number">-2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j]==<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        copy[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> livecount=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> dir:dirs)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> dx=i+<span class="number">1</span>+dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> dy=j+<span class="number">1</span>+dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(copy[dx][dy]==<span class="number">1</span>)</span><br><span class="line">                       livecount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(livecount&lt;<span class="number">2</span> &amp;&amp; board[i][j]==<span class="number">1</span>)</span><br><span class="line">                    board[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(livecount&gt;<span class="number">3</span> &amp;&amp; board[i][j]==<span class="number">1</span>)</span><br><span class="line">                    board[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(livecount==<span class="number">3</span> &amp;&amp; board[i][j]==<span class="number">0</span>)</span><br><span class="line">                    board[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：48-旋转图像"><a href="#LeetCode练习（数组）：48-旋转图像" class="headerlink" title="LeetCode练习（数组）：48.旋转图像"></a><strong>LeetCode练习（数组）：48.旋转图像</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:</p><p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 首先对矩阵进行转职</span></span><br><span class="line"><span class="comment">[                                                  [</span></span><br><span class="line"><span class="comment">  [1,2,3],                                            [1,4,7]</span></span><br><span class="line"><span class="comment">  [4,5,6],          ----------------------------&gt;     [2,5,8]</span></span><br><span class="line"><span class="comment">  [7,8,9]                                             [3,6,9]</span></span><br><span class="line"><span class="comment">],                                                 ]</span></span><br><span class="line"><span class="comment">* 然后再对转置后的矩阵逐行翻转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[j][i];</span><br><span class="line">                matrix[j][i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][l];</span><br><span class="line">                matrix[i][l]=matrix[i][r];</span><br><span class="line">                matrix[i][r]=temp;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：69-x的平方根"><a href="#LeetCode练习（数组）：69-x的平方根" class="headerlink" title="LeetCode练习（数组）：69.x的平方根"></a><strong>LeetCode练习（数组）：69.x的平方根</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2</p><p>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*需要注意以下几点：1. 使用二分查找可以提高效率</span></span><br><span class="line"><span class="comment">                 2. 判断中位数的平方是否等于目标值x时，用mid*mid==x会导致越界，应该                     使用mid==mid/x</span></span><br><span class="line"><span class="comment">                 3. x==1的情况不能忽略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=x;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid == x/mid)</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mid &lt; x/mid)</span><br><span class="line">                &#123;</span><br><span class="line">                    l=mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; x/mid)</span><br><span class="line">                &#123;</span><br><span class="line">                    r=mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://hustxxj.github.io/2020/04/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://hustxxj.github.io/2020/04/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-04-01T10:27:25.000Z</published>
    <updated>2020-04-02T02:11:27.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h1><hr><p>平衡二叉树是对二叉排序树的改进，由于二叉排序树在某些情况下会退化为链表，为了解决二叉排序树存在的这个问题，于是规定了<strong><em>平衡二叉树任意结点的左右子树的高度差不能超过1</em></strong>。</p><p>有关平衡二叉树的两个概念：</p><p>1&gt;平衡因子：</p><p>平衡二叉树上结点左子树的高度减去右子树的高度称为该结点的平衡因子BF（Balance Factor）。BF的取值范围为[-1,1]，如果发现某个结点的BF不在这个范围，就需要对树进行调整。</p><p>2&gt;最小不平衡子树：</p><p>插入一个结点后，距离插入结点最近的，且平衡因子不在[-1,1]范围的结点。</p><p><code><img src="/2020/04/01/平衡二叉树/pic0.jpg" title="示例图"></code></p><p>二叉排序树是如何进化为平衡二叉树的呢？答案是：<strong><em>旋转</em></strong></p><p>在介绍如何将一个失衡的二叉排序树旋转为一个平衡二叉树之前，首先介绍二叉排序树失衡的四种情况：</p><blockquote><p>LL型：根节点的左子树的左子树过深导致失衡状态</p></blockquote><blockquote><p>LR型：根节点的左子树的右子树过深导致失衡状态</p></blockquote><blockquote><p>RL型：根节点的右子树的左子树过深导致失衡状态</p></blockquote><blockquote><p>RR型：根节点的右子树的右子树过深导致失衡状态</p></blockquote><p><code><img src="/2020/04/01/平衡二叉树/pic1.jpg" title="示例图"></code></p><p>对于每种情况导致的失衡，旋转的策略也不相同。</p><hr><h2 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a><strong>平衡二叉树的调整</strong></h2><p><strong>参考博客</strong>：<em><a href="https://blog.csdn.net/isunbin/article/details/81707606" target="_blank" rel="noopener">https://blog.csdn.net/isunbin/article/details/81707606</a></em></p><p>定义平衡二叉树的结点结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure><h3 id="LL型失衡调整"><a href="#LL型失衡调整" class="headerlink" title="LL型失衡调整"></a><strong>LL型失衡调整</strong></h3><p><code><img src="/2020/04/01/平衡二叉树/pic2.jpg" title="示例图"></code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">LL_Rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x;</span><br><span class="line">    x=y-&gt;left;</span><br><span class="line">    y-&gt;left=x-&gt;right;</span><br><span class="line">    x-&gt;right=y;</span><br><span class="line">    </span><br><span class="line">    y-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left),<span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left),<span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RR型失衡调整"><a href="#RR型失衡调整" class="headerlink" title="RR型失衡调整"></a><strong>RR型失衡调整</strong></h3><p><code><img src="/2020/04/01/平衡二叉树/pic3.jpg" title="示例图"></code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">RR_Rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x;</span><br><span class="line">    x=y-&gt;right;</span><br><span class="line">    y-&gt;right=x-&gt;left;</span><br><span class="line">    x-&gt;left=y;</span><br><span class="line">    </span><br><span class="line">    y-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left),<span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left),<span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LR型调整"><a href="#LR型调整" class="headerlink" title="LR型调整"></a><strong>LR型调整</strong></h3><p><code><img src="/2020/04/01/平衡二叉树/pic4.jpg" title="示例图"></code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">LR_Rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x=y-&gt;left;</span><br><span class="line">    y-&gt;left=RR_Rotate(x);</span><br><span class="line">    <span class="keyword">return</span> LL_Rotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RL型调整"><a href="#RL型调整" class="headerlink" title="RL型调整"></a><strong>RL型调整</strong></h3><p><code><img src="/2020/04/01/平衡二叉树/pic5.jpg" title="示例图"></code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">RL_Rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x=y-&gt;right;</span><br><span class="line">    y-&gt;right=LL_Rotate(x);</span><br><span class="line">    <span class="keyword">return</span> RR_Rotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="平衡二叉树实现实例"><a href="#平衡二叉树实现实例" class="headerlink" title="平衡二叉树实现实例"></a><strong>平衡二叉树实现实例</strong></h2><h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a><strong>平衡二叉树的插入</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct Node *N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)   <span class="comment">//这一步很重要</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> = (<span class="title">BTNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">LL_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line"> </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">RR_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;right;</span><br><span class="line">    y-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left = y;</span><br><span class="line"> </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(BTNode* N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)  <span class="comment">//这一步很重要</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(N-&gt;left) - <span class="built_in">height</span>(N-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//向平衡二叉树中插入值为key的节点，返回二叉树的根节点</span></span><br><span class="line"><span class="function">BTNode* <span class="title">insert</span><span class="params">(BTNode* node<span class="comment">/*平衡二叉树根节点*/</span>, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*part1:常规判断根节点是否为NULL，为空则新建一个节点*/</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode(key);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*part2:迭代找出需要添加节点的位置*/</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*part3:判断二叉树是否还是平衡二叉树，不平衡则旋转*/</span></span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> LL_rotate(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)     <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> RR_rotate(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key)     <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;left = RR_rotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> LL_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key)     <span class="comment">//RL型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;right = LL_rotate(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> RR_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *root = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    root = insert(root, <span class="number">2</span>);</span><br><span class="line">    root = insert(root, <span class="number">1</span>);</span><br><span class="line">    root = insert(root, <span class="number">0</span>);</span><br><span class="line">    root = insert(root, <span class="number">3</span>);</span><br><span class="line">    root = insert(root, <span class="number">4</span>);</span><br><span class="line">    root = insert(root, <span class="number">4</span>);</span><br><span class="line">    root = insert(root, <span class="number">5</span>);</span><br><span class="line">    root = insert(root, <span class="number">6</span>);</span><br><span class="line">    root = insert(root, <span class="number">9</span>);</span><br><span class="line">    root = insert(root, <span class="number">8</span>);</span><br><span class="line">    root = insert(root, <span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历："</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><strong>删除节点</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">minValueNode</span><span class="params">(BTNode* node)</span>   <span class="comment">//返回最左叶子节点（值最小的点）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* current = node;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        current=current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除平衡二叉树中值为key的节点，返回平衡二叉树的根节点</span></span><br><span class="line"><span class="function">BTNode* <span class="title">deleteNode</span><span class="params">(BTNode* root<span class="comment">/*平衡二叉树根节点*/</span>,<span class="keyword">int</span> key)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*part1:常规判断根节点是否为NULL，为NULL则返回NULL*/</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*part2:迭代找出需要删除节点的位置*/</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left=deleteNode(root-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right=deleteNode(root-&gt;right,key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((root-&gt;left==<span class="literal">NULL</span>) || (root-&gt;right==<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp=(root-&gt;left!=<span class="literal">NULL</span>)?root-&gt;left:root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)  <span class="comment">//根节点没有子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=root;</span><br><span class="line">                root=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>          <span class="comment">//根存在一个子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                *root=*temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;<span class="keyword">else</span>             <span class="comment">//根节点左右两个子节点都存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp=minValueNode(root-&gt;right);</span><br><span class="line">            root-&gt;key=temp-&gt;key;</span><br><span class="line">            root-&gt;right=deleteNode(root-&gt;right,temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)  <span class="comment">//这一步不能忘记</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*part3:判断二叉树是否还是平衡二叉树，不平衡则旋转*/</span></span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="number">0</span>) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> LL_rotate(root);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="number">0</span>) <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left =  RR_rotate(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> LL_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> RR_rotate(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="number">0</span>)  <span class="comment">//RL型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = LL_rotate(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> RR_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct Node *N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> = (<span class="title">BTNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">ll_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line"> </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">rr_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;right;</span><br><span class="line">    y-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left = y;</span><br><span class="line"> </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(BTNode* N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(N-&gt;left) - <span class="built_in">height</span>(N-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">insert</span><span class="params">(BTNode* node, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode(key);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"> </span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> ll_rotate(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)     <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> rr_rotate(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key)     <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;left = rr_rotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ll_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key)     <span class="comment">//RL型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;right = ll_rotate(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> rr_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode * <span class="title">minValueNode</span><span class="params">(BTNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* current = node;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">deleteNode</span><span class="params">(BTNode* root, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;left == <span class="literal">NULL</span>) || (root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *root = *temp;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp = minValueNode(root-&gt;right);</span><br><span class="line"> </span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line"> </span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"> </span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(root);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="number">0</span>) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> ll_rotate(root);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="number">0</span>) <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = rr_rotate(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ll_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> rr_rotate(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="number">0</span>)  <span class="comment">//Rl型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = ll_rotate(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> rr_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *root = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    root = insert(root, <span class="number">9</span>);</span><br><span class="line">    root = insert(root, <span class="number">5</span>);</span><br><span class="line">    root = insert(root, <span class="number">10</span>);</span><br><span class="line">    root = insert(root, <span class="number">0</span>);</span><br><span class="line">    root = insert(root, <span class="number">6</span>);</span><br><span class="line">    root = insert(root, <span class="number">11</span>);</span><br><span class="line">    root = insert(root, <span class="number">-1</span>);</span><br><span class="line">    root = insert(root, <span class="number">1</span>);</span><br><span class="line">    root = insert(root, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历：\n"</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* The constructed AVL Tree would be</span></span><br><span class="line"><span class="comment">                     9</span></span><br><span class="line"><span class="comment">                    /  \</span></span><br><span class="line"><span class="comment">                   1    10</span></span><br><span class="line"><span class="comment">                 /  \     \</span></span><br><span class="line"><span class="comment">                0    5     11</span></span><br><span class="line"><span class="comment">               /    /  \</span></span><br><span class="line"><span class="comment">              -1   2    6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    root = deleteNode(root, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* The AVL Tree after deletion of 10</span></span><br><span class="line"><span class="comment">                       1</span></span><br><span class="line"><span class="comment">                     /   \</span></span><br><span class="line"><span class="comment">                    0     9</span></span><br><span class="line"><span class="comment">                  /     /  \</span></span><br><span class="line"><span class="comment">                -1     5     11</span></span><br><span class="line"><span class="comment">                     /  \</span></span><br><span class="line"><span class="comment">                    2    6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历：\n"</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;&lt;strong&gt;平衡二叉树&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;平衡二叉树是对二叉排序树的改进，由于二叉排序树在某些情况下会退化为链表，
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://hustxxj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://hustxxj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——31.整数中1出现的次数（365-416-f62）</title>
    <link href="http://hustxxj.github.io/2020/03/30/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9431.%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/03/30/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9431.%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2020-03-30T04:13:39.000Z</published>
    <updated>2020-03-30T05:51:11.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>最简单的思路：将数字转换为字符串，然后逐一计算每个字符串中’1’出现的个数，累加起来得到答案。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=Caculate1num(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Caculate1num</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss&lt;&lt;num;</span><br><span class="line">        str=ss.str();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">'1'</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（约瑟夫环）：面试题62-圆圈中最后剩下的数字"><a href="#LeetCode练习（约瑟夫环）：面试题62-圆圈中最后剩下的数字" class="headerlink" title="LeetCode练习（约瑟夫环）：面试题62. 圆圈中最后剩下的数字"></a><strong>LeetCode练习（约瑟夫环）：面试题62. 圆圈中最后剩下的数字</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>示例 1：</p><p>输入: n = 5, m = 3<br>输出: 3</p><p>示例 2：</p><p>输入: n = 10, m = 17<br>输出: 2</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">推导法：</span></span><br><span class="line"><span class="comment">n=1: ans=0;</span></span><br><span class="line"><span class="comment">n=2: ans=(0+m)%2</span></span><br><span class="line"><span class="comment">n=3: ans=((0+m)%2+m)%3</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=(ans+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：416-分割等和子集"><a href="#LeetCode练习（动态规划）：416-分割等和子集" class="headerlink" title="LeetCode练习（动态规划）：416.分割等和子集"></a><strong>LeetCode练习（动态规划）：416.分割等和子集</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><pre><code>每个数组中的元素不会超过 100数组的大小不会超过 200</code></pre><p>示例 1:</p><p>输入: [1, 5, 11, 5]</p><p>输出: true</p><p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2:</p><p>输入: [1, 2, 3, 5]</p><p>输出: false</p><p>解释: 数组不能分割成两个元素和相等的子集.</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i][j]表示利用前i个数，能否组成一个和为j的值</span></span><br><span class="line"><span class="comment">最后返回结果bool ans=dp[nums.size()][sum/2]</span></span><br><span class="line"><span class="comment">注意：第i个值的大小为num[i-1]</span></span><br><span class="line"><span class="comment">dp[i][j]:</span></span><br><span class="line"><span class="comment">    case1:dp[i-1][j-nums[i-1]] //加第i个值</span></span><br><span class="line"><span class="comment">    case2:dp[i-1][j]         //不加第i个值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;((sum/<span class="number">2</span>)+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=sum/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sum/<span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i<span class="number">-1</span>]&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]] | dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len][sum/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数学）：365-水壶问题"><a href="#LeetCode练习（数学）：365-水壶问题" class="headerlink" title="LeetCode练习（数学）：365. 水壶问题"></a><strong>LeetCode练习（数学）：365. 水壶问题</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p><p>你允许：</p><pre><code>装满任意一个水壶清空任意一个水壶从一个水壶向另外一个水壶倒水，直到装满或者倒空</code></pre><p>示例 1: (From the famous “Die Hard” example)</p><p>输入: x = 3, y = 5, z = 4<br>输出: True</p><p>示例 2:</p><p>输入: x = 2, y = 6, z = 5<br>输出: False</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(z&gt;x+y)          <span class="comment">//两个杯子都装满也达不到所需容量</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span> || y==<span class="number">0</span>)   <span class="comment">//只有一个杯子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(z==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x==z || y==z)   <span class="comment">//只有一个杯子，且杯子的容量正好等于所需容量</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z%gcd(x,y)==<span class="number">0</span>;   <span class="comment">//z是否是x,y最大公约数的整数倍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——30.连续子数组的最大和（64-820-1162）</title>
    <link href="http://hustxxj.github.io/2020/03/28/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9430.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://hustxxj.github.io/2020/03/28/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9430.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
    <published>2020-03-28T01:33:00.000Z</published>
    <updated>2020-03-29T03:58:52.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>这是一道典型的动态规划题目，整理出状态转移方程：</p><p>dp[n]表示读取完第n个数，最大连续子序列的和<br>所以dp[n]= dp[n-1]+array[n]    当dp[n-1]&gt;0时<br>               = array[n]                 当dp[n-1]&lt;=0时</p><p>直接按照状态转移方程可以得出正确结果，但是这里可以做一些简化以降低空间复杂度：因为dp[n]的值只与前一个状态dp[n-1]有关，所以可以用一个变量v_last存储dp[n-1]的值。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> v_last=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v_max=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v_last&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v_last+=<span class="built_in">array</span>[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                v_last=<span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v_last&gt;v_max)</span><br><span class="line">            &#123;</span><br><span class="line">                v_max=v_last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：820-单词的压缩编码"><a href="#LeetCode练习（字符串）：820-单词的压缩编码" class="headerlink" title="LeetCode练习（字符串）：820.单词的压缩编码"></a><strong>LeetCode练习（字符串）：820.单词的压缩编码</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p><p>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。</p><p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p><p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><p>示例：</p><p>输入: words = [“time”, “me”, “bell”]<br>输出: 10<br>说明: S = “time#bell#” ， indexes = [0, 2, 5] 。</p><p>提示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= words.length &lt;= <span class="number">2000</span></span><br><span class="line"><span class="number">1</span> &lt;= words[i].length &lt;= <span class="number">7</span></span><br><span class="line">每个单词都是小写字母 。</span><br></pre></td></tr></table></figure><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><p>由数据范围可知一个单词最多含有 7 个后缀，所以我们可以枚举单词所有的后缀。对于每个后缀，如果其存在 words 列表中，我们就将其从列表中删除。为了高效删除，我们将 words 用哈希集合（HashSet）来存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; good(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="keyword">word</span>:words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                good.erase(<span class="keyword">word</span>.substr(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">word</span>: good) &#123;</span><br><span class="line">            ans += <span class="keyword">word</span>.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（BSF）：1162-地图分析"><a href="#LeetCode练习（BSF）：1162-地图分析" class="headerlink" title="LeetCode练习（BSF）：1162.地图分析"></a><strong>LeetCode练习（BSF）：1162.地图分析</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p><p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先寻找出所有陆地的坐标,存储在队列中</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">                   que.push(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(que.empty()  || que.<span class="built_in">size</span>()==grid.<span class="built_in">size</span>()*grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐个弹出队列中的陆地，将它上下左右的海洋(0)标记为陆地(BFS),标记值为基地陆地值+1</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;   <span class="comment">//存储基地陆地值</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            ans=grid[temp.first][temp.second];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d:direction)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> dx=temp.first+d[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> dy=temp.second+d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dx&lt;<span class="number">0</span> || dx &gt;= grid.<span class="built_in">size</span>())</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dy&lt;<span class="number">0</span> || dy &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid[dx][dy]!=<span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                grid[dx][dy]=ans+<span class="number">1</span>;</span><br><span class="line">                que.push(&#123;dx,dy&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：64-最小路径和"><a href="#LeetCode练习（动态规划）：64-最小路径和" class="headerlink" title="LeetCode练习（动态规划）：64.最小路径和"></a><strong>LeetCode练习（动态规划）：64.最小路径和</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——29.最小K个数</title>
    <link href="http://hustxxj.github.io/2020/03/27/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9429.%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/03/27/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9429.%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/</id>
    <published>2020-03-27T01:57:45.000Z</published>
    <updated>2020-03-27T04:44:20.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>需要注意考虑K大于输入数组的容量的情况。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(input.<span class="built_in">size</span>()==<span class="number">0</span> || k==<span class="number">0</span> || k&gt;input.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        sort(input.<span class="built_in">begin</span>(),input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：941-卡牌分组"><a href="#LeetCode练习（数组）：941-卡牌分组" class="headerlink" title="LeetCode练习（数组）：941.卡牌分组"></a><strong>LeetCode练习（数组）：941.卡牌分组</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：计算数组中每个数出现的次数，然后求最大公约数，如果最大公约数小于等于1则返回false，否则返回true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=deck.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[deck[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sav;     <span class="comment">//记录每个数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            sav.push_back(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sav.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sav[<span class="number">0</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sav.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sav[i+<span class="number">1</span>]=measure(sav[i],sav[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sav[sav.<span class="built_in">size</span>()<span class="number">-1</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">            &#123;</span><br><span class="line">                a=a-b;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                b=b-a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：12-整数转罗马数字"><a href="#LeetCode练习（字符串）：12-整数转罗马数字" class="headerlink" title="LeetCode练习（字符串）：12.整数转罗马数字"></a><strong>LeetCode练习（字符串）：12.整数转罗马数字</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/27/剑指Offer——29.最小K个数/29_2.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'M'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num-=count*<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'C'</span>);</span><br><span class="line">                res.push_back(<span class="string">'D'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'C'</span>);</span><br><span class="line">                res.push_back(<span class="string">'M'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'D'</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count<span class="number">-5</span>;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'C'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'C'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num-=count*<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'X'</span>);</span><br><span class="line">                res.push_back(<span class="string">'L'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'X'</span>);</span><br><span class="line">                res.push_back(<span class="string">'C'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'L'</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count<span class="number">-5</span>;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'X'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'X'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num-=count*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'I'</span>);</span><br><span class="line">                res.push_back(<span class="string">'V'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'I'</span>);</span><br><span class="line">                res.push_back(<span class="string">'X'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;=<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'V'</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num<span class="number">-5</span>;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'I'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'I'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：125-验证回文串"><a href="#LeetCode练习（字符串）：125-验证回文串" class="headerlink" title="LeetCode练习（字符串）：125.验证回文串"></a><strong>LeetCode练习（字符串）：125.验证回文串</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/27/剑指Offer——29.最小K个数/29_3.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> new_str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">               new_str.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'a'</span>&amp;&amp;s[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">               new_str.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'A'</span>&amp;&amp;s[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">               new_str.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=new_str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(new_str[left]!=new_str[right]  &amp;&amp; <span class="built_in">abs</span>(new_str[left]-new_str[right])!=<span class="number">32</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(new_str[left]&gt;=<span class="string">'0'</span>&amp;&amp;new_str[left]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(new_str[right]&gt;=<span class="string">'a'</span>&amp;&amp;new_str[right]&lt;=<span class="string">'z'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(new_str[right]&gt;=<span class="string">'A'</span>&amp;&amp;new_str[right]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(new_str[right]&gt;=<span class="string">'0'</span>&amp;&amp;new_str[right]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(new_str[left]&gt;=<span class="string">'a'</span>&amp;&amp;new_str[left]&lt;=<span class="string">'z'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(new_str[left]&gt;=<span class="string">'A'</span>&amp;&amp;new_str[left]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——28.数组中出现次数超过一半的数字（876-999-f17.16）</title>
    <link href="http://hustxxj.github.io/2020/03/26/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9428.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://hustxxj.github.io/2020/03/26/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9428.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-03-26T01:06:15.000Z</published>
    <updated>2020-03-26T02:34:10.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用map对每个数字出现的次数进行计数，并且判断计数是否超过长度的一半。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cot[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(cot[numbers[i]]&gt;(len/<span class="number">2</span>))</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：999-车的可用捕获量"><a href="#LeetCode练习（数组）：999-车的可用捕获量" class="headerlink" title="LeetCode练习（数组）：999.车的可用捕获量"></a><strong>LeetCode练习（数组）：999.车的可用捕获量</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p><p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p><p>返回车能够在一次移动中捕获到的卒的数量。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hang=board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(hang==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lie=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> location_x,location_y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hang;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator it=<span class="built_in">find</span>(board[i].<span class="built_in">begin</span>(),board[i].<span class="built_in">end</span>(),<span class="string">'R'</span>);</span><br><span class="line">            <span class="keyword">if</span>(it!=board[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                location_x=i;</span><br><span class="line">                location_y=it-board[i].<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//'R'的坐标为board[location_x][location_y]</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左找'p',如果找到'p'之前先遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_y<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_y+<span class="number">1</span>;i&lt;=lie<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_x<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向下找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_x+<span class="number">1</span>;i&lt;=hang<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（快慢指针）：876-链表的中间结点"><a href="#LeetCode练习（快慢指针）：876-链表的中间结点" class="headerlink" title="LeetCode练习（快慢指针）：876.链表的中间结点"></a><strong>LeetCode练习（快慢指针）：876.链表的中间结点</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针实现，需要注意while结束边界条件</span></span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：面试题17-16-按摩师"><a href="#LeetCode练习（动态规划）：面试题17-16-按摩师" class="headerlink" title="LeetCode练习（动态规划）：面试题17.16.按摩师"></a><strong>LeetCode练习（动态规划）：面试题17.16.按摩师</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i][0]表示当前预约不接，所获得最大钱数</span></span><br><span class="line"><span class="comment">dp[i][0]=max&#123;dp[i-1][0],dp[i-1][1]&#125;;</span></span><br><span class="line"><span class="comment">dp[i][1]表示当前预约接，所获得最大钱数</span></span><br><span class="line"><span class="comment">dp[i][1]=dp[i-1][0]+nums[i];</span></span><br><span class="line"><span class="comment">result=max&#123;dp[len-1][0],dp[len-1][1]&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[len<span class="number">-1</span>][<span class="number">0</span>],dp[len<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>基础查找算法整理</title>
    <link href="http://hustxxj.github.io/2020/03/23/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://hustxxj.github.io/2020/03/23/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-03-23T12:19:40.000Z</published>
    <updated>2020-03-24T12:39:46.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5种基础的查找算法"><a href="#5种基础的查找算法" class="headerlink" title="5种基础的查找算法"></a><strong>5种基础的查找算法</strong></h1><hr><p>本文对7种基础的查找算法做了整理，包括顺序查找（不做讨论）、二分查找、插值查找、哈希查找、二叉搜索树查找以及红黑树。实现了这5中查找算法的代码并讨论了各自的时间复杂度和空间复杂度。</p><hr><h2 id="01-二分查找"><a href="#01-二分查找" class="headerlink" title="#01.二分查找"></a><strong>#01.二分查找</strong></h2><hr><p>对于一个常规的<em>有序</em>数组而言，进行二分查找的思路比较简单。将所要查找的元素每次和数组的中间元素进行比较，如果大于中间元素值，则对数组的后半部分进行二分查找；如果小于中间元素，则对数组的前半部分进行二分查找。</p><p>二分查找的时间复杂度为O(logN)，空间复杂度为O(1)，要求数组是有序的。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">        &#123;</span><br><span class="line">            index=mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//简单二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>简单二分查找要求数组需要是一个常规有序数组，现在考虑利用二分查找对一个<em>旋转有序数组</em>进行查找。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//旋转数组二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_Rotate_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=a[left])   <span class="comment">//左边有序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=a[left] &amp;&amp; target&lt;a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右边有序</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;=a[right] &amp;&amp; target&gt;a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_Rotate_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="02-插值查找"><a href="#02-插值查找" class="headerlink" title="#02.插值查找"></a><strong>#02.插值查找</strong></h2><hr><p>插值查找是对二分查找的改进，适用于数组数据分布比较均匀的情况，但是如果数组分布较极端那么插值查找的效率反而不如二分查找。</p><p>二分查找的公式为：</p><p><code><img src="/2020/03/23/基础查找算法整理/02_01.jpg" title="示例图"></code></p><p>插值查找的公式为：</p><p><code><img src="/2020/03/23/基础查找算法整理/02_02.jpg" title="示例图"></code></p><p>插值查找的平均期望复杂度为O(loglogN)，空间复杂度为O(1)，要求数组是有序的。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=left+((target-a[left])/(a[right]-a[left]))*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="03-哈希查找"><a href="#03-哈希查找" class="headerlink" title="#03.哈希查找"></a><strong>#03.哈希查找</strong></h2><hr><p>哈希查找是指：将所要查找的值带入哈希函数中，直接索引出值的位置。即：index=H(value)，H()表示哈希函数。</p><p><strong>哈希函数的构造方式</strong>：哈希函数的构造方式通常有五种</p><p>1&gt;直接定址法：H(value)=a x value+b，这种形式适合于表较小且连续的情况。</p><p>2&gt;数字分析法</p><p>3&gt;平方取中法</p><p>4&gt;折叠法</p><p>5&gt;除数留余法：H(value)=value MOD p （p&lt;=m，m为表长）。该方法是用的最多的方法。</p><p><strong>解决哈希冲突的方法</strong>：解决哈希冲突的方法通常有四种，开放定制法，链地址法，公共溢出区法，再散列法。主要介绍前两种常见方法。</p><p>1&gt;<strong>开放定制法</strong>：如果两个数value_x（前），value_y（后）的哈希函数值发生冲突，H(value_x)==H(value_y)，那么H(value_y)会改为H(value_y)+D </p><p>D的取值有三种取法：</p><p>①线性探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_01.jpg" title="示例图"></code></p><p>②平方探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_02.jpg" title="示例图"></code></p><p>③随机探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_03.jpg" title="示例图"></code></p><p>2&gt; <strong>链地址法</strong>：产生哈希冲突后再存储数据后面加一个指针，指向后面冲突的数据</p><p><code><img src="/2020/03/23/基础查找算法整理/03_04.jpg" title="示例图"></code></p><p>需要注意的是哈希表在删除元素时：链地址法可以直接删除；<em>但是对于开放定制法，如果直接删除前面的元素就会导致后面的元素无法索引到，所以需要在删除时插入一个原来不存在的数据如-1。</em></p><p>哈希查找的时间复杂度为O(1)，空间复杂度为O(n)，对于要查找的数组是否有序没有要求。</p><hr><h2 id="04-二叉搜索树查找"><a href="#04-二叉搜索树查找" class="headerlink" title="#04.二叉搜索树查找"></a><strong>#04.二叉搜索树查找</strong></h2><hr><p>首先介绍一下<strong>什么是二叉搜索树</strong>，二叉搜索树满足以下条件：</p><p>①若它的左子树不为空，则<strong>左子树上所有节点</strong>的值均小于它根节点的值</p><p>②若它的右子树不为空，则<strong>右子树上所有节点</strong>的值均大于它根节点的值</p><p><code><img src="/2020/03/23/基础查找算法整理/04_01.jpg" title="示例图"></code></p><p>二叉搜索树的查找时间复杂度受树的深度影响，平均时间复杂度为O(logN)</p><hr><p>1&gt;二叉搜索树查找最大值：从根节点一直往右走，直到无路可走，遍可访问到最大值节点。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchMax</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> SearchMax(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>2&gt;二叉搜索树查找最小值：从根节点一直往左走，直到无路可走，遍可以访问到最小值节点。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchMin</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(rooy-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> SearchMin(root-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3&gt;二叉搜索数进行一般查找</p><p>①递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchValue</span><span class="params">(TreeNode* root,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val==target)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; target)</span><br><span class="line">        <span class="keyword">return</span> SearchValue(root-&gt;left,target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; target)</span><br><span class="line">        <span class="keyword">return</span> SearchValue(root-&gt;right,target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②非递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchValue</span><span class="params">(TreeNode* root,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode* ptr=root;</span><br><span class="line">    <span class="keyword">while</span>(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;val==target)</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        </span><br><span class="line">        ptr=(root-&gt;val &gt; target)?ptr-&gt;left:ptr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="05-红黑树"><a href="#05-红黑树" class="headerlink" title="#05.红黑树"></a><strong>#05.红黑树</strong></h2><hr><p><a href="https://www.jianshu.com/p/104fa73c81b3" target="_blank" rel="noopener">https://www.jianshu.com/p/104fa73c81b3</a></p><p><a href="https://blog.csdn.net/hackbuteer1/article/details/7740956" target="_blank" rel="noopener">https://blog.csdn.net/hackbuteer1/article/details/7740956</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5种基础的查找算法&quot;&gt;&lt;a href=&quot;#5种基础的查找算法&quot; class=&quot;headerlink&quot; title=&quot;5种基础的查找算法&quot;&gt;&lt;/a&gt;&lt;strong&gt;5种基础的查找算法&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;本文对7种基础的查找算法做了整理，包括顺
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://hustxxj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://hustxxj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——27.字符串的排列（67-136-f40）</title>
    <link href="http://hustxxj.github.io/2020/03/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9427.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9427.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2020-03-20T07:10:48.000Z</published>
    <updated>2020-03-23T13:50:53.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>a,b,c全排列得出的所有字符串，可以看做：</p><ol><li><p>以a开头，（b,c）全排列得出的字符串</p></li><li><p>以b开头，（a,c）全排列得出的字符串</p></li><li><p>以c开头，（a,b）全排列得出的字符串</p></li></ol><p>   <em>定义Permutation1（string str,int begin,vector<string>result）：</string></em></p><p>   表示从str的第begin个字符开始，计算str的全排列，将结果放入result中。</p><p>   显然，当begin==str.size()-1的时候，全排列只存在一种，就是当下的str，所以将str放入result中。</p><p>   而当begin!=str.size()时：</p><p>   ​       ①交换a和a的顺序，计算（b，c）的全排列</p><p>   ​       ②交换a和b的顺序，计算（a，c）的全排列</p><p>   ​       ③交换a和c的顺序，计算（b，a）的全排列</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(str.empty()) <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">        Permutation1(str,result,<span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 此时得到的result中排列并不是字典顺序，可以单独再排下序</span></span><br><span class="line">        sort(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Permutation1</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result,<span class="keyword">int</span> <span class="built_in">begin</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == str.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="comment">// 递归结束条件：索引已经指向str最后一个元素时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>(),str) == result.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果result中不存在str，才添加；避免aa和aa重复添加的情况</span></span><br><span class="line">                result.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一次循环i与begin相等，相当于第一个位置自身交换，关键在于之后的循环，</span></span><br><span class="line">            <span class="comment">// 之后i != begin，则会交换两个不同位置上的字符，直到begin==str.size()-1，进行输出；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">begin</span>;i&lt;str.<span class="built_in">size</span>();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(str[i],str[<span class="built_in">begin</span>]);</span><br><span class="line">                Permutation1(str,result,<span class="built_in">begin</span>+<span class="number">1</span>);</span><br><span class="line">                swap(str[i],str[<span class="built_in">begin</span>]); <span class="comment">// 复位，用以恢复之前字符串顺序，达到第一位依次跟其他位交换的目的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> &amp;fir,<span class="keyword">char</span> &amp;sec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = fir;</span><br><span class="line">        fir = sec;</span><br><span class="line">        sec = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：面试题40-最小的K个数"><a href="#LeetCode练习（数组）：面试题40-最小的K个数" class="headerlink" title="LeetCode练习（数组）：面试题40.最小的K个数"></a><strong>LeetCode练习（数组）：</strong>面试题40.最小的K个数</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：67-二进制求和"><a href="#LeetCode练习（字符串）：67-二进制求和" class="headerlink" title="LeetCode练习（字符串）：67.二进制求和"></a><strong>LeetCode练习（字符串）：67.二进制求和</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/20/剑指Offer——27.字符串的排列/27_67.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> max_len=(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())?b.<span class="built_in">size</span>():a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=b.<span class="built_in">size</span>();i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            b=temp+b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a.<span class="built_in">size</span>();i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            a=temp+a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isadd=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'0'</span> &amp;&amp; b[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                isadd=<span class="literal">false</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'0'</span> &amp;&amp; b[i]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">false</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'1'</span> &amp;&amp; b[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">false</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'1'</span> &amp;&amp; b[i]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isadd==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：136-只出现一次的数字"><a href="#LeetCode练习（数组）：136-只出现一次的数字" class="headerlink" title="LeetCode练习（数组）：136.只出现一次的数字"></a><strong>LeetCode练习（数组）：136.只出现一次的数字</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/20/剑指Offer——27.字符串的排列/27_136.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                out = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]==nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                out = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>基础排序算法整理</title>
    <link href="http://hustxxj.github.io/2020/03/19/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://hustxxj.github.io/2020/03/19/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-03-19T01:46:35.000Z</published>
    <updated>2020-03-23T08:09:47.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9种基础的排序算法"><a href="#9种基础的排序算法" class="headerlink" title="9种基础的排序算法"></a><strong>9种基础的排序算法</strong></h1><hr><p>撰写本文意在帮助自己复习巩固基础的10大排序算法，分析每种排序算法的原理及实现思路。同时对各个排序算法的时间复杂度，空间复杂度以及稳定性进行了总结。</p><hr><h2 id="01-冒泡排序"><a href="#01-冒泡排序" class="headerlink" title="#01.冒泡排序"></a><strong>#01.冒泡排序</strong></h2><hr><p>冒泡排序的基本思想就是对数值进行两两比较，如果出现反序，则交换两个数值的位置。一直到序列中没有反序为止。<br>实现过程：（以将数据从小到大排序为目标）</p><ol><li>从数组起始点开始，比较相邻的两个数据，如果后一个数据<em>小于</em>前一个数据，则交换两个数据的位置。</li><li>继续以上步骤，知道遍历完数组元素。完成第一次遍历。</li><li>从数组的第二个元素开始，再次两两比较，如果后一个数据<em>小于</em>前一个数据，则交换两个数据的位置。</li><li>重复上述步骤直到数组完全有序。</li></ol><hr><p>实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//冒泡排序(从小到大)</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每比较完一轮，就会将最大值放到数组的尾部，所以剩余需要比较的数为len-1-i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&gt;ex[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=ex[j];</span><br><span class="line">                ex[j]=ex[j+<span class="number">1</span>];</span><br><span class="line">                ex[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>时间复杂度：</p><ol><li>按照上述基本方法进行冒泡排序，需要进行n次循环，第一循环需要进行n-1次比较，第二次循环需要进行n-2次比较，以此类推… （1+2+3+…+n-1）=n(n-1)/2，所以最好最坏的时间复杂度都是O(n2)；</li><li>如果对上述方法进行优化，<em>最好情况下</em>，时间复杂度为O(n)。</li></ol><p>空间复杂度：</p><ol><li>由于完成排序没有利用新的内存空间，所以空间复杂度是O(1)。</li></ol><p>稳定性：</p><ol><li>排序后没有影响数据的位置关系，是稳定的。</li></ol><hr><h2 id="02-选择排序"><a href="#02-选择排序" class="headerlink" title="#02.选择排序"></a><strong>#02.选择排序</strong></h2><hr><p>选择排序的基本思想是（从小到大排序）：</p><ol><li>第一次遍历n-1个数，找出最小的元素与第1个数进行位置交换</li><li>第二次遍历n-2个数，找出最小值与第2个数进行位置交换。<br>…</li><li>第n-1次遍历，找到最小元素与第n-1个元素进行交换<br>排序完成</li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//得出第i轮遍历找到的最小值</span></span><br><span class="line">        <span class="keyword">int</span> min_value=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&lt;ex[min_value])</span><br><span class="line">            &#123;</span><br><span class="line">                min_value=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换位置</span></span><br><span class="line">        <span class="keyword">int</span> temp=ex[i];</span><br><span class="line">        ex[i]=ex[min_value];</span><br><span class="line">        ex[min_value]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>第一遍排序，需要进行n-1次比较；第二遍排序，需要进行n-2次比较；…第n-2轮排序，需要进行1次比较。<br>1+2+3+…+n-1=n(n-1)/2，所以时间复杂度为O(n2)</li></ol><p>空间复杂度：</p><ol><li>没有开辟新的内存空间，所以O(1)</li></ol><p>稳定性：</p><ol><li>不是稳定的。两个相等的元素，在排序前后相对位置有可能发生变化</li></ol><hr><h2 id="03-插入排序"><a href="#03-插入排序" class="headerlink" title="#03.插入排序"></a><strong>#03.插入排序</strong></h2><hr><p>插入排序的基本思路是：</p><ol><li>对于一个数组，假定前n-1个数据是已经排序好的。</li><li>现在将第n个元素插入到前面已序的n-1个数据中，使得这n个数据已序。</li><li>令n=1，2，… ，反复循环直到全部排序好。</li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&lt;ex[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=ex[j];</span><br><span class="line">                ex[j]=ex[j<span class="number">-1</span>];</span><br><span class="line">                ex[j<span class="number">-1</span>]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复制度：</p><ol><li>最好的情况，如果数组已经是一个已序数组，那么只需要经过n次比较就可以得出结果，时间复杂度为O(n)。</li><li>最坏的情况，如果数组是一个逆序数组，那么需要比较1+2+3+…+n-1=n(n-1)/2次，时间复杂度为O(n2)。</li></ol><p>空间复杂度：</p><ol><li>没有利用新的空间，空间复杂度为O(1)。</li></ol><p>算法稳定性：</p><ol><li>相等数据在排序前后，相对位置没有发生变化，所以是稳定的。</li></ol><hr><h2 id="04-快速排序"><a href="#04-快速排序" class="headerlink" title="#04.快速排序"></a><strong>#04.快速排序</strong></h2><hr><p>快速排序的基本思想是利用分治法：</p><ol><li><p>选基准数。先从数列中取出一个数作为基准数</p></li><li><p>分区过程。将比基准数大的数全部放到它的右边，比基准数小的数全部放到它的左边。</p></li><li><p>迭代。对左右分区再进行上述操作。</p><p><em>具体代码实现思路（挖坑填数）：</em></p><ol><li>取i=L（区间左边界），j=R（区间右边界）。将基准数BASE设为a[i]，作为第一个坑。</li><li>j–从右向左搜寻，找到小于BASE的数则挖出这个数，填入坑a[i]中。</li><li>i++从左往右搜寻，找到大于BASE的数则挖出这个数，填入前一步挖出的坑a[j]中。</li><li>重复执行2,3步直到i==j，然后将BASE放入a[i]中。</li></ol></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fast_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=right;</span><br><span class="line">        <span class="keyword">int</span> BASE=a[i];</span><br><span class="line">        <span class="keyword">while</span>(i!=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;i;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;BASE)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i]=a[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;j;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;BASE)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[j]=a[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i]=BASE;</span><br><span class="line"></span><br><span class="line">        Fast_sort(a,left,i<span class="number">-1</span>);</span><br><span class="line">        Fast_sort(a,i+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    Fast_sort(ex,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li><p>如果数组本身已经是一个有序的数组，最好情况下时间复杂度为O(n*logn)。</p></li><li><p>如果数组是个逆序数组，那么此时时间复杂度最高，为O(n^2)。</p></li></ol><p>   空间复杂度：</p><ol><li>没有利用新的空间，空间复杂度O(1)。</li></ol><pre><code>算法稳定性：1. 不稳定</code></pre><hr><h2 id="05-堆排序"><a href="#05-堆排序" class="headerlink" title="#05.堆排序"></a><strong>#05.堆排序</strong></h2><hr><p>堆排序的基本原理：</p><ol><li><p>将一个无序序列构建成一个堆，如果需要序后的数组为升序排列则构建成大顶堆，如果序后数组为降序排列则构建成小顶堆。</p><p>（以升序排列为例）</p></li><li><p>将堆顶元素与末尾元素交换，将最大元素下沉到数组末端。</p></li><li><p>重新调整结构，使其满足大顶堆的定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换，知道整个序列有序。</p></li></ol><p>   <em>原理说明可以参考下面的博客：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></em></p><p>   <em>代码实现参考下面博客：<a href="https://www.cnblogs.com/skywang12345/p/3602162.html#a42" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3602162.html#a42</a></em></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxtopheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> sta,<span class="keyword">int</span> en)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current=sta;             <span class="comment">//当前节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> left=sta*<span class="number">2</span>+<span class="number">1</span>;            <span class="comment">//当前节点左子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> value=a[current];        <span class="comment">//当前节点的值</span></span><br><span class="line">    <span class="keyword">for</span>(;left&lt;en;current=left,left=left*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[left]&lt;a[left+<span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;=a[left])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[current]=a[left];</span><br><span class="line">            a[left]=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_ASCSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将数组a构成大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(length/<span class="number">2</span>)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        maxtopheap(a,i,length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换+继续重组成大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];</span><br><span class="line">        a[i]=a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>]=temp;</span><br><span class="line">        maxtopheap(a,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序(从小到大)</span></span><br><span class="line">    Heap_ASCSort(ex,len);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>堆排序最优情况下，最差情况下以及平均时间复杂度都为O(n*logn)</li></ol><p>   空间复杂度:</p><ol><li>只涉及元素直接的调换，空间复杂度为O(1)</li></ol><pre><code>算法稳定性：1. 不稳定</code></pre><hr><h2 id="06-归并排序"><a href="#06-归并排序" class="headerlink" title="#06.归并排序"></a><strong>#06.归并排序</strong></h2><hr><p>归并排序的基本原理：</p><p><em>归并排序时基于两组已序的数组进行合并，时间复杂度为O(n)这一事实实现的</em></p><ol><li><p>将数据分为A，B两组，如果这A，B分别都是已序数组，那么就可以很方便的将两组数据合并成一个有序数组。</p></li><li><p>如何实现A，B数组的已序？就是再对A，B进行划分，直到每个小组只有1个元素，那么就可以任务这个小组组内有序了。</p></li><li><p>然后再逐层合并实现整体的已序。</p><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/6_1.jpg" title="示例图"></code></p></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; before,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; after)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(before[i]&lt;before[j])</span><br><span class="line">        &#123;</span><br><span class="line">            after[k++]=before[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            after[k++]=before[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">        after[k++]=before[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        after[k++]=before[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并以后还需要反向赋值回原数组，以便留给后续迭代使用</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        before[left + i] = after[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; before,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; after)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        Merge_sort(before,left,mid,after);          <span class="comment">//左边归并排序</span></span><br><span class="line">        Merge_sort(before,mid+<span class="number">1</span>,right,after);       <span class="comment">//右边归并排序</span></span><br><span class="line">        MergeArray(before,left,mid,right,after);    <span class="comment">//合并左右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; af(<span class="number">20</span>);</span><br><span class="line">    Merge_sort(ex,<span class="number">0</span>,len<span class="number">-1</span>,af);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>任何情况下归并排序的时间复杂度为O(n*logn)。假设数量长为n，将数列分开成小数列一共要logn步，每一步都是一个合并有序数列的过程，合并有序数列时间复杂度为O(n)。</li></ol><p>   空间复杂度：</p><ol><li>空间复杂度为O(n)，因为借用了一个数组af[]用于暂存已序的数组。</li></ol><pre><code>稳定性：1. 稳定</code></pre><hr><h2 id="07-希尔排序"><a href="#07-希尔排序" class="headerlink" title="#07.希尔排序"></a><strong>#07.希尔排序</strong></h2><hr><p>希尔排序的基本原理：</p><p>希尔排序可以理解为是堆插入排序的改进，改进的思路是：把数组按<em>下标的增量进行分组</em>，对每组使用直接插入排序；随着增量的逐渐减少，每组包含的元素越来越多，<em>当增量减至1时</em>，整个数组正好为一组，算法终止。</p><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/7_1.jpg" title="示例图"></code></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> distance=len;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        distance=distance/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;distance;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=k+distance;i&lt;len;i+=distance)   <span class="comment">//i+=distance需要注意</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;k;j-=distance)    <span class="comment">//j&gt;k这个也需要注意</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ex[j]&lt;ex[j-distance])</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=ex[j];</span><br><span class="line">                        ex[j]=ex[j-distance];</span><br><span class="line">                        ex[j-distance]=temp;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(distance==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>希尔排序的时间复杂度取决于增量选取，最坏情况下希尔排序的时间复杂度会到O(n2)，平均时间复杂度为O(n*logn2)。</li></ol><p>   空间复杂度：</p><ol><li>与插入排序一样都是O(1)。</li></ol><pre><code>算法稳定性：1.  尽管插入排序是稳定的，但是由于希尔排序涉及到分组，相同的元素被分到不同的组中然后各自进行插入排序有可能会改变它们之间的位置关系，所以希尔排序时不稳定的。</code></pre><hr><h2 id="08-计数排序"><a href="#08-计数排序" class="headerlink" title="#08.计数排序"></a><strong>#08.计数排序</strong></h2><hr><p>计数排序的基本原理：</p><p><em>计数排序是一种非比较的排序，它适用于<strong>一定范围</strong>的整数排序。在取值范围不是很大的情况下，它的性能甚至会快过O(nlogn)的排序方法</em></p><p>计数排序的算法步骤：</p><ol><li><p>找出待排序数组的最大值和最小值。</p></li><li><p>构建一个数组C，统计原数组中每个元素i出现的次数k，将k存入数组C的第i项中。</p></li><li><p>对C中的所有计数累加。</p></li><li><p>反向填充原数组。</p></li></ol><p>   <em>原理参考图：</em></p><p>   <code><img src="/2020/03/19/基础排序算法整理/8_1.jpg" title="示例图"></code></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//计数排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> v_min=ex[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> v_max=ex[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ex[i]&gt;v_max)</span><br><span class="line">        &#123;</span><br><span class="line">            v_max=ex[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ex[i]&lt;v_min)</span><br><span class="line">        &#123;</span><br><span class="line">            v_min=ex[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> range=v_max-v_min+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countArray(range,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArray[ex[j]-v_min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ptr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;range;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;countArray[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ex[ptr++]=i+v_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li><p>计数排序的时间复杂度受到数组中最大值和最小值的差值影响。</p></li><li><p>设max-min=m，则时间复杂度为O(m+n)</p></li></ol><p>   空间复杂度:</p><ol><li>空间复杂度同样取决于数组最大和最小值得差值，设max-min=m，则空间复杂度为O(m)。</li></ol><pre><code>算法稳定性：1. 稳定</code></pre><hr><h2 id="09-基数排序"><a href="#09-基数排序" class="headerlink" title="#09. 基数排序"></a><strong>#09. 基数排序</strong></h2><hr><p>基数排序的原理：</p><ol><li>将整数按位数切割成不同的数字，然后按每个位数分别比较。</li></ol><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/9_1.gif" title="示例图"></code></p><p><code><img src="/2020/03/19/基础排序算法整理/9_2.jpg" title="示例图"></code></p><p><em>ex：基数排序还有前面的计数排序都可以看做是桶排序的特殊形式，三者的差异在于：</em></p><p><em>1.基数排序：根据元素的每<strong>位</strong>数字来分配桶。</em></p><p><em>2.计数排序：每个桶只存在单一元素。</em></p><p><em>3.桶排序：每个桶凑存储一定范围的元素。</em></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span>;             <span class="comment">//指数，用来区分每次排序是按哪一位，exp=1表示按个位排序，ex=10表示按十位排序...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> v_max=vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]&gt;v_max)</span><br><span class="line">        &#123;</span><br><span class="line">            v_max=vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从个位开始，对数组进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">exp</span>=<span class="number">1</span>;v_max/<span class="built_in">exp</span>&gt;<span class="number">0</span>;<span class="built_in">exp</span>*=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> buckets[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(length,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i]+=buckets[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]<span class="number">-1</span>]=vec[i];</span><br><span class="line">            buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    radix_sort(ex,len);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>基数排序的时间复杂度取决于数组中最大数有多少位，设最大数有k位，则时间复杂度为O(kn)</li></ol><p>   空间复杂度：</p><ol><li>这里开辟了一个包含10个整型的数组，空间复杂度为O(1)</li></ol><pre><code>算法稳定性：1. 稳定</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9种基础的排序算法&quot;&gt;&lt;a href=&quot;#9种基础的排序算法&quot; class=&quot;headerlink&quot; title=&quot;9种基础的排序算法&quot;&gt;&lt;/a&gt;&lt;strong&gt;9种基础的排序算法&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;撰写本文意在帮助自己复习巩固基础的10大
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://hustxxj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://hustxxj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——26.二叉搜索树和双向链表（23-33-836）</title>
    <link href="http://hustxxj.github.io/2020/03/18/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9426.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/03/18/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9426.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-18T04:48:28.000Z</published>
    <updated>2020-03-23T13:50:27.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>思路与迭代法实现二叉树的中序遍历类似，可以参考剑指Offer——04.二叉树的重建</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRootOfTree==nullptr)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; sta;</span><br><span class="line">        TreeNode* ptr=pRootOfTree;</span><br><span class="line">        TreeNode* res=new TreeNode(-1);</span><br><span class="line">        TreeNode* res_ptr=res;</span><br><span class="line">        bool isFirst=true;</span><br><span class="line">        while(ptr!=nullptr || !sta.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr!=nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            res_ptr-&gt;right=ptr;</span><br><span class="line">            if(isFirst==false)</span><br><span class="line">              ptr-&gt;left=res_ptr;</span><br><span class="line">            res_ptr=ptr;</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">            isFirst=false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：836-矩阵重叠"><a href="#LeetCode练习（数组）：836-矩阵重叠" class="headerlink" title="LeetCode练习（数组）：836.矩阵重叠"></a><strong>LeetCode练习（数组）：836.矩阵重叠</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_836.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123;</span><br><span class="line">        bool res=false;</span><br><span class="line">        </span><br><span class="line">        if(rec2[0]&lt;rec1[2] &amp;&amp; rec2[1]&lt;rec1[3] &amp;&amp; rec2[2]&gt;rec1[0] &amp;&amp; rec2[3]&gt;rec1[1])</span><br><span class="line">           res=true;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：23-合并K个排序链表"><a href="#LeetCode练习（链表）：23-合并K个排序链表" class="headerlink" title="LeetCode练习（链表）：23.合并K个排序链表"></a><strong>LeetCode练习（链表）：23.合并K个排序链表</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_23.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        int len=lists.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return nullptr;</span><br><span class="line">        if(len==1)</span><br><span class="line">           return lists[0];</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* ptr=lists[i];</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                vec.push_back(ptr-&gt;val);</span><br><span class="line">                ptr=ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(vec.begin(),vec.end());</span><br><span class="line">        ListNode* res=new ListNode(-1);</span><br><span class="line">        ListNode* res_ptr=res;</span><br><span class="line">        for(int i=0;i&lt;vec.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tempnode=new ListNode(vec[i]);</span><br><span class="line">            res_ptr-&gt;next=tempnode;</span><br><span class="line">            res_ptr=tempnode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：33-搜索旋转排序数组"><a href="#LeetCode练习（数组）：33-搜索旋转排序数组" class="headerlink" title="LeetCode练习（数组）：33.搜索旋转排序数组"></a><strong>LeetCode练习（数组）：33.搜索旋转排序数组</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_33.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) </span><br><span class="line">    &#123;</span><br><span class="line">        int low=0,high=nums.size()-1;</span><br><span class="line">        </span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=low+(high-low)/2;</span><br><span class="line">            if(target==nums[mid]) return mid;</span><br><span class="line"></span><br><span class="line">            if(nums[low]&lt;=nums[mid])  /////左区间有序</span><br><span class="line">            &#123;</span><br><span class="line">                if(target&gt;=nums[low]&amp;&amp;target&lt;nums[mid])   ////target在左区间</span><br><span class="line">                    high=mid-1;</span><br><span class="line">                else low=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else                     ///右区间有序</span><br><span class="line">            &#123;</span><br><span class="line">                if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[high])    ////target在右区间</span><br><span class="line">                    low=mid+1;</span><br><span class="line">                else high=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——25.复制链表的复制（46-62-1160）</title>
    <link href="http://hustxxj.github.io/2020/03/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9425.%E5%A4%8D%E5%88%B6%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>http://hustxxj.github.io/2020/03/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9425.%E5%A4%8D%E5%88%B6%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
    <published>2020-03-17T12:58:55.000Z</published>
    <updated>2020-03-18T04:45:18.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><ol><li>在每个节点后面复制一个和当前节点一模一样的节点（节点值，下一节点地址，随机节点地址都一样）</li><li>将复制的节点拿出来单独组成一个链表</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    struct RandomListNode *next, *random;</span><br><span class="line">    RandomListNode(int x) :</span><br><span class="line">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        </span><br><span class="line">        clo(pHead);</span><br><span class="line">        setrandomptr(pHead);</span><br><span class="line">        return depart(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void clo(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode* ptr=head;</span><br><span class="line">        while(ptr!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* cloneNode=new RandomListNode(ptr-&gt;label);</span><br><span class="line">            cloneNode-&gt;next=ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next=cloneNode;</span><br><span class="line">            ptr=cloneNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void setrandomptr(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode *pNode = head;</span><br><span class="line">     </span><br><span class="line">        while (pNode != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode *pClone = pNode-&gt;next;</span><br><span class="line">            if (pNode-&gt;random)</span><br><span class="line">            &#123;</span><br><span class="line">                pClone-&gt;random = pNode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pClone-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RandomListNode* depart(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode* ptr=head;</span><br><span class="line">        RandomListNode* res=head-&gt;next;</span><br><span class="line">        while(ptr!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* ptr_res=ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next=ptr_res-&gt;next;</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">            if(ptr!=nullptr)</span><br><span class="line">              ptr_res-&gt;next=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（哈希表）：1160-拼写单词"><a href="#LeetCode练习（哈希表）：1160-拼写单词" class="headerlink" title="LeetCode练习（哈希表）：1160.拼写单词"></a><strong>LeetCode练习（哈希表）：1160.拼写单词</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/17/剑指Offer——25.复制链表的复制/25_1160.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123;</span><br><span class="line">        if(words.size()==0 || chars.size()==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        map&lt;char,int&gt; mp;</span><br><span class="line">        for(int i=0;i&lt;chars.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[chars[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;words.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(words[i].size() &gt; chars.size())</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(words[i].begin(),words[i].end());</span><br><span class="line">            int target=0,count=0;</span><br><span class="line">            bool isRight=true;</span><br><span class="line">            for(int j=0;j&lt;words[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[words[i][j]]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    isRight=false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(words[i][j]==words[i][target])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(count&gt;mp[words[i][target]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        isRight=false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        target=j;</span><br><span class="line">                        count=1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&gt;mp[words[i][target]])</span><br><span class="line">            &#123;</span><br><span class="line">                isRight=false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isRight==true)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=words[i].size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：46-全排列"><a href="#LeetCode练习（数组）：46-全排列" class="headerlink" title="LeetCode练习（数组）：46.全排列"></a><strong>LeetCode练习（数组）：46.全排列</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        do&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;while(next_permutation(nums.begin(),nums.end()));</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：62-不同路径"><a href="#LeetCode练习（动态规划）：62-不同路径" class="headerlink" title="LeetCode练习（动态规划）：62.不同路径"></a><strong>LeetCode练习（动态规划）：62.不同路径</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/17/剑指Offer——25.复制链表的复制/25_62.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if(m&lt;=1 || n&lt;=1)</span><br><span class="line">           return 1;</span><br><span class="line">        int dp[n][m]=&#123;0&#125;;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[0][i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][0]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][m-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——24.二叉树中和为某一值得路径（22-695-f01.06）</title>
    <link href="http://hustxxj.github.io/2020/03/16/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9424.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E5%BE%97%E8%B7%AF%E5%BE%84/"/>
    <id>http://hustxxj.github.io/2020/03/16/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9424.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E5%BE%97%E8%B7%AF%E5%BE%84/</id>
    <published>2020-03-16T04:10:32.000Z</published>
    <updated>2020-03-18T04:45:48.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用递归实现：</p><ol><li>如果当前节点是叶子节点，且节点值等于目标值，则将该子数组放入最后的结果中</li><li>如果当前节点值小于目标值，但是还存在子节点，则迭代，目标值相应递减。</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;val == expectNumber &amp;&amp; root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        if(root-&gt;val &lt; expectNumber &amp;&amp; root-&gt;left!=nullptr)</span><br><span class="line">            FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        if(root-&gt;val &lt; expectNumber &amp;&amp; root-&gt;right!=nullptr)</span><br><span class="line">            FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-深度优先遍历）：695-岛屿的最大面积"><a href="#LeetCode练习（数组-深度优先遍历）：695-岛屿的最大面积" class="headerlink" title="LeetCode练习（数组/深度优先遍历）：695.岛屿的最大面积"></a><strong>LeetCode练习（数组/深度优先遍历）：695.岛屿的最大面积</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_695.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路： 遍历数组，每当发现一个1，就从该元素出发搜索周围四个方向是否存在1，将该元素以及周围为1的元素都置0，顺便计数一共置0了多少个1（代表岛屿的面积）。遍历完后返回最大岛屿面积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int area;</span><br><span class="line">public:</span><br><span class="line">    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int rows=grid.size();</span><br><span class="line">        if(rows==0)</span><br><span class="line">           return 0;</span><br><span class="line">        int cols=grid[0].size();</span><br><span class="line">        if(cols==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;rows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;cols;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    area=0;</span><br><span class="line">                    find_1(grid,i,j);</span><br><span class="line">                    res=(area&gt;res)?area:res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void find_1(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int i,int j)</span><br><span class="line">    &#123;</span><br><span class="line">        if(grid[i][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j]=0;</span><br><span class="line">            area++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i-1&gt;=0 &amp;&amp; grid[i-1][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i-1,j);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i+1&lt;grid.size() &amp;&amp; grid[i+1][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i+1,j);</span><br><span class="line">        &#125;</span><br><span class="line">        if(j-1&gt;=0 &amp;&amp; grid[i][j-1]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i,j-1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(j+1&lt;grid[0].size() &amp;&amp; grid[i][j+1]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i,j+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（字符串）：面试题01-06-字符串压缩"><a href="#LeetCode练习（字符串）：面试题01-06-字符串压缩" class="headerlink" title="LeetCode练习（字符串）：面试题01.06.字符串压缩"></a><strong>LeetCode练习（字符串）：面试题01.06.字符串压缩</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_f0106.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>数字转字符串 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss&lt;&lt;a;</span><br><span class="line">string str=ss.str();</span><br><span class="line">或</span><br><span class="line">int a=10;</span><br><span class="line">string str=to_string(a);</span><br></pre></td></tr></table></figure></p><p>字符串转数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int stoi(const strings str, size_t* pos = 0/*返回第一个无法转换的字符位置*/, int base = 10/*表示按10进制转换为整数*/)</span><br><span class="line">long stol(const strings str, size_t* pos = 0, int base = 10)</span><br><span class="line">float stof(const strings str, size_t* pos = 0)</span><br><span class="line">double stod(const strings str, size_t* pos = 0)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string compressString(string S) &#123;</span><br><span class="line">        int len=S.size();</span><br><span class="line">        if(len&lt;=1)</span><br><span class="line">          return S;</span><br><span class="line">        </span><br><span class="line">        int target=0;</span><br><span class="line">        int count=0;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(S[i]==S[target])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(S[target]);</span><br><span class="line">                res+=to_string(count);</span><br><span class="line">                target=i;</span><br><span class="line">                count=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(S[target]);</span><br><span class="line">        res+=to_string(count);</span><br><span class="line"></span><br><span class="line">        res=(res.size()&gt;=len)?S:res;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯算法）：22-括号生成"><a href="#LeetCode练习（回溯算法）：22-括号生成" class="headerlink" title="LeetCode练习（回溯算法）：22.括号生成"></a><strong>LeetCode练习（回溯算法）：22.括号生成</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_22.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><ol><li>在str中放入n个”()”</li><li>利用next_permutation对str进行全排列，然后检查每个排列是否合法（调用next_permutation之前先要对str进行sort排序，否则会出错）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if(n==0)</span><br><span class="line">           return res;</span><br><span class="line">        if(n==1)</span><br><span class="line">        &#123;</span><br><span class="line">            string ss=&quot;()&quot;;</span><br><span class="line">            res.push_back(ss);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ss=&quot;&quot;;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ss+=&quot;()&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ss.begin(),ss.end());</span><br><span class="line"></span><br><span class="line">        do&#123;</span><br><span class="line">            if(IsLegal(ss))</span><br><span class="line">               res.push_back(ss);</span><br><span class="line">        &#125;while(next_permutation(ss.begin(),ss.end()));</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool IsLegal(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        int len=str.size();</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==&apos;(&apos;)</span><br><span class="line">               count++;</span><br><span class="line">            else</span><br><span class="line">               count--;</span><br><span class="line">            </span><br><span class="line">            if(count&lt;0)</span><br><span class="line">               return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——23.二叉搜索树的后序遍历序列（6-34-300）</title>
    <link href="http://hustxxj.github.io/2020/03/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9423.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9423.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-14T11:43:59.000Z</published>
    <updated>2020-03-14T14:46:46.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><pre><code>采用自顶向下的方式进行运算如果vector是二叉搜索树的后续遍历序列，那么vector{a1,....,a2,b1,.....,b2,c1}一定满足a1~a2小于c1,b1~b2大于c1如果以上条件满足，那么再将a1~a2,b1~b2分别作为输入验证他们是否满足</code></pre><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool isFirstIn=true;</span><br><span class="line">public:</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">        int len=sequence.size();</span><br><span class="line">        if(len==0 &amp;&amp; isFirstIn==true)</span><br><span class="line">            return false;</span><br><span class="line">        if(len &lt;=2)</span><br><span class="line">            return true;</span><br><span class="line">        isFirstIn=false;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; left,right;</span><br><span class="line">        int root=sequence[len-1];</span><br><span class="line">        int ptr;</span><br><span class="line">        for(int i=0;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sequence[i] &lt; root)</span><br><span class="line">                left.push_back(sequence[i]);</span><br><span class="line">            if(sequence[i] &gt; root)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==len-2)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=i+1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=ptr;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sequence[i]&gt;root)</span><br><span class="line">                right.push_back(sequence[i]);</span><br><span class="line">            if(sequence[i]&lt;root)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return VerifySquenceOfBST(left) &amp;&amp; VerifySquenceOfBST(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：300-最长的上升子序列"><a href="#LeetCode练习（动态规划）：300-最长的上升子序列" class="headerlink" title="LeetCode练习（动态规划）：300.最长的上升子序列"></a><strong>LeetCode练习（动态规划）：300.最长的上升子序列</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_300.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>状态转移方程：设dp[n]表示从第n个数字往左，最长上升子序列的长度            则，dp[n]=max(dp[j])+1; 0&lt;=j&lt;n;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return len;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; dp(len,0);</span><br><span class="line">        for(int j=0;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=1;</span><br><span class="line">            for(int i=0;i&lt;j;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i] &lt; nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j]=max(dp[j],dp[i]+1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：6-Z字形变换"><a href="#LeetCode练习（字符串）：6-Z字形变换" class="headerlink" title="LeetCode练习（字符串）：6.Z字形变换"></a><strong>LeetCode练习（字符串）：6.Z字形变换</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_6.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convert(string s, int numRows) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        if(s==&quot;&quot; || numRows==0)</span><br><span class="line">           return res;</span><br><span class="line">        </span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len &lt;=numRows || numRows==1)</span><br><span class="line">           return s;</span><br><span class="line">        vector&lt;string&gt; ss(numRows);</span><br><span class="line">        bool isDown=true;</span><br><span class="line">        int stairs=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isDown==true)</span><br><span class="line">            &#123;</span><br><span class="line">                ss[stairs].push_back(s[i]);</span><br><span class="line">                stairs++;</span><br><span class="line">                if(stairs==numRows)</span><br><span class="line">                &#123;</span><br><span class="line">                    isDown=false;</span><br><span class="line">                    stairs-=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ss[stairs].push_back(s[i]);</span><br><span class="line">                stairs--;</span><br><span class="line">                if(stairs&lt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    isDown=true;</span><br><span class="line">                    stairs+=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=ss[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode练习（数组）：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode练习（数组）：34. 在排序数组中查找元素的第一个和最后一个位置"></a><strong>LeetCode练习（数组）：34. 在排序数组中查找元素的第一个和最后一个位置</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_6.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;int&gt;::iterator it1=find(nums.begin(),nums.end(),target);</span><br><span class="line">        if(it1==nums.end())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(-1);</span><br><span class="line">            res.push_back(-1);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(it1-nums.begin());</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">        vector&lt;int&gt;::iterator it2=find(nums.begin(),nums.end(),target);</span><br><span class="line">        res.push_back(nums.size()-(it2-nums.begin())-1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Ye
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——22.从上往下打印二叉树（58-169-322）</title>
    <link href="http://hustxxj.github.io/2020/03/13/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9422.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://hustxxj.github.io/2020/03/13/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9422.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-13T08:46:04.000Z</published>
    <updated>2020-03-13T17:54:55.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>简单的利用队列实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt;  res;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left!=nullptr)</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                if(temp-&gt;right!=nullptr)</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：169-多数元素"><a href="#LeetCode练习（数组）：169-多数元素" class="headerlink" title="LeetCode练习（数组）：169.多数元素"></a><strong>LeetCode练习（数组）：169.多数元素</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_169.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        int count=0;int target=nums[0];</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==target)</span><br><span class="line">               count++;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(count &gt; len/2)</span><br><span class="line">                   return target;</span><br><span class="line">                count=1;</span><br><span class="line">                target=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：322-零钱兑换"><a href="#LeetCode练习（动态规划）：322-零钱兑换" class="headerlink" title="LeetCode练习（动态规划）：322.零钱兑换"></a><strong>LeetCode练习（动态规划）：322.零钱兑换</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_322.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>动态规划问题最重要的就是列出状态转移方程设dp[n]表示凑出n块钱，所需要的硬币个数最小值  那么就有dp[n]=min(dp[n-coin]+1)，即需要凑出n-coin块钱需要的硬币个数+1个面额为coin的硬币n=0时,dp[0]=0;n&lt;0时,dp[n]=-1;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        int num=coins.size();</span><br><span class="line">        if(num==0)</span><br><span class="line">           return -1;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(amount+1,amount+1);</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for(int i=0;i&lt;amount+1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;num;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i-coins[j] &lt; 0)</span><br><span class="line">                   continue;</span><br><span class="line">                dp[i]=min(dp[i-coins[j]]+1,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (dp[amount]==amount+1)?-1:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：58-最后一个单词的长度"><a href="#LeetCode练习（数组）：58-最后一个单词的长度" class="headerlink" title="LeetCode练习（数组）：58.最后一个单词的长度"></a><strong>LeetCode练习（数组）：58.最后一个单词的长度</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_58.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=len-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&apos; &apos;)</span><br><span class="line">               continue;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=i;j&gt;=0;j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s[j]==&apos; &apos;)</span><br><span class="line">                      break;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;从上往下打印出二叉树的每个节点，同层节点从左至右打印。&lt;/p&gt;
&lt;hr&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——21.栈的弹入弹出序列（38-283-1071）</title>
    <link href="http://hustxxj.github.io/2020/03/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9421.%E6%A0%88%E7%9A%84%E5%BC%B9%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9421.%E6%A0%88%E7%9A%84%E5%BC%B9%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-12T08:37:14.000Z</published>
    <updated>2020-03-12T11:24:18.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>记录弹出序列中逆序的数量，当逆序数大于等于2时则表示该序列不可能是弹出序列。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        int num=pushV.size();</span><br><span class="line">        if(num==0)</span><br><span class="line">            return true;</span><br><span class="line">        if(num==1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pushV[0]!=popV[0])</span><br><span class="line">                return false;</span><br><span class="line">            else</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int reversetime=0;</span><br><span class="line">        for(int i=0;i&lt;num-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int a=popV[i];</span><br><span class="line">            int b=popV[i+1];</span><br><span class="line">            vector&lt;int&gt;::iterator ptra=find(pushV.begin(),pushV.end(),a);</span><br><span class="line">            vector&lt;int&gt;::iterator ptrb=find(pushV.begin(),pushV.end(),b);</span><br><span class="line">            if(ptra==pushV.end() || ptrb==pushV.end())</span><br><span class="line">                return false;</span><br><span class="line">            if((ptra-pushV.begin())&lt;(ptrb-pushV.begin()))</span><br><span class="line">                reversetime++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(reversetime&gt;=2)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：1071-字符串的最大公因子"><a href="#LeetCode练习（字符串）：1071-字符串的最大公因子" class="headerlink" title="LeetCode练习（字符串）：1071.字符串的最大公因子"></a><strong>LeetCode练习（字符串）：1071.字符串的最大公因子</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_1071.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string gcdOfStrings(string str1, string str2) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        int len1=str1.size();</span><br><span class="line">        int len2=str2.size();</span><br><span class="line">        int M=gcd(len1,len2);           //gcd(x,y)求x，y的最大公约数</span><br><span class="line">        for(int i=0;i&lt;M;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str1[i]==str2[i])</span><br><span class="line">               res.push_back(str1[i]);</span><br><span class="line">            else</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str1[i]!=res[i%M])</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str2[i]!=res[i%M])</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：38-外观数列"><a href="#LeetCode练习（数组）：38-外观数列" class="headerlink" title="LeetCode练习（数组）：38.外观数列"></a><strong>LeetCode练习（数组）：38.外观数列</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_38.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string res=&quot;1&quot;;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=transform(res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string transform(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        string res;</span><br><span class="line">        int len=str.size();</span><br><span class="line">        int ptr=0;</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==str[ptr])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count+&apos;0&apos;);</span><br><span class="line">                res.push_back(str[ptr]);</span><br><span class="line">                ptr=i;</span><br><span class="line">                count=0;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(count+&apos;0&apos;);</span><br><span class="line">        res.push_back(str[ptr]);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：283-移动零"><a href="#LeetCode练习（数组）：283-移动零" class="headerlink" title="LeetCode练习（数组）：283.移动零"></a><strong>LeetCode练习（数组）：283.移动零</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_283.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">               count++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.push_back(0);</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                i--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——20.包含min函数的栈（17-88-1013）</title>
    <link href="http://hustxxj.github.io/2020/03/11/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9420.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>http://hustxxj.github.io/2020/03/11/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9420.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</id>
    <published>2020-03-11T06:34:41.000Z</published>
    <updated>2020-03-11T12:18:51.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度为o(1)）。注意：测试样例中保证不在栈为空的时候，调用pop()或者min()或者top方法。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>要想在时间复杂度为o(1)的情况下找出栈中最小的元素，那么就需要另外开辟一个栈空间，用来存放最小值。<br>记原始栈为sta1,存放最小值的栈为sta2，存放的规则为：</p><ol><li>sta1正常进行push,pop等操作。</li><li>当sta2为empty时，向sta2中正常push元素；当sta2不为empty时，需要比较当前push的元素与sta2的栈顶元素的大小，只有当前要push的元素小于栈顶元素，才能push入sta2。</li><li>当需要pop时，当sta1弹出的元素为栈中的最小元素时，sta2也要跟着弹出栈顶元素（因为sta1弹出栈中最小元素意味着min值已经改变，所以sta2的栈顶最为记录min的栈，栈顶值也要改变。）<br><em>特别的：需要理解sta2从栈底到栈顶依次记录的是，sta1每次push后栈中的最小元素</em></li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">stack&lt;int&gt; sta1,sta2;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        sta1.push(value);</span><br><span class="line">        if(sta2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sta2.push(value);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(sta2.top() &gt; value)</span><br><span class="line">            &#123;</span><br><span class="line">                sta2.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(sta1.top()==sta2.top())</span><br><span class="line">            sta2.pop();</span><br><span class="line">        sta1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return sta1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return sta2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：1013-将数组分成和相等的三个部分"><a href="#LeetCode练习（数组）：1013-将数组分成和相等的三个部分" class="headerlink" title="LeetCode练习（数组）：1013. 将数组分成和相等的三个部分"></a><strong>LeetCode练习（数组）：1013. 将数组分成和相等的三个部分</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_1013.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li>根据题意：只有将数组分成三等份，且三等份每份的和相等才能返回true，否则返回false。</li><li>将数组分为三等份，需要两个指针实现。</li><li>例如[0,2,1,-6,6,-7,9,1,2,0,1],初始化定义第一个指针指向第一个元素，第二个指针指向最后一个元素</li><li>判断每个区间的和与目标值是否相等，相等则指针不动，不相等则指针移动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int len=A.size();</span><br><span class="line">        if(len&lt;=2)</span><br><span class="line">            return false;</span><br><span class="line">        int sum = accumulate(A.begin(), A.end(), 0);</span><br><span class="line">        int target;</span><br><span class="line">        if(sum%3 != 0)</span><br><span class="line">           return false;</span><br><span class="line">        else</span><br><span class="line">           target=sum/3;</span><br><span class="line"></span><br><span class="line">        int left_ptr=0,right_ptr=len-1;</span><br><span class="line">        int sum_left=A[left_ptr],sum_right=A[right_ptr];</span><br><span class="line">        while(left_ptr+1&lt;right_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum_left==target &amp;&amp; sum_right==target)</span><br><span class="line">               return true;</span><br><span class="line">            if(sum_left!=target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum_left+=A[++left_ptr];</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum_right!=target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum_right+=A[--right_ptr];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：88-合并两个有序数组"><a href="#LeetCode练习（数组）：88-合并两个有序数组" class="headerlink" title="LeetCode练习（数组）：88.合并两个有序数组"></a><strong>LeetCode练习（数组）：88.合并两个有序数组</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_88.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        for(int i=m;i&lt;m+n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i]=nums2[i-m];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1.erase((nums1.begin()+m+n),nums1.end());</span><br><span class="line">        sort(nums1.begin(),nums1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯算法）：17-电话号码的字母组合"><a href="#LeetCode练习（回溯算法）：17-电话号码的字母组合" class="headerlink" title="LeetCode练习（回溯算法）：17.电话号码的字母组合"></a><strong>LeetCode练习（回溯算法）：17.电话号码的字母组合</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_17.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>遍历digits的每个字符，将每个字符下面索引出的所有元素都与res里的每个元素进行相加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        int len=digits.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        res=&#123;&quot;&quot;&#125;;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            if(digits[i]==&apos;2&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;a&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;b&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;c&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;3&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;d&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;e&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;f&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;4&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;g&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;h&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;i&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;5&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;j&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;k&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;l&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;6&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;m&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;n&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;o&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;7&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;p&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;q&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;r&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;s&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;8&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;t&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;u&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;v&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;9&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;w&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;x&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;y&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;z&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——19.顺时针打印矩阵（11-15-543）</title>
    <link href="http://hustxxj.github.io/2020/03/10/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9419.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://hustxxj.github.io/2020/03/10/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9419.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</id>
    <published>2020-03-10T00:05:02.000Z</published>
    <updated>2020-03-10T05:59:21.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4x4矩阵：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16则依次打印出数字1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>从最外圈顺时针逐渐向内圈遍历，利用四个指针限定出最外圈的四个角，遍历完最外圈后将四个角点内移，然后重新遍历。直到左右角重叠或者上下角重叠则退出循环。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(matrix.size()==0 || matrix[0].size()==0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        int left=0,right=matrix[0].size()-1,top=0,bottom=matrix.size()-1;</span><br><span class="line">        while(left&lt;=right &amp;&amp; top&lt;=bottom)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=left;i&lt;=right;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i=top+1;i&lt;=bottom;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            //避免横向重复遍历同一行</span><br><span class="line">            if(top!=bottom)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int i=right-1;i&gt;=left;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //避免纵向重复遍历同一页</span><br><span class="line">            if(left!=right)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int i=bottom-1;i&gt;top;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（二叉树）：543-二叉树的直径"><a href="#LeetCode练习（二叉树）：543-二叉树的直径" class="headerlink" title="LeetCode练习（二叉树）：543.二叉树的直径"></a><strong>LeetCode练习（二叉树）：543.二叉树的直径</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_543.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int max=0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp_node=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp_node-&gt;left!=nullptr)</span><br><span class="line">                   q.push(temp_node-&gt;left);</span><br><span class="line">                if(temp_node-&gt;right!=nullptr)</span><br><span class="line">                   q.push(temp_node-&gt;right);</span><br><span class="line">                int v=depth(temp_node-&gt;left)+depth(temp_node-&gt;right);</span><br><span class="line">                if(v&gt;max)</span><br><span class="line">                   max=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int depth(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)</span><br><span class="line">            return 1;</span><br><span class="line">        </span><br><span class="line">        int depth_l=depth(root-&gt;left)+1;</span><br><span class="line">        int depth_r=depth(root-&gt;right)+1;</span><br><span class="line"></span><br><span class="line">        return max(depth_l,depth_r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-双指针）：15-三数之和"><a href="#LeetCode练习（数组-双指针）：15-三数之和" class="headerlink" title="LeetCode练习（数组/双指针）：15.三数之和"></a><strong>LeetCode练习（数组/双指针）：15.三数之和</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_15.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        if(nums.size()&lt;3 )</span><br><span class="line">            return res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int now=nums[i];</span><br><span class="line">            if(now &gt; 0)</span><br><span class="line">                break;</span><br><span class="line">            int ptr_left=i+1;</span><br><span class="line">            int ptr_right=nums.size()-1;</span><br><span class="line">            while(ptr_left&lt;ptr_right)</span><br><span class="line">            &#123;</span><br><span class="line">                int add=nums[ptr_left]+nums[ptr_right];</span><br><span class="line">                if(add+now&lt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr_left++;</span><br><span class="line">                &#125;else if(add+now&gt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr_right--;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;int&gt; temp;</span><br><span class="line">                    temp.push_back(now);</span><br><span class="line">                    temp.push_back(nums[ptr_left]);</span><br><span class="line">                    temp.push_back(nums[ptr_right]);</span><br><span class="line">                    res.push_back(temp);</span><br><span class="line">                    //去重</span><br><span class="line">                    int intLo=nums[ptr_left];</span><br><span class="line">                    int intHi=nums[ptr_right];</span><br><span class="line">                    while (ptr_left &lt; ptr_right &amp;&amp; nums[ptr_left] == intLo)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ptr_left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while (ptr_left &lt; ptr_right &amp;&amp; nums[ptr_right] == intHi)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ptr_right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //去重</span><br><span class="line">            while (i + 1 &lt; nums.size()-2 &amp;&amp; nums[i] == nums[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-双指针）：11-盛最多水的容器"><a href="#LeetCode练习（数组-双指针）：11-盛最多水的容器" class="headerlink" title="LeetCode练习（数组/双指针）：11.盛最多水的容器"></a><strong>LeetCode练习（数组/双指针）：11.盛最多水的容器</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_11.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int left=0,right=height.size()-1;</span><br><span class="line">        int max=0;</span><br><span class="line">        while(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            int v_min;</span><br><span class="line">            int width=right-left;</span><br><span class="line">            if(height[left]&lt;height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                v_min=height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                v_min=height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            int temp=v_min*width;</span><br><span class="line">            if(temp&gt;max)</span><br><span class="line">               max=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——18.二叉树的镜像（8-28-35）</title>
    <link href="http://hustxxj.github.io/2020/03/09/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9418.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>http://hustxxj.github.io/2020/03/09/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9418.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</id>
    <published>2020-03-09T07:33:13.000Z</published>
    <updated>2020-03-09T12:25:47.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用递归实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //记Mirror函数为：交换pRoot两颗子树的位置</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot == nullptr)</span><br><span class="line">            return;</span><br><span class="line">        if(pRoot-&gt;left!=nullptr || pRoot-&gt;right!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tempNode=pRoot-&gt;right;</span><br><span class="line">            pRoot-&gt;right=pRoot-&gt;left;</span><br><span class="line">            pRoot-&gt;left=tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：35-搜索插入的位置"><a href="#LeetCode练习（数组）：35-搜索插入的位置" class="headerlink" title="LeetCode练习（数组）：35.搜索插入的位置"></a><strong>LeetCode练习（数组）：35.搜索插入的位置</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_35.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>暴力解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.size()==0)</span><br><span class="line">           return 0;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] == target || nums[i] &gt; target)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>二分查找：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.size()==0 || target &lt; nums[0])</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        if(target &gt; nums[nums.size()-1])</span><br><span class="line">           return nums.size();</span><br><span class="line"></span><br><span class="line">        int ptr_begin=0,ptr_end=nums.size()-1;</span><br><span class="line">        while(ptr_begin &lt; ptr_end)</span><br><span class="line">        &#123;</span><br><span class="line">            int ptr_mid=(ptr_begin+ptr_end)/2;</span><br><span class="line">            if(nums[ptr_mid]==target)</span><br><span class="line">               return ptr_mid;</span><br><span class="line">            else if(nums[ptr_mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr_begin=ptr_mid+1;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ptr_end=ptr_mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ptr_begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（双指针）：28-实现strStr"><a href="#LeetCode练习（双指针）：28-实现strStr" class="headerlink" title="LeetCode练习（双指针）：28.实现strStr()"></a><strong>LeetCode练习（双指针）：28.实现strStr()</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_28.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><em>双指针实现：重点在于找到循环退出条件</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        int n = haystack.size(), m = needle.size();</span><br><span class="line">        for(int i = 0; i &lt; n - m + 1; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for( ; j &lt; m; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(haystack[i + j] !=  needle[j])</span><br><span class="line">                //为了保证在这个循环里haystack的索引也跟着needle索引一起向前推进，i的含义设置为起始点，i + j才是haystack的索引</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j == m)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组）：8-字符串转换整数（atoi）"><a href="#LeetCode练习（数组）：8-字符串转换整数（atoi）" class="headerlink" title="LeetCode练习（数组）：8.字符串转换整数（atoi）"></a><strong>LeetCode练习（数组）：8.字符串转换整数（atoi）</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_8.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(string str) &#123;</span><br><span class="line">        int begin=0;</span><br><span class="line">        for(int i=0;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==&apos; &apos;)</span><br><span class="line">               continue;</span><br><span class="line">            else</span><br><span class="line">               begin=i;</span><br><span class="line">               break;</span><br><span class="line">        &#125;</span><br><span class="line">        int res=0;</span><br><span class="line">        int flag;</span><br><span class="line">        string sav;</span><br><span class="line">        if((str[begin]&gt;=&apos;0&apos;&amp;&amp;str[begin]&lt;=&apos;9&apos;) || str[begin]==&apos;-&apos; || str[begin]==&apos;+&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[begin]&gt;=&apos;0&apos;&amp;&amp;str[begin]&lt;=&apos;9&apos;)  //开头是数字</span><br><span class="line">            &#123;</span><br><span class="line">                flag=1;</span><br><span class="line">                for(int j=begin;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                    else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(str[begin]==&apos;-&apos;)   //开头是负号</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                if(begin==str.size()-1)</span><br><span class="line">                    return 0;</span><br><span class="line">                sav.push_back(&apos;-&apos;);</span><br><span class="line">                for(int j=begin+1;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                     if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                     else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(str[begin]==&apos;+&apos;)   //开头是正号</span><br><span class="line">            &#123;</span><br><span class="line">                flag=3;</span><br><span class="line">                if(begin==str.size()-1)</span><br><span class="line">                    return 0;</span><br><span class="line">                sav.push_back(&apos;+&apos;);</span><br><span class="line">                for(int j=begin+1;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                     if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                     else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int len=sav.size();</span><br><span class="line">        if(flag==1)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1)&gt;INT_MAX)</span><br><span class="line">                    return INT_MAX;</span><br><span class="line">                else</span><br><span class="line">                    res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(flag==2)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1) &gt; INT_MAX)</span><br><span class="line">                   return INT_MIN;</span><br><span class="line">                else</span><br><span class="line">                   res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">            res=-res;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(flag==3)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1) &gt; INT_MAX)</span><br><span class="line">                   return INT_MAX;</span><br><span class="line">                else</span><br><span class="line">                   res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——17.树的子结构（112-198-f57）</title>
    <link href="http://hustxxj.github.io/2020/03/07/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9417.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://hustxxj.github.io/2020/03/07/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9417.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</id>
    <published>2020-03-07T07:46:11.000Z</published>
    <updated>2020-03-07T13:28:17.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两棵二叉树A、B，判断B是不是A的子结构（约定：空树不是任意一个数的子结构）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>该题用递归实现</p><ol><li>定义一个函数isSameStruct(root1,root2)，用于判断从root1和root2开始，两个树是否完全一样。</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot1==nullptr || pRoot2==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return isSameStruct(pRoot1,pRoot2) || HasSubtree(pRoot1-&gt;left,pRoot2) || HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //判断从root1和root2这两个节点开始，两棵树是不是一样的</span><br><span class="line">    bool isSameStruct(TreeNode* root1, TreeNode* root2)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果root2(表示子树)先结束并没有返回false,那么代表root2是root1的子树，返回true</span><br><span class="line">        if(root2==nullptr)</span><br><span class="line">            return true;</span><br><span class="line">        //如果root1先返回，表示root2不是root1的子树</span><br><span class="line">        if(root1==nullptr)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(root1-&gt;val != root2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果两个值相等，再比较他们的左右节点</span><br><span class="line">        return isSameStruct(root1-&gt;left,root2-&gt;left) &amp;&amp; isSameStruct(root1-&gt;right,root2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树）：112-路径总和"><a href="#LeetCode练习（树）：112-路径总和" class="headerlink" title="LeetCode练习（树）：112.路径总和"></a><strong>LeetCode练习（树）：112.路径总和</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/07/剑指Offer——17.树的子结构/17_112.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：经典的用queue来迭代完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">           return false;</span><br><span class="line">        </span><br><span class="line">        queue&lt;int&gt; save_value;</span><br><span class="line">        queue&lt;TreeNode*&gt; save_node;</span><br><span class="line">        save_node.push(root);</span><br><span class="line">        save_value.push(root-&gt;val);</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while(!save_node.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=save_node.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=save_node.front();</span><br><span class="line">                int temp_value=save_value.front();</span><br><span class="line">                save_node.pop();</span><br><span class="line">                save_value.pop();</span><br><span class="line">                if(temp-&gt;left==nullptr &amp;&amp; temp-&gt;right==nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(temp_value);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    save_node.push(temp-&gt;left);</span><br><span class="line">                    save_value.push(temp-&gt;left-&gt;val+temp_value);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right!=nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    save_node.push(temp-&gt;right);</span><br><span class="line">                    save_value.push(temp-&gt;right-&gt;val+temp_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;::iterator ptr=find(res.begin(),res.end(),sum);</span><br><span class="line">        return (ptr==res.end())?false:true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组）：198-打家劫舍"><a href="#LeetCode练习（数组）：198-打家劫舍" class="headerlink" title="LeetCode练习（数组）：198.打家劫舍"></a><strong>LeetCode练习（数组）：198.打家劫舍</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/07/剑指Offer——17.树的子结构/17_198.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>思路：动态规划类型题目关键在于找到状态转移方程设f(n)表示劫犯遍历完第n家共获得的最高金额若偷第n家，那么第n-1家必然不能偷，所以f(n)=nums[n]+f(n-2);若不偷第n家，那么遍历完第n家所获得最大金额就等于遍历完第n-1家所获得最大金额，即f(n)=f(n-1);综上，若想f(n)最大，则得出状态转移方程f(n)=max(nums[n]+f(n-2),f(n-1));</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        else if(len==1)</span><br><span class="line">           return nums[0];</span><br><span class="line"></span><br><span class="line">        int a=0,b=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=max(nums[i]+a,b);</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（滑动窗口）：面试题57-II-和为s的连续正数序列"><a href="#LeetCode练习（滑动窗口）：面试题57-II-和为s的连续正数序列" class="headerlink" title="LeetCode练习（滑动窗口）：面试题57-II.和为s的连续正数序列"></a><strong>LeetCode练习（滑动窗口）：面试题57-II.和为s的连续正数序列</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>利用滑动窗口求解的题目，要注意<em>循环退出条件</em>，还有<em>窗口的边界</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        if(target==0)</span><br><span class="line">           return res;</span><br><span class="line">        </span><br><span class="line">        int left=1,right=1;</span><br><span class="line">        int border=target/2 + 1;</span><br><span class="line">        int sum=0;</span><br><span class="line">        while(left &lt; border)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;else if(sum &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum-=left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;int&gt; temp;</span><br><span class="line">                for(int i=left;i&lt;right;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                sum+=right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两棵二叉树A、B，判断B是不是A的子结构（约定：空树不是任意一个数的子结构）
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——16.合并两个排序的链表（70-121-1103）</title>
    <link href="http://hustxxj.github.io/2020/03/05/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9416.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/03/05/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9416.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-05T07:07:27.000Z</published>
    <updated>2020-03-07T13:26:58.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两个单调递增的链表，输出两个链表合成后的链表，合成后的链表满足单调不减规则。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p><em>略</em></p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead1==nullptr)</span><br><span class="line">            return pHead2;</span><br><span class="line">        else if(pHead2==nullptr)</span><br><span class="line">            return pHead1;</span><br><span class="line">        </span><br><span class="line">        ListNode* f_head=new ListNode(-1);</span><br><span class="line">        ListNode* f_ptr=f_head;</span><br><span class="line">        ListNode* ptr1=pHead1;</span><br><span class="line">        ListNode* ptr2=pHead2;</span><br><span class="line">        while(ptr1 &amp;&amp; ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp_node;</span><br><span class="line">            if(ptr1-&gt;val &lt;= ptr2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_node=ptr1;</span><br><span class="line">                ptr1=ptr1-&gt;next;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                temp_node=ptr2;</span><br><span class="line">                ptr2=ptr2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            f_ptr-&gt;next=temp_node;</span><br><span class="line">            f_ptr=temp_node;</span><br><span class="line">        &#125;</span><br><span class="line">        f_ptr-&gt;next=(ptr1)?ptr1:ptr2;</span><br><span class="line">        return f_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：1103-分糖果II"><a href="#LeetCode练习（动态规划）：1103-分糖果II" class="headerlink" title="LeetCode练习（动态规划）：1103.分糖果II"></a><strong>LeetCode练习（动态规划）：1103.分糖果II</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/05/剑指Offer——16.合并两个排序的链表/16_1103.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; distributeCandies(int candies, int num_people) &#123;</span><br><span class="line">        vector&lt;int&gt; res(num_people);</span><br><span class="line">        if(num_people==1)</span><br><span class="line">        &#123;</span><br><span class="line">            res[0]=candies;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int num_candy=1;</span><br><span class="line">        for(int i=0;i&lt;num_people;i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            if(candies&gt;=num_candy)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]+=num_candy;</span><br><span class="line">                candies-=num_candy;</span><br><span class="line">                num_candy++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]+=candies;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(i==num_people-1)</span><br><span class="line">                i=-1;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：70-爬楼梯"><a href="#LeetCode练习（动态规划）：70-爬楼梯" class="headerlink" title="LeetCode练习（动态规划）：70.爬楼梯"></a><strong>LeetCode练习（动态规划）：70.爬楼梯</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>该题与青蛙跳台阶一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n==1 || n==2)</span><br><span class="line">           return n;</span><br><span class="line">        </span><br><span class="line">        int a=1,b=2;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=3;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（动态规划）：121-买卖股票的最佳时机"><a href="#LeetCode练习（动态规划）：121-买卖股票的最佳时机" class="headerlink" title="LeetCode练习（动态规划）：121.买卖股票的最佳时机"></a><strong>LeetCode练习（动态规划）：121.买卖股票的最佳时机</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/05/剑指Offer——16.合并两个排序的链表/16_121.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>dp[i][0]:第i天，不持股，手上所得最大利润dp[i][1]:第i天，持股，手上所得最大利润</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int len=prices.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int dp_i_0=0,dp_i_1=INT_MIN; //初始化，dp_i_0=0表示-1天未持股所能获得最大利润，dp_i_1=INT_MIN表示-1天持股所能获得最大利润为不可能事件</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_i_0=max(dp_i_0,dp_i_1+prices[i]);</span><br><span class="line">            dp_i_1=max(dp_i_1,-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp_i_0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，合成后的链表满足单调不减规则。
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
