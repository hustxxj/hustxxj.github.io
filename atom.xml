<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江江的小跟班.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hustxxj.github.io/"/>
  <updated>2020-03-14T14:46:46.763Z</updated>
  <id>http://hustxxj.github.io/</id>
  
  <author>
    <name>Xuxuejie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer——23.二叉搜索树的后序遍历序列（6-34-300）</title>
    <link href="http://hustxxj.github.io/2020/03/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9423.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9423.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-14T11:43:59.000Z</published>
    <updated>2020-03-14T14:46:46.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><pre><code>采用自顶向下的方式进行运算如果vector是二叉搜索树的后续遍历序列，那么vector{a1,....,a2,b1,.....,b2,c1}一定满足a1~a2小于c1,b1~b2大于c1如果以上条件满足，那么再将a1~a2,b1~b2分别作为输入验证他们是否满足</code></pre><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool isFirstIn=true;</span><br><span class="line">public:</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">        int len=sequence.size();</span><br><span class="line">        if(len==0 &amp;&amp; isFirstIn==true)</span><br><span class="line">            return false;</span><br><span class="line">        if(len &lt;=2)</span><br><span class="line">            return true;</span><br><span class="line">        isFirstIn=false;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; left,right;</span><br><span class="line">        int root=sequence[len-1];</span><br><span class="line">        int ptr;</span><br><span class="line">        for(int i=0;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sequence[i] &lt; root)</span><br><span class="line">                left.push_back(sequence[i]);</span><br><span class="line">            if(sequence[i] &gt; root)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==len-2)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=i+1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=ptr;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sequence[i]&gt;root)</span><br><span class="line">                right.push_back(sequence[i]);</span><br><span class="line">            if(sequence[i]&lt;root)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return VerifySquenceOfBST(left) &amp;&amp; VerifySquenceOfBST(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：300-最长的上升子序列"><a href="#LeetCode练习（动态规划）：300-最长的上升子序列" class="headerlink" title="LeetCode练习（动态规划）：300.最长的上升子序列"></a><strong>LeetCode练习（动态规划）：300.最长的上升子序列</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_300.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>状态转移方程：设dp[n]表示从第n个数字往左，最长上升子序列的长度            则，dp[n]=max(dp[j])+1; 0&lt;=j&lt;n;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return len;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; dp(len,0);</span><br><span class="line">        for(int j=0;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=1;</span><br><span class="line">            for(int i=0;i&lt;j;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i] &lt; nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j]=max(dp[j],dp[i]+1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：6-Z字形变换"><a href="#LeetCode练习（字符串）：6-Z字形变换" class="headerlink" title="LeetCode练习（字符串）：6.Z字形变换"></a><strong>LeetCode练习（字符串）：6.Z字形变换</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_6.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convert(string s, int numRows) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        if(s==&quot;&quot; || numRows==0)</span><br><span class="line">           return res;</span><br><span class="line">        </span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len &lt;=numRows || numRows==1)</span><br><span class="line">           return s;</span><br><span class="line">        vector&lt;string&gt; ss(numRows);</span><br><span class="line">        bool isDown=true;</span><br><span class="line">        int stairs=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isDown==true)</span><br><span class="line">            &#123;</span><br><span class="line">                ss[stairs].push_back(s[i]);</span><br><span class="line">                stairs++;</span><br><span class="line">                if(stairs==numRows)</span><br><span class="line">                &#123;</span><br><span class="line">                    isDown=false;</span><br><span class="line">                    stairs-=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ss[stairs].push_back(s[i]);</span><br><span class="line">                stairs--;</span><br><span class="line">                if(stairs&lt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    isDown=true;</span><br><span class="line">                    stairs+=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=ss[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode练习（数组）：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode练习（数组）：34. 在排序数组中查找元素的第一个和最后一个位置"></a><strong>LeetCode练习（数组）：34. 在排序数组中查找元素的第一个和最后一个位置</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_6.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;int&gt;::iterator it1=find(nums.begin(),nums.end(),target);</span><br><span class="line">        if(it1==nums.end())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(-1);</span><br><span class="line">            res.push_back(-1);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(it1-nums.begin());</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">        vector&lt;int&gt;::iterator it2=find(nums.begin(),nums.end(),target);</span><br><span class="line">        res.push_back(nums.size()-(it2-nums.begin())-1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Ye
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——22.从上往下打印二叉树（58-169-322）</title>
    <link href="http://hustxxj.github.io/2020/03/13/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9422.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://hustxxj.github.io/2020/03/13/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9422.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-13T08:46:04.000Z</published>
    <updated>2020-03-13T17:54:55.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>简单的利用队列实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt;  res;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left!=nullptr)</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                if(temp-&gt;right!=nullptr)</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：169-多数元素"><a href="#LeetCode练习（数组）：169-多数元素" class="headerlink" title="LeetCode练习（数组）：169.多数元素"></a><strong>LeetCode练习（数组）：169.多数元素</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_169.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        int count=0;int target=nums[0];</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==target)</span><br><span class="line">               count++;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(count &gt; len/2)</span><br><span class="line">                   return target;</span><br><span class="line">                count=1;</span><br><span class="line">                target=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：322-零钱兑换"><a href="#LeetCode练习（动态规划）：322-零钱兑换" class="headerlink" title="LeetCode练习（动态规划）：322.零钱兑换"></a><strong>LeetCode练习（动态规划）：322.零钱兑换</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_322.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>动态规划问题最重要的就是列出状态转移方程设dp[n]表示凑出n块钱，所需要的硬币个数最小值  那么就有dp[n]=min(dp[n-coin]+1)，即需要凑出n-coin块钱需要的硬币个数+1个面额为coin的硬币n=0时,dp[0]=0;n&lt;0时,dp[n]=-1;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        int num=coins.size();</span><br><span class="line">        if(num==0)</span><br><span class="line">           return -1;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(amount+1,amount+1);</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for(int i=0;i&lt;amount+1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;num;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i-coins[j] &lt; 0)</span><br><span class="line">                   continue;</span><br><span class="line">                dp[i]=min(dp[i-coins[j]]+1,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (dp[amount]==amount+1)?-1:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：58-最后一个单词的长度"><a href="#LeetCode练习（数组）：58-最后一个单词的长度" class="headerlink" title="LeetCode练习（数组）：58.最后一个单词的长度"></a><strong>LeetCode练习（数组）：58.最后一个单词的长度</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_58.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=len-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&apos; &apos;)</span><br><span class="line">               continue;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=i;j&gt;=0;j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s[j]==&apos; &apos;)</span><br><span class="line">                      break;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;从上往下打印出二叉树的每个节点，同层节点从左至右打印。&lt;/p&gt;
&lt;hr&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——21.栈的弹入弹出序列（38-283-1071）</title>
    <link href="http://hustxxj.github.io/2020/03/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9421.%E6%A0%88%E7%9A%84%E5%BC%B9%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9421.%E6%A0%88%E7%9A%84%E5%BC%B9%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-12T08:37:14.000Z</published>
    <updated>2020-03-12T11:24:18.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>记录弹出序列中逆序的数量，当逆序数大于等于2时则表示该序列不可能是弹出序列。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        int num=pushV.size();</span><br><span class="line">        if(num==0)</span><br><span class="line">            return true;</span><br><span class="line">        if(num==1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pushV[0]!=popV[0])</span><br><span class="line">                return false;</span><br><span class="line">            else</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int reversetime=0;</span><br><span class="line">        for(int i=0;i&lt;num-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int a=popV[i];</span><br><span class="line">            int b=popV[i+1];</span><br><span class="line">            vector&lt;int&gt;::iterator ptra=find(pushV.begin(),pushV.end(),a);</span><br><span class="line">            vector&lt;int&gt;::iterator ptrb=find(pushV.begin(),pushV.end(),b);</span><br><span class="line">            if(ptra==pushV.end() || ptrb==pushV.end())</span><br><span class="line">                return false;</span><br><span class="line">            if((ptra-pushV.begin())&lt;(ptrb-pushV.begin()))</span><br><span class="line">                reversetime++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(reversetime&gt;=2)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：1071-字符串的最大公因子"><a href="#LeetCode练习（字符串）：1071-字符串的最大公因子" class="headerlink" title="LeetCode练习（字符串）：1071.字符串的最大公因子"></a><strong>LeetCode练习（字符串）：1071.字符串的最大公因子</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_1071.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string gcdOfStrings(string str1, string str2) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        int len1=str1.size();</span><br><span class="line">        int len2=str2.size();</span><br><span class="line">        int M=gcd(len1,len2);           //gcd(x,y)求x，y的最大公约数</span><br><span class="line">        for(int i=0;i&lt;M;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str1[i]==str2[i])</span><br><span class="line">               res.push_back(str1[i]);</span><br><span class="line">            else</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str1[i]!=res[i%M])</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str2[i]!=res[i%M])</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：38-外观数列"><a href="#LeetCode练习（数组）：38-外观数列" class="headerlink" title="LeetCode练习（数组）：38.外观数列"></a><strong>LeetCode练习（数组）：38.外观数列</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_38.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string res=&quot;1&quot;;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=transform(res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string transform(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        string res;</span><br><span class="line">        int len=str.size();</span><br><span class="line">        int ptr=0;</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==str[ptr])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count+&apos;0&apos;);</span><br><span class="line">                res.push_back(str[ptr]);</span><br><span class="line">                ptr=i;</span><br><span class="line">                count=0;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(count+&apos;0&apos;);</span><br><span class="line">        res.push_back(str[ptr]);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：283-移动零"><a href="#LeetCode练习（数组）：283-移动零" class="headerlink" title="LeetCode练习（数组）：283.移动零"></a><strong>LeetCode练习（数组）：283.移动零</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_283.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">               count++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.push_back(0);</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                i--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——20.包含min函数的栈（17-88-1013）</title>
    <link href="http://hustxxj.github.io/2020/03/11/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9420.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>http://hustxxj.github.io/2020/03/11/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9420.%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</id>
    <published>2020-03-11T06:34:41.000Z</published>
    <updated>2020-03-11T12:18:51.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度为o(1)）。注意：测试样例中保证不在栈为空的时候，调用pop()或者min()或者top方法。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>要想在时间复杂度为o(1)的情况下找出栈中最小的元素，那么就需要另外开辟一个栈空间，用来存放最小值。<br>记原始栈为sta1,存放最小值的栈为sta2，存放的规则为：</p><ol><li>sta1正常进行push,pop等操作。</li><li>当sta2为empty时，向sta2中正常push元素；当sta2不为empty时，需要比较当前push的元素与sta2的栈顶元素的大小，只有当前要push的元素小于栈顶元素，才能push入sta2。</li><li>当需要pop时，当sta1弹出的元素为栈中的最小元素时，sta2也要跟着弹出栈顶元素（因为sta1弹出栈中最小元素意味着min值已经改变，所以sta2的栈顶最为记录min的栈，栈顶值也要改变。）<br><em>特别的：需要理解sta2从栈底到栈顶依次记录的是，sta1每次push后栈中的最小元素</em></li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">stack&lt;int&gt; sta1,sta2;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        sta1.push(value);</span><br><span class="line">        if(sta2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sta2.push(value);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(sta2.top() &gt; value)</span><br><span class="line">            &#123;</span><br><span class="line">                sta2.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(sta1.top()==sta2.top())</span><br><span class="line">            sta2.pop();</span><br><span class="line">        sta1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return sta1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return sta2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：1013-将数组分成和相等的三个部分"><a href="#LeetCode练习（数组）：1013-将数组分成和相等的三个部分" class="headerlink" title="LeetCode练习（数组）：1013. 将数组分成和相等的三个部分"></a><strong>LeetCode练习（数组）：1013. 将数组分成和相等的三个部分</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_1013.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li>根据题意：只有将数组分成三等份，且三等份每份的和相等才能返回true，否则返回false。</li><li>将数组分为三等份，需要两个指针实现。</li><li>例如[0,2,1,-6,6,-7,9,1,2,0,1],初始化定义第一个指针指向第一个元素，第二个指针指向最后一个元素</li><li>判断每个区间的和与目标值是否相等，相等则指针不动，不相等则指针移动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int len=A.size();</span><br><span class="line">        if(len&lt;=2)</span><br><span class="line">            return false;</span><br><span class="line">        int sum = accumulate(A.begin(), A.end(), 0);</span><br><span class="line">        int target;</span><br><span class="line">        if(sum%3 != 0)</span><br><span class="line">           return false;</span><br><span class="line">        else</span><br><span class="line">           target=sum/3;</span><br><span class="line"></span><br><span class="line">        int left_ptr=0,right_ptr=len-1;</span><br><span class="line">        int sum_left=A[left_ptr],sum_right=A[right_ptr];</span><br><span class="line">        while(left_ptr+1&lt;right_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum_left==target &amp;&amp; sum_right==target)</span><br><span class="line">               return true;</span><br><span class="line">            if(sum_left!=target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum_left+=A[++left_ptr];</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum_right!=target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum_right+=A[--right_ptr];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：88-合并两个有序数组"><a href="#LeetCode练习（数组）：88-合并两个有序数组" class="headerlink" title="LeetCode练习（数组）：88.合并两个有序数组"></a><strong>LeetCode练习（数组）：88.合并两个有序数组</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_88.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        for(int i=m;i&lt;m+n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i]=nums2[i-m];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1.erase((nums1.begin()+m+n),nums1.end());</span><br><span class="line">        sort(nums1.begin(),nums1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯算法）：17-电话号码的字母组合"><a href="#LeetCode练习（回溯算法）：17-电话号码的字母组合" class="headerlink" title="LeetCode练习（回溯算法）：17.电话号码的字母组合"></a><strong>LeetCode练习（回溯算法）：17.电话号码的字母组合</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/11/剑指Offer——20.包含min函数的栈/20_17.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>遍历digits的每个字符，将每个字符下面索引出的所有元素都与res里的每个元素进行相加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        int len=digits.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        res=&#123;&quot;&quot;&#125;;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            if(digits[i]==&apos;2&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;a&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;b&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;c&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;3&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;d&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;e&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;f&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;4&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;g&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;h&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;i&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;5&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;j&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;k&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;l&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;6&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;m&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;n&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;o&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;7&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;p&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;q&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;r&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;s&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;8&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;t&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;u&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;v&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(digits[i]==&apos;9&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=0;j&lt;res.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(res[j]+&apos;w&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;x&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;y&apos;);</span><br><span class="line">                    temp.push_back(res[j]+&apos;z&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——19.顺时针打印矩阵（11-15-543）</title>
    <link href="http://hustxxj.github.io/2020/03/10/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9419.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://hustxxj.github.io/2020/03/10/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9419.%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</id>
    <published>2020-03-10T00:05:02.000Z</published>
    <updated>2020-03-10T05:59:21.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4x4矩阵：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16则依次打印出数字1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>从最外圈顺时针逐渐向内圈遍历，利用四个指针限定出最外圈的四个角，遍历完最外圈后将四个角点内移，然后重新遍历。直到左右角重叠或者上下角重叠则退出循环。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(matrix.size()==0 || matrix[0].size()==0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        int left=0,right=matrix[0].size()-1,top=0,bottom=matrix.size()-1;</span><br><span class="line">        while(left&lt;=right &amp;&amp; top&lt;=bottom)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=left;i&lt;=right;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i=top+1;i&lt;=bottom;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            //避免横向重复遍历同一行</span><br><span class="line">            if(top!=bottom)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int i=right-1;i&gt;=left;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //避免纵向重复遍历同一页</span><br><span class="line">            if(left!=right)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int i=bottom-1;i&gt;top;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（二叉树）：543-二叉树的直径"><a href="#LeetCode练习（二叉树）：543-二叉树的直径" class="headerlink" title="LeetCode练习（二叉树）：543.二叉树的直径"></a><strong>LeetCode练习（二叉树）：543.二叉树的直径</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_543.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int max=0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp_node=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp_node-&gt;left!=nullptr)</span><br><span class="line">                   q.push(temp_node-&gt;left);</span><br><span class="line">                if(temp_node-&gt;right!=nullptr)</span><br><span class="line">                   q.push(temp_node-&gt;right);</span><br><span class="line">                int v=depth(temp_node-&gt;left)+depth(temp_node-&gt;right);</span><br><span class="line">                if(v&gt;max)</span><br><span class="line">                   max=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int depth(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)</span><br><span class="line">            return 1;</span><br><span class="line">        </span><br><span class="line">        int depth_l=depth(root-&gt;left)+1;</span><br><span class="line">        int depth_r=depth(root-&gt;right)+1;</span><br><span class="line"></span><br><span class="line">        return max(depth_l,depth_r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-双指针）：15-三数之和"><a href="#LeetCode练习（数组-双指针）：15-三数之和" class="headerlink" title="LeetCode练习（数组/双指针）：15.三数之和"></a><strong>LeetCode练习（数组/双指针）：15.三数之和</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_15.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        if(nums.size()&lt;3 )</span><br><span class="line">            return res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int now=nums[i];</span><br><span class="line">            if(now &gt; 0)</span><br><span class="line">                break;</span><br><span class="line">            int ptr_left=i+1;</span><br><span class="line">            int ptr_right=nums.size()-1;</span><br><span class="line">            while(ptr_left&lt;ptr_right)</span><br><span class="line">            &#123;</span><br><span class="line">                int add=nums[ptr_left]+nums[ptr_right];</span><br><span class="line">                if(add+now&lt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr_left++;</span><br><span class="line">                &#125;else if(add+now&gt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr_right--;</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;int&gt; temp;</span><br><span class="line">                    temp.push_back(now);</span><br><span class="line">                    temp.push_back(nums[ptr_left]);</span><br><span class="line">                    temp.push_back(nums[ptr_right]);</span><br><span class="line">                    res.push_back(temp);</span><br><span class="line">                    //去重</span><br><span class="line">                    int intLo=nums[ptr_left];</span><br><span class="line">                    int intHi=nums[ptr_right];</span><br><span class="line">                    while (ptr_left &lt; ptr_right &amp;&amp; nums[ptr_left] == intLo)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ptr_left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while (ptr_left &lt; ptr_right &amp;&amp; nums[ptr_right] == intHi)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ptr_right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //去重</span><br><span class="line">            while (i + 1 &lt; nums.size()-2 &amp;&amp; nums[i] == nums[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-双指针）：11-盛最多水的容器"><a href="#LeetCode练习（数组-双指针）：11-盛最多水的容器" class="headerlink" title="LeetCode练习（数组/双指针）：11.盛最多水的容器"></a><strong>LeetCode练习（数组/双指针）：11.盛最多水的容器</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/10/剑指Offer——19.顺时针打印矩阵/19_11.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int left=0,right=height.size()-1;</span><br><span class="line">        int max=0;</span><br><span class="line">        while(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            int v_min;</span><br><span class="line">            int width=right-left;</span><br><span class="line">            if(height[left]&lt;height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                v_min=height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                v_min=height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            int temp=v_min*width;</span><br><span class="line">            if(temp&gt;max)</span><br><span class="line">               max=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——18.二叉树的镜像（8-28-35）</title>
    <link href="http://hustxxj.github.io/2020/03/09/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9418.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>http://hustxxj.github.io/2020/03/09/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9418.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</id>
    <published>2020-03-09T07:33:13.000Z</published>
    <updated>2020-03-09T12:25:47.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用递归实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //记Mirror函数为：交换pRoot两颗子树的位置</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot == nullptr)</span><br><span class="line">            return;</span><br><span class="line">        if(pRoot-&gt;left!=nullptr || pRoot-&gt;right!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tempNode=pRoot-&gt;right;</span><br><span class="line">            pRoot-&gt;right=pRoot-&gt;left;</span><br><span class="line">            pRoot-&gt;left=tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：35-搜索插入的位置"><a href="#LeetCode练习（数组）：35-搜索插入的位置" class="headerlink" title="LeetCode练习（数组）：35.搜索插入的位置"></a><strong>LeetCode练习（数组）：35.搜索插入的位置</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_35.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>暴力解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.size()==0)</span><br><span class="line">           return 0;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] == target || nums[i] &gt; target)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>二分查找：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.size()==0 || target &lt; nums[0])</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        if(target &gt; nums[nums.size()-1])</span><br><span class="line">           return nums.size();</span><br><span class="line"></span><br><span class="line">        int ptr_begin=0,ptr_end=nums.size()-1;</span><br><span class="line">        while(ptr_begin &lt; ptr_end)</span><br><span class="line">        &#123;</span><br><span class="line">            int ptr_mid=(ptr_begin+ptr_end)/2;</span><br><span class="line">            if(nums[ptr_mid]==target)</span><br><span class="line">               return ptr_mid;</span><br><span class="line">            else if(nums[ptr_mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr_begin=ptr_mid+1;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ptr_end=ptr_mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ptr_begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（双指针）：28-实现strStr"><a href="#LeetCode练习（双指针）：28-实现strStr" class="headerlink" title="LeetCode练习（双指针）：28.实现strStr()"></a><strong>LeetCode练习（双指针）：28.实现strStr()</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_28.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><em>双指针实现：重点在于找到循环退出条件</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        int n = haystack.size(), m = needle.size();</span><br><span class="line">        for(int i = 0; i &lt; n - m + 1; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for( ; j &lt; m; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(haystack[i + j] !=  needle[j])</span><br><span class="line">                //为了保证在这个循环里haystack的索引也跟着needle索引一起向前推进，i的含义设置为起始点，i + j才是haystack的索引</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j == m)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组）：8-字符串转换整数（atoi）"><a href="#LeetCode练习（数组）：8-字符串转换整数（atoi）" class="headerlink" title="LeetCode练习（数组）：8.字符串转换整数（atoi）"></a><strong>LeetCode练习（数组）：8.字符串转换整数（atoi）</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/09/剑指Offer——18.二叉树的镜像/18_8.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(string str) &#123;</span><br><span class="line">        int begin=0;</span><br><span class="line">        for(int i=0;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==&apos; &apos;)</span><br><span class="line">               continue;</span><br><span class="line">            else</span><br><span class="line">               begin=i;</span><br><span class="line">               break;</span><br><span class="line">        &#125;</span><br><span class="line">        int res=0;</span><br><span class="line">        int flag;</span><br><span class="line">        string sav;</span><br><span class="line">        if((str[begin]&gt;=&apos;0&apos;&amp;&amp;str[begin]&lt;=&apos;9&apos;) || str[begin]==&apos;-&apos; || str[begin]==&apos;+&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[begin]&gt;=&apos;0&apos;&amp;&amp;str[begin]&lt;=&apos;9&apos;)  //开头是数字</span><br><span class="line">            &#123;</span><br><span class="line">                flag=1;</span><br><span class="line">                for(int j=begin;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                    else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(str[begin]==&apos;-&apos;)   //开头是负号</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                if(begin==str.size()-1)</span><br><span class="line">                    return 0;</span><br><span class="line">                sav.push_back(&apos;-&apos;);</span><br><span class="line">                for(int j=begin+1;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                     if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                     else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(str[begin]==&apos;+&apos;)   //开头是正号</span><br><span class="line">            &#123;</span><br><span class="line">                flag=3;</span><br><span class="line">                if(begin==str.size()-1)</span><br><span class="line">                    return 0;</span><br><span class="line">                sav.push_back(&apos;+&apos;);</span><br><span class="line">                for(int j=begin+1;j&lt;str.size();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                     if(str[j]&lt;&apos;0&apos; || str[j]&gt;&apos;9&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                     else</span><br><span class="line">                       sav.push_back(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int len=sav.size();</span><br><span class="line">        if(flag==1)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1)&gt;INT_MAX)</span><br><span class="line">                    return INT_MAX;</span><br><span class="line">                else</span><br><span class="line">                    res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(flag==2)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1) &gt; INT_MAX)</span><br><span class="line">                   return INT_MIN;</span><br><span class="line">                else</span><br><span class="line">                   res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">            res=-res;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(flag==3)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int n=sav[i]-&apos;0&apos;;</span><br><span class="line">                if(res+n*pow(10,len-i-1) &gt; INT_MAX)</span><br><span class="line">                   return INT_MAX;</span><br><span class="line">                else</span><br><span class="line">                   res+=n*pow(10,len-i-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——17.树的子结构（112-198-f57）</title>
    <link href="http://hustxxj.github.io/2020/03/07/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9417.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://hustxxj.github.io/2020/03/07/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9417.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</id>
    <published>2020-03-07T07:46:11.000Z</published>
    <updated>2020-03-07T13:28:17.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两棵二叉树A、B，判断B是不是A的子结构（约定：空树不是任意一个数的子结构）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>该题用递归实现</p><ol><li>定义一个函数isSameStruct(root1,root2)，用于判断从root1和root2开始，两个树是否完全一样。</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot1==nullptr || pRoot2==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return isSameStruct(pRoot1,pRoot2) || HasSubtree(pRoot1-&gt;left,pRoot2) || HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //判断从root1和root2这两个节点开始，两棵树是不是一样的</span><br><span class="line">    bool isSameStruct(TreeNode* root1, TreeNode* root2)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果root2(表示子树)先结束并没有返回false,那么代表root2是root1的子树，返回true</span><br><span class="line">        if(root2==nullptr)</span><br><span class="line">            return true;</span><br><span class="line">        //如果root1先返回，表示root2不是root1的子树</span><br><span class="line">        if(root1==nullptr)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(root1-&gt;val != root2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果两个值相等，再比较他们的左右节点</span><br><span class="line">        return isSameStruct(root1-&gt;left,root2-&gt;left) &amp;&amp; isSameStruct(root1-&gt;right,root2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树）：112-路径总和"><a href="#LeetCode练习（树）：112-路径总和" class="headerlink" title="LeetCode练习（树）：112.路径总和"></a><strong>LeetCode练习（树）：112.路径总和</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/07/剑指Offer——17.树的子结构/17_112.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：经典的用queue来迭代完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">           return false;</span><br><span class="line">        </span><br><span class="line">        queue&lt;int&gt; save_value;</span><br><span class="line">        queue&lt;TreeNode*&gt; save_node;</span><br><span class="line">        save_node.push(root);</span><br><span class="line">        save_value.push(root-&gt;val);</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while(!save_node.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=save_node.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=save_node.front();</span><br><span class="line">                int temp_value=save_value.front();</span><br><span class="line">                save_node.pop();</span><br><span class="line">                save_value.pop();</span><br><span class="line">                if(temp-&gt;left==nullptr &amp;&amp; temp-&gt;right==nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(temp_value);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    save_node.push(temp-&gt;left);</span><br><span class="line">                    save_value.push(temp-&gt;left-&gt;val+temp_value);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right!=nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    save_node.push(temp-&gt;right);</span><br><span class="line">                    save_value.push(temp-&gt;right-&gt;val+temp_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;::iterator ptr=find(res.begin(),res.end(),sum);</span><br><span class="line">        return (ptr==res.end())?false:true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组）：198-打家劫舍"><a href="#LeetCode练习（数组）：198-打家劫舍" class="headerlink" title="LeetCode练习（数组）：198.打家劫舍"></a><strong>LeetCode练习（数组）：198.打家劫舍</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/07/剑指Offer——17.树的子结构/17_198.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>思路：动态规划类型题目关键在于找到状态转移方程设f(n)表示劫犯遍历完第n家共获得的最高金额若偷第n家，那么第n-1家必然不能偷，所以f(n)=nums[n]+f(n-2);若不偷第n家，那么遍历完第n家所获得最大金额就等于遍历完第n-1家所获得最大金额，即f(n)=f(n-1);综上，若想f(n)最大，则得出状态转移方程f(n)=max(nums[n]+f(n-2),f(n-1));</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        else if(len==1)</span><br><span class="line">           return nums[0];</span><br><span class="line"></span><br><span class="line">        int a=0,b=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=max(nums[i]+a,b);</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（滑动窗口）：面试题57-II-和为s的连续正数序列"><a href="#LeetCode练习（滑动窗口）：面试题57-II-和为s的连续正数序列" class="headerlink" title="LeetCode练习（滑动窗口）：面试题57-II.和为s的连续正数序列"></a><strong>LeetCode练习（滑动窗口）：面试题57-II.和为s的连续正数序列</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>利用滑动窗口求解的题目，要注意<em>循环退出条件</em>，还有<em>窗口的边界</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        if(target==0)</span><br><span class="line">           return res;</span><br><span class="line">        </span><br><span class="line">        int left=1,right=1;</span><br><span class="line">        int border=target/2 + 1;</span><br><span class="line">        int sum=0;</span><br><span class="line">        while(left &lt; border)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;else if(sum &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum-=left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;int&gt; temp;</span><br><span class="line">                for(int i=left;i&lt;right;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                sum+=right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两棵二叉树A、B，判断B是不是A的子结构（约定：空树不是任意一个数的子结构）
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——16.合并两个排序的链表（70-121-1103）</title>
    <link href="http://hustxxj.github.io/2020/03/05/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9416.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/03/05/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9416.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-05T07:07:27.000Z</published>
    <updated>2020-03-07T13:26:58.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两个单调递增的链表，输出两个链表合成后的链表，合成后的链表满足单调不减规则。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p><em>略</em></p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead1==nullptr)</span><br><span class="line">            return pHead2;</span><br><span class="line">        else if(pHead2==nullptr)</span><br><span class="line">            return pHead1;</span><br><span class="line">        </span><br><span class="line">        ListNode* f_head=new ListNode(-1);</span><br><span class="line">        ListNode* f_ptr=f_head;</span><br><span class="line">        ListNode* ptr1=pHead1;</span><br><span class="line">        ListNode* ptr2=pHead2;</span><br><span class="line">        while(ptr1 &amp;&amp; ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp_node;</span><br><span class="line">            if(ptr1-&gt;val &lt;= ptr2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_node=ptr1;</span><br><span class="line">                ptr1=ptr1-&gt;next;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                temp_node=ptr2;</span><br><span class="line">                ptr2=ptr2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            f_ptr-&gt;next=temp_node;</span><br><span class="line">            f_ptr=temp_node;</span><br><span class="line">        &#125;</span><br><span class="line">        f_ptr-&gt;next=(ptr1)?ptr1:ptr2;</span><br><span class="line">        return f_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：1103-分糖果II"><a href="#LeetCode练习（动态规划）：1103-分糖果II" class="headerlink" title="LeetCode练习（动态规划）：1103.分糖果II"></a><strong>LeetCode练习（动态规划）：1103.分糖果II</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/05/剑指Offer——16.合并两个排序的链表/16_1103.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; distributeCandies(int candies, int num_people) &#123;</span><br><span class="line">        vector&lt;int&gt; res(num_people);</span><br><span class="line">        if(num_people==1)</span><br><span class="line">        &#123;</span><br><span class="line">            res[0]=candies;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int num_candy=1;</span><br><span class="line">        for(int i=0;i&lt;num_people;i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            if(candies&gt;=num_candy)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]+=num_candy;</span><br><span class="line">                candies-=num_candy;</span><br><span class="line">                num_candy++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]+=candies;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(i==num_people-1)</span><br><span class="line">                i=-1;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：70-爬楼梯"><a href="#LeetCode练习（动态规划）：70-爬楼梯" class="headerlink" title="LeetCode练习（动态规划）：70.爬楼梯"></a><strong>LeetCode练习（动态规划）：70.爬楼梯</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>该题与青蛙跳台阶一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n==1 || n==2)</span><br><span class="line">           return n;</span><br><span class="line">        </span><br><span class="line">        int a=1,b=2;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=3;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（动态规划）：121-买卖股票的最佳时机"><a href="#LeetCode练习（动态规划）：121-买卖股票的最佳时机" class="headerlink" title="LeetCode练习（动态规划）：121.买卖股票的最佳时机"></a><strong>LeetCode练习（动态规划）：121.买卖股票的最佳时机</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/05/剑指Offer——16.合并两个排序的链表/16_121.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>dp[i][0]:第i天，不持股，手上所得最大利润dp[i][1]:第i天，持股，手上所得最大利润</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int len=prices.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int dp_i_0=0,dp_i_1=INT_MIN; //初始化，dp_i_0=0表示-1天未持股所能获得最大利润，dp_i_1=INT_MIN表示-1天持股所能获得最大利润为不可能事件</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_i_0=max(dp_i_0,dp_i_1+prices[i]);</span><br><span class="line">            dp_i_1=max(dp_i_1,-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp_i_0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，合成后的链表满足单调不减规则。
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——15.反转链表（53-66-994）</title>
    <link href="http://hustxxj.github.io/2020/03/04/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9415.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/03/04/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9415.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-04T07:02:12.000Z</published>
    <updated>2020-03-07T13:26:33.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个链表，反转链表后，输出新链表的表头。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>常规的利用双指针实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        if(pHead==nullptr || pHead-&gt;next==nullptr)</span><br><span class="line">            return pHead;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre_node=pHead;</span><br><span class="line">        ListNode* bak_node=NULL;</span><br><span class="line">        </span><br><span class="line">        while(pre_node-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp_node=pre_node-&gt;next;</span><br><span class="line">            pre_node-&gt;next=bak_node;</span><br><span class="line">            bak_node=pre_node;</span><br><span class="line">            pre_node=temp_node;</span><br><span class="line">        &#125;</span><br><span class="line">        pre_node-&gt;next=bak_node;</span><br><span class="line">        return pre_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：66-加一"><a href="#LeetCode练习（数组）：66-加一" class="headerlink" title="LeetCode练习（数组）：66.加一"></a><strong>LeetCode练习（数组）：66.加一</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/04/剑指Offer——15.反转链表/15_66.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：该题如果想先将数组中的元素转换为整数，加1后再重新转换为数组，这种思路会受整数范围的限制造成溢出的问题。所以还是应该在原数组上进行更改，只是要特别考虑几种情况。例如输入【9,9,9】，输出则是【1,0,0,0】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;</span><br><span class="line">        int len=digits.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; res;</span><br><span class="line">            res.push_back(1);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(digits[len-1]&lt;9)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[len-1]=digits[len-1]+1;</span><br><span class="line">            return digits;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            int ptr=len-1;</span><br><span class="line">            while(digits[ptr]==9)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[ptr]=0;</span><br><span class="line">                ptr--;</span><br><span class="line">                if(ptr&lt;0)</span><br><span class="line">                   break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ptr&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[ptr]+=1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                digits.push_back(1);</span><br><span class="line">                reverse(digits.begin(),digits.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（广度优先搜索）：994-腐烂的橘子"><a href="#LeetCode练习（广度优先搜索）：994-腐烂的橘子" class="headerlink" title="LeetCode练习（广度优先搜索）：994.腐烂的橘子"></a><strong>LeetCode练习（广度优先搜索）：994.腐烂的橘子</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/04/剑指Offer——15.反转链表/15_994.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>队列实现 BFS 的方法相对固定，大致分三步：</p><pre><code>初始化队列；最开始的坏橘子全部入队，具体是橘子的坐标和 timetimetime；循环：当队列不为空时，先弹出队首元素，然后将这个元素能够腐烂的橘子全部入队。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int arr[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">public:</span><br><span class="line">    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int row = grid.size();</span><br><span class="line">        if(row == 0) return -1;</span><br><span class="line">        int col = grid[0].size();</span><br><span class="line">        list&lt;pair&lt;int, int&gt;&gt; que;</span><br><span class="line">        int fresh = 0;</span><br><span class="line">        for(int i = 0; i &lt; row; ++i)</span><br><span class="line">            for(int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">                if(grid[i][j] == 2) &#123;</span><br><span class="line">                    que.push_back(make_pair(i, j));</span><br><span class="line">                    grid[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(grid[i][j] == 1)</span><br><span class="line">                    ++fresh;</span><br><span class="line">            &#125;</span><br><span class="line">        if(!fresh) return 0;</span><br><span class="line">        int res = -1;</span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            int nums = que.size();</span><br><span class="line">            ++res;</span><br><span class="line">            while(nums--) &#123;</span><br><span class="line">                int cur_i = que.front().first;</span><br><span class="line">                int cur_j = que.front().second;</span><br><span class="line">                que.pop_front();</span><br><span class="line">                for(int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                    int i = cur_i + arr[k][0];</span><br><span class="line">                    int j = cur_j + arr[k][1];</span><br><span class="line">                    if(i &lt; 0 || j &lt; 0 || i &gt;= row || j &gt;= col)</span><br><span class="line">                        continue;</span><br><span class="line">                    if(grid[i][j]) &#123;</span><br><span class="line">                        que.push_back(make_pair(i, j));</span><br><span class="line">                        grid[i][j] = 0;</span><br><span class="line">                        --fresh;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return fresh ? -1 : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-动态规划）：53-最大子序和"><a href="#LeetCode练习（数组-动态规划）：53-最大子序和" class="headerlink" title="LeetCode练习（数组/动态规划）：53.最大子序和"></a><strong>LeetCode练习（数组/动态规划）：53.最大子序和</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/04/剑指Offer——15.反转链表/15_53.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果时间复杂度：O(n)以【-2,1,-3,4,-1,2,1】为例:初始化：最大连续子序列【-2】，最大值-2，当前序列【 】；第一轮：最大连续子序列【-2】，最大值-2，当前序列【-2】；第二轮：最大连续子序列【1】，最大值1，当前序列【1】；第三轮：最大连续子序列【1】，最大值1，当前序列【1，-3】；第四轮：最大连续子序列【4】，最大值4，当前序列【4】；第五轮：最大连续子序列【4】，最大值4，当前序列【4，-1】；第六轮：最大连续子序列【4，-1，2】，最大值5，当前序列【4，-1，2】；第七轮：最大连续子序列【4，-1，2，1】，最大值6，当前序列【4，-1，2，1】；</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        if(len==1)</span><br><span class="line">           return nums[0];</span><br><span class="line">        </span><br><span class="line">        int sum=0,ans=nums[0];</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sum&lt;=0)    </span><br><span class="line">            &#123;</span><br><span class="line">            //若sum&lt;=0，说明不存在增益了，那不如直接替换成当前元素，从当前元素开始重新计算</span><br><span class="line">                sum=nums[i];     </span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">            //sum&gt;0，说明当前sum对于后续数组依然存在增益</span><br><span class="line">                sum+=nums[i];    </span><br><span class="line">            &#125;</span><br><span class="line">            ans=(ans&gt;=sum)?ans:sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——14.链表中倒数第K个结点（14-26-27）</title>
    <link href="http://hustxxj.github.io/2020/03/03/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9414.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://hustxxj.github.io/2020/03/03/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9414.%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2020-03-03T06:59:54.068Z</published>
    <updated>2020-03-07T13:20:49.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个链表，输出该链表中倒数第K个结点。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用双指针实现，求倒数第K个结点，可以先定义一个指针pre指向正数第K个结点，然后定义一个bak指向头结点。然后两个指针同时前移，当pre为NULL时，对应的bak正好指向倒数第K个结点。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        if(pListHead==nullptr || k==0)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        int len=0;</span><br><span class="line">        ListNode* c_node=pListHead;</span><br><span class="line">        while(c_node)</span><br><span class="line">        &#123;</span><br><span class="line">            c_node=c_node-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(k&gt;len)</span><br><span class="line">            return nullptr;</span><br><span class="line">        else if(k==len)</span><br><span class="line">            return pListHead;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre_node=pListHead;</span><br><span class="line">        ListNode* bak_node=pListHead;</span><br><span class="line">        while(pre_node)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_node=pre_node-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">            if(k==0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        while(pre_node)</span><br><span class="line">        &#123;</span><br><span class="line">            bak_node=bak_node-&gt;next;</span><br><span class="line">            pre_node=pre_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return bak_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-双指针）：26-删除排序数组中的重复项"><a href="#LeetCode练习（数组-双指针）：26-删除排序数组中的重复项" class="headerlink" title="LeetCode练习（数组/双指针）：26.删除排序数组中的重复项"></a><strong>LeetCode练习（数组/双指针）：26.删除排序数组中的重复项</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/03/剑指Offer——14.链表中倒数第K个结点/14_26.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return len;</span><br><span class="line">        </span><br><span class="line">        int res=1;</span><br><span class="line">        int current_num=0;</span><br><span class="line">        vector&lt;int&gt;::iterator it=nums.begin();</span><br><span class="line">        for(int i=1;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]!=nums[current_num])</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                current_num=i;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                nums.erase(it+i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：14-最长公共前缀"><a href="#LeetCode练习（字符串）：14-最长公共前缀" class="headerlink" title="LeetCode练习（字符串）：14.最长公共前缀"></a><strong>LeetCode练习（字符串）：14.最长公共前缀</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/03/剑指Offer——14.链表中倒数第K个结点/14_14.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>注意理解题意，这里是求最长公共<em>前缀</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        if(strs.size()==0)</span><br><span class="line">           return res;</span><br><span class="line">        else if(strs.size()==1)</span><br><span class="line">           return strs[0];</span><br><span class="line">        </span><br><span class="line">        int a_size=(strs[0].size()&gt;=strs[1].size())?strs[1].size():strs[0].size();</span><br><span class="line">        for(int i=0;i&lt;a_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(strs[0][i]!=strs[1][i])</span><br><span class="line">                break;</span><br><span class="line">            else</span><br><span class="line">                res.push_back(strs[0][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=2;i&lt;strs.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp;</span><br><span class="line">            for(int j=0;j&lt;res.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(strs[i][j]==res[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(strs[i][j]);</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（数组-双指针）：27-移除元素"><a href="#LeetCode练习（数组-双指针）：27-移除元素" class="headerlink" title="LeetCode练习（数组/双指针）：27.移除元素"></a><strong>LeetCode练习（数组/双指针）：27.移除元素</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/03/剑指Offer——14.链表中倒数第K个结点/14_27.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        vector&lt;int&gt;::iterator it=nums.begin();</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.erase(it+i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第K个结点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;解
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer——13.调整数组顺序使奇数位于偶数前面（392-1046-1221）</title>
    <link href="http://hustxxj.github.io/2020/03/02/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9413.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <id>http://hustxxj.github.io/2020/03/02/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9413.%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</id>
    <published>2020-03-02T03:49:26.000Z</published>
    <updated>2020-03-07T13:25:16.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>用两个栈来实现，定义两个栈，将数组中的元素根据奇偶分别放入两个栈中，然后再重新放回数组。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">        int len=array.size();</span><br><span class="line">        stack&lt;int&gt; ji,ou;</span><br><span class="line">        for(int i=len-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(array[i] &amp; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                ji.push(array[i]);</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ou.push(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            array.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        while(!ji.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            array.push_back(ji.top());</span><br><span class="line">            ji.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while(!ou.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            array.push_back(ou.top());</span><br><span class="line">            ou.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（贪心算法）：392-判断子序列"><a href="#LeetCode练习（贪心算法）：392-判断子序列" class="headerlink" title="LeetCode练习（贪心算法）：392.判断子序列"></a><strong>LeetCode练习（贪心算法）：392.判断子序列</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/02/剑指Offer——13.调整数组顺序使奇数位于偶数前面/13_392.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：<br>依照次序，对s中的字符，依次在t中寻找相等的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubsequence(string s, string t) &#123;</span><br><span class="line">        if(s.size()==0)</span><br><span class="line">           return true;</span><br><span class="line">        </span><br><span class="line">        int tag=0;</span><br><span class="line">        for(int i=0;i&lt;t.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(t[i]==s[tag])</span><br><span class="line">            &#123;</span><br><span class="line">                tag++;</span><br><span class="line">                if(tag&gt;=s.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（贪心算法）：1221-分割平衡字符串"><a href="#LeetCode练习（贪心算法）：1221-分割平衡字符串" class="headerlink" title="LeetCode练习（贪心算法）：1221.分割平衡字符串"></a><strong>LeetCode练习（贪心算法）：1221.分割平衡字符串</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/02/剑指Offer——13.调整数组顺序使奇数位于偶数前面/13_1221.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>平衡字符串不要求对称，只要求数量R和L相等。例如“RLRRRLLRLL”可以分割成两个“RL”和“RRRLLRLL”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int balancedStringSplit(string s) &#123;</span><br><span class="line">        int Rnum = 0,Lnum = 0,n = 0;</span><br><span class="line">        for(int i = 0;i &lt;s.size();i++)&#123;</span><br><span class="line">            if(s[i] == &apos;R&apos;)</span><br><span class="line">                Rnum++;</span><br><span class="line">            if(s[i] == &apos;L&apos;)</span><br><span class="line">                Lnum++;</span><br><span class="line">            if(Rnum == Lnum)</span><br><span class="line">                n++;</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（贪心算法）：1046-最后一块石头的重量"><a href="#LeetCode练习（贪心算法）：1046-最后一块石头的重量" class="headerlink" title="LeetCode练习（贪心算法）：1046.最后一块石头的重量"></a><strong>LeetCode练习（贪心算法）：1046.最后一块石头的重量</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/02/剑指Offer——13.调整数组顺序使奇数位于偶数前面/13_1046.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>由于每次都需要取最重的两个元素，所以数据每次取出时必须是一个有序排列。如果使用sort每次取出前都排序依次，时间复杂度太高。这里使用了优先队列来解决这个问题。<br>具体的priority_queue底层是用堆来实现的，它将存储在vector或者deque中的数据利用大顶堆这种数据结构重新组织从而实现优先队列的功能。参考链接：<a href="http://c.biancheng.net/view/7010.html" target="_blank" rel="noopener">http://c.biancheng.net/view/7010.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lastStoneWeight(vector&lt;int&gt;&amp; stones) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; pq;</span><br><span class="line">        for(int i:stones)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(pq.size()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            int st1=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            int st2=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            if(st1!=st2)</span><br><span class="line">            &#123;</span><br><span class="line">                int new_stone=abs(st1-st2);</span><br><span class="line">                pq.push(new_stone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return (pq.size()==0)?0:pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——12.数值的整数次方（55-122-225）</title>
    <link href="http://hustxxj.github.io/2020/03/01/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9412.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>http://hustxxj.github.io/2020/03/01/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9412.%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</id>
    <published>2020-03-01T05:22:28.000Z</published>
    <updated>2020-03-07T13:24:51.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0；</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>需要注意exponent为负数的情况</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        double res=1;</span><br><span class="line">        if(base == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        else if(exponent==0)</span><br><span class="line">            return res;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;abs(exponent);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(exponent &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            res=1.0/res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（贪心算法）：225-用队列实现栈"><a href="#LeetCode练习（贪心算法）：225-用队列实现栈" class="headerlink" title="LeetCode练习（贪心算法）：225.用队列实现栈"></a><strong>LeetCode练习（贪心算法）：225.用队列实现栈</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>使用队列实现栈的下列操作：push(x)，pop()，top()，empty();</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><em>队列：queue,数组 ：vector,双向数组：deque,列表：list</em><br>这里要求用队列实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;int&gt; q1;</span><br><span class="line">    queue&lt;int&gt; q2;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        q2.push(x);</span><br><span class="line">        while(!q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q2.push(q1.front());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q1.push(q2.front());</span><br><span class="line">            q2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int res=q1.front();</span><br><span class="line">        q1.pop();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        int res;</span><br><span class="line">        if(q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res=0;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            res=q1.front();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return q1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（贪心算法）：122-买卖股票的最近时机II"><a href="#LeetCode练习（贪心算法）：122-买卖股票的最近时机II" class="headerlink" title="LeetCode练习（贪心算法）：122.买卖股票的最近时机II"></a><strong>LeetCode练习（贪心算法）：122.买卖股票的最近时机II</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获得的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><code><img src="/2020/03/01/剑指Offer——12.数值的整数次方/12_122.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：由于可以知道股票何时涨跌，所以要想赚最多的钱只需要在股票涨的前一天买入，股票跌的前一天卖出即可。</p><ol><li>先买一支股票，那么在哪一天买进呢？从第一天开始，追踪股票涨势，如果第二天涨，则头一天买入。</li><li>买进以后什么时候卖出？从买进当天开始观望，追踪股票涨势，在出现下跌的前一天卖出。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size()&lt;=1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(prices.size()==2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(prices[1]&gt;prices[0])</span><br><span class="line">               return prices[1]-prices[0];</span><br><span class="line">            else</span><br><span class="line">               return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res=0;</span><br><span class="line">        int len=prices.size();</span><br><span class="line">        int buyPrice=0;bool already_buy=false;</span><br><span class="line">        int sailPrice=0;</span><br><span class="line">        for(int i=0;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int bak=prices[i];</span><br><span class="line">            int pre=prices[i+1];</span><br><span class="line">            if(pre&gt;bak &amp;&amp; already_buy==false) //明天股票要涨了，赶快买</span><br><span class="line">            &#123;</span><br><span class="line">                buyPrice=bak;</span><br><span class="line">                already_buy=true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(pre&lt;bak &amp;&amp; already_buy==true) //明天要跌了，赶快卖</span><br><span class="line">            &#123;</span><br><span class="line">                res+=prices[i]-buyPrice;</span><br><span class="line">                already_buy=false;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            if(i==len-2 &amp;&amp; pre&gt;=bak &amp;&amp; already_buy==true)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=pre-buyPrice;  //股市闭市,手上还有股票则全部抛售</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（贪心算法）：55-跳跃游戏"><a href="#LeetCode练习（贪心算法）：55-跳跃游戏" class="headerlink" title="LeetCode练习（贪心算法）：55.跳跃游戏"></a><strong>LeetCode练习（贪心算法）：55.跳跃游戏</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个非负数整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。<br><code><img src="/2020/03/01/剑指Offer——12.数值的整数次方/12_55.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：本题题意有个地方需要理解清楚，不然容易产生混淆。即“每个元素代表你在该位置<em>可以跳跃的最大长度</em>”。并且还有一点，需要前移多少格，由该位置的<em>权重值</em>决定，这个权重值指“位置i+位置的值nums[i]”。只有当该点的权重值大于它所覆盖的每个点的权重值时，才会能走几格走几格，否则会走向它所覆盖的位置中权重最大的点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;len;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0 &amp;&amp; i!=len-1)</span><br><span class="line">               return false;</span><br><span class="line">            </span><br><span class="line">            if(i==len-1)</span><br><span class="line">               return true;</span><br><span class="line"></span><br><span class="line">            if(i+nums[i]&gt;=len-1)</span><br><span class="line">               return true;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int V_Max=i+nums[i];</span><br><span class="line">                for(int j=i+1;j&lt;=i+nums[i];j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(nums[j]+j&gt;V_Max)</span><br><span class="line">                    &#123;</span><br><span class="line">                        i=j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(j==i+nums[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        i+=nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;给定一个double类型的浮点数base和int类型的整数exponent。求b
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——11.二进制中1的个数（83-106-234）</title>
    <link href="http://hustxxj.github.io/2020/02/29/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9411.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/02/29/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9411.%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2020-02-29T07:11:10.000Z</published>
    <updated>2020-03-07T13:24:26.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br>+5（原码：00000101，反码：00000101，补码：00000101）<br>-5（原码：10000101，反码：11111010，补码：11111011）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p><em>整数在内存中是用补码表示的</em><br>用m=1与给的数n逐位&amp;运算，每运行完一次，判断运算结果是否大于0，如果是则计数+1，否则不加。与此同时，m左移一位再次&amp;运算直到m==0为止</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int res=0;</span><br><span class="line">         int flag=1;</span><br><span class="line">         while(flag)</span><br><span class="line">         &#123;</span><br><span class="line">             if(flag &amp; n)</span><br><span class="line">             &#123;</span><br><span class="line">                 res++;</span><br><span class="line">             &#125;</span><br><span class="line">             flag&lt;&lt;=1;</span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：234-回文链表"><a href="#LeetCode练习（链表）：234-回文链表" class="headerlink" title="LeetCode练习（链表）：234.回文链表"></a><strong>LeetCode练习（链表）：234.回文链表</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>请判断一个链表是否为回文链表。<br>示例1：输入1-&gt;2,输出false;输入1-&gt;2-&gt;2-&gt;1,输出true。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：这题可以用deque来实现，先遍历链表将其都放入deque中，然后每次弹出第一个和最后一个元素进行比较，如果不相同则直接返回false。如果直到deque为空还没有返回则返回true。<em>弹出前需要先判断deque中是否还有两个或两个以上元素</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">          return true;</span><br><span class="line">        </span><br><span class="line">        deque&lt;ListNode*&gt; de;</span><br><span class="line">        ListNode* ptr=head;</span><br><span class="line">        while(ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            de.push_back(ptr);</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!de.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            if(de.size()==1)</span><br><span class="line">               break;</span><br><span class="line">            ListNode* begin_node=de[0];</span><br><span class="line">            ListNode* end_node=de[de.size()-1];</span><br><span class="line">            de.pop_back();</span><br><span class="line">            de.pop_front();</span><br><span class="line">            if(begin_node-&gt;val != end_node-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（链表）：106-相交链表"><a href="#LeetCode练习（链表）：106-相交链表" class="headerlink" title="LeetCode练习（链表）：106.相交链表"></a><strong>LeetCode练习（链表）：106.相交链表</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>编写一个程序，找到两个单链表相交的起始节点，要求时间复杂度O(n)，空间复杂度O(1)。如图所示：<br><code><img src="/2020/02/29/剑指Offer——11.二进制中1的个数/11_160.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><code><img src="/2020/02/29/剑指Offer——11.二进制中1的个数/11_160_1.jpg" title="示例图"></code><br><code><img src="/2020/02/29/剑指Offer——11.二进制中1的个数/11_160_2.jpg" title="示例图"></code><br><code><img src="/2020/02/29/剑指Offer——11.二进制中1的个数/11_160_3.jpg" title="示例图"></code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if(headA==nullptr || headB==nullptr)</span><br><span class="line">           return NULL;</span><br><span class="line">        </span><br><span class="line">        ListNode* ptrA=headA;</span><br><span class="line">        ListNode* ptrB=headB;</span><br><span class="line"></span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ptrA==ptrB)</span><br><span class="line">               return ptrA;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ptrA=ptrA-&gt;next;</span><br><span class="line">                ptrB=ptrB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(ptrA==nullptr &amp;&amp; ptrB==nullptr)</span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line">            if(ptrA==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                ptrA=headB;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(ptrB==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                ptrB=headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（链表）：83-删除排序链表中的重复元素"><a href="#LeetCode练习（链表）：83-删除排序链表中的重复元素" class="headerlink" title="LeetCode练习（链表）：83.删除排序链表中的重复元素"></a><strong>LeetCode练习（链表）：83.删除排序链表中的重复元素</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br>例如：输入1-&gt;1-&gt;2-&gt;3-&gt;3，输出1-&gt;2-&gt;3</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>该题可以利用双指针来实现，定义一个前指针和一个后指针，判断两个指针的值是否相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">           return head;</span><br><span class="line"></span><br><span class="line">        ListNode* pre_ptr=head-&gt;next;</span><br><span class="line">        ListNode* bak_ptr=head;</span><br><span class="line">        while(pre_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pre_ptr-&gt;val==bak_ptr-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre_ptr=pre_ptr-&gt;next;</span><br><span class="line">                bak_ptr-&gt;next=pre_ptr;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                pre_ptr=pre_ptr-&gt;next;</span><br><span class="line">                bak_ptr=bak_ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;br&gt;+5（原
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——10.矩形覆盖（24-141-206）</title>
    <link href="http://hustxxj.github.io/2020/02/27/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9410.%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>http://hustxxj.github.io/2020/02/27/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9410.%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</id>
    <published>2020-02-27T06:59:47.000Z</published>
    <updated>2020-03-07T13:24:11.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p> 我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2<em>n的大矩形，总共有多少种方法？比如n=3时，2</em>3的矩形块有3种覆盖方法。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>列举出前几项，可以发现规律：<br>n=1:~1<br>n=2:~2<br>n=3:~3(1-2;1-1)(第一块竖放有2种;第一块横放有1种)<br>n=4:~5(1-3;1-2)<br>n=5:~8(1-5;1-3)</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int number) &#123;</span><br><span class="line">        if(number==0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(number==1)</span><br><span class="line">            return 1;</span><br><span class="line">        if(number==2)</span><br><span class="line">            return 2;</span><br><span class="line">        int a=1,b=2;</span><br><span class="line">        int res;</span><br><span class="line">        for(int i=3;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：206-反转链表"><a href="#LeetCode练习（链表）：206-反转链表" class="headerlink" title="LeetCode练习（链表）：206.反转链表"></a><strong>LeetCode练习（链表）：206.反转链表</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>反转一个单链表，示例：输入1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL;输出5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：<br>使用双指针实现：定义一个pre指针指向head，一个bak指针指向NULL。当pre不为空时，将pre指向bak,然后两个指针都向前移一位，继续执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(head==nullptr)</span><br><span class="line">          return head;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre=head;</span><br><span class="line">        ListNode* bak=NULL;</span><br><span class="line">        while(pre!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp=pre-&gt;next;</span><br><span class="line">            pre-&gt;next=bak;</span><br><span class="line">            bak=pre;</span><br><span class="line">            pre=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return bak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（链表）：24-两两交换链表中的节点"><a href="#LeetCode练习（链表）：24-两两交换链表中的节点" class="headerlink" title="LeetCode练习（链表）：24.两两交换链表中的节点"></a><strong>LeetCode练习（链表）：24.两两交换链表中的节点</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>示例：给定1-&gt;2-&gt;3-&gt;4,你应该返回2-&gt;1-&gt;4-&gt;3</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：利用栈来实现，每次读入两个节点，逐个弹出重新排入一个链表中。<br><em>（注意需要构建一个新节点作为起始节点）</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        if(head==nullptr || head-&gt;next==nullptr) &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">//用stack保存每次迭代的两个节点</span><br><span class="line">stack&lt;ListNode*&gt; s;</span><br><span class="line">ListNode* p = new ListNode(-1);</span><br><span class="line">ListNode* cur = head;</span><br><span class="line">//head指向新的p节点，函数结束时返回head.next即可</span><br><span class="line">head = p;</span><br><span class="line">while(cur!=nullptr &amp;&amp; cur-&gt;next!=nullptr) &#123;</span><br><span class="line">//将两个节点放入stack中</span><br><span class="line">s.push(cur);</span><br><span class="line">s.push(cur-&gt;next);</span><br><span class="line">//当前节点往前走两步</span><br><span class="line">cur = cur-&gt;next-&gt;next;</span><br><span class="line">//从stack中弹出两个节点，然后用p节点指向新弹出的两个节点</span><br><span class="line">p-&gt;next = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">p-&gt;next = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">//注意边界条件，当链表长度是奇数时，cur就不为空</span><br><span class="line">if(cur!=nullptr) &#123;</span><br><span class="line">p-&gt;next = cur;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">p-&gt;next = nullptr;</span><br><span class="line">&#125;</span><br><span class="line">return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（链表）：141-环形链表"><a href="#LeetCode练习（链表）：141-环形链表" class="headerlink" title="LeetCode练习（链表）：141.环形链表"></a><strong>LeetCode练习（链表）：141.环形链表</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个链表，判断链表中是否有环。为了表示给定链表中有环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。如果pos是-1，则在该链表中没有环。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><ol><li>本题判断链表中是否有环，采用的是快慢指针的思想。但是需要特别注意的是，while循环退出的条件。如果快指针为NULL，或者快指针的next为NULL，说明该链表不是环（是环不会一直next也不会出现NULL）。此时退出while循环返回false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if(head==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast_ptr=head;</span><br><span class="line">        ListNode* slow_ptr=head;</span><br><span class="line"></span><br><span class="line">        while(fast_ptr!=nullptr &amp;&amp; fast_ptr-&gt;next!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            slow_ptr=slow_ptr-&gt;next;</span><br><span class="line">            fast_ptr=fast_ptr-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            if(fast_ptr == slow_ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt; 我们可以用2&lt;em&gt;1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2&lt;/e
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——09.变态跳台阶（107-111-226）</title>
    <link href="http://hustxxj.github.io/2020/02/25/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9409.%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://hustxxj.github.io/2020/02/25/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9409.%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2020-02-25T13:15:36.000Z</published>
    <updated>2020-03-07T13:23:39.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>列出前几项可以发现规律：<br>1-1(1);<br>2-1(1):2(1)-(2);<br>3-1(2):2(1):3(1)-(4);<br>4-1(4):2(2):3(1):4(1)-(8);<br>5-1(8):2(4):3(2):4(1):5(1)-(16);</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        return pow(2,number-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树）：226-翻转二叉树"><a href="#LeetCode练习（树）：226-翻转二叉树" class="headerlink" title="LeetCode练习（树）：226.翻转二叉树"></a><strong>LeetCode练习（树）：226.翻转二叉树</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>翻转一棵树<br><code><img src="/2020/02/25/剑指Offer——09.变态跳台阶/09_226.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><ol><li><p>迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode* m=temp-&gt;left;</span><br><span class="line">                temp-&gt;left=temp-&gt;right;</span><br><span class="line">                temp-&gt;right=m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        invert(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void invert(TreeNode* root) //输入根节点，翻转二叉树</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">           return;</span><br><span class="line">        TreeNode* temp=root-&gt;left;</span><br><span class="line">        root-&gt;left=root-&gt;right;</span><br><span class="line">        root-&gt;right=temp;</span><br><span class="line">        invert(root-&gt;left);</span><br><span class="line">        invert(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（树）：111-二叉树的最小深度"><a href="#LeetCode练习（树）：111-二叉树的最小深度" class="headerlink" title="LeetCode练习（树）：111.二叉树的最小深度"></a><strong>LeetCode练习（树）：111.二叉树的最小深度</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>注意：最短路径不等于没有路径，本题和求最大深度有一定区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">          return 0;</span><br><span class="line"></span><br><span class="line">        int left=minDepth(root-&gt;left);</span><br><span class="line">        int right=minDepth(root-&gt;right);</span><br><span class="line">        int min;</span><br><span class="line">        if(root-&gt;left==nullptr || root-&gt;right==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            min=(left==0)?right+1:left+1;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            min=(left&gt;=right)?right+1:left+1;</span><br><span class="line">        &#125; </span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（树）：107-二叉树的层次遍历II"><a href="#LeetCode练习（树）：107-二叉树的层次遍历II" class="headerlink" title="LeetCode练习（树）：107.二叉树的层次遍历II"></a><strong>LeetCode练习（树）：107.二叉树的层次遍历II</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，返回其节点值自底向上的层次遍历。即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; vec;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                vec.push_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer--08.跳台阶（101-102-104）</title>
    <link href="http://hustxxj.github.io/2020/02/24/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9408.%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://hustxxj.github.io/2020/02/24/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9408.%E8%B7%B3%E5%8F%B0%E9%98%B6/</id>
    <published>2020-02-24T04:17:23.000Z</published>
    <updated>2020-03-07T13:23:14.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>1…1<br>2…2(1,1;2)<br>3…3(1,2;2,1)2+1=3<br>4…4(1,3;2,2)3+2=5<br>5…5(1,4;2,3)5+3=8<br>6…6(1,5;2,4)8+5=13</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(number==2)</span><br><span class="line">        &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a=1,b=2;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=3;i&lt;=number;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树-递归）：104-二叉树的最大深度"><a href="#LeetCode练习（树-递归）：104-二叉树的最大深度" class="headerlink" title="LeetCode练习（树/递归）：104.二叉树的最大深度"></a><strong>LeetCode练习（树/递归）：104.二叉树的最大深度</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li><p>递归思路<br>maxDepth(root)：输入根节点，输出根节点到最远叶子节点的深度<br>maxDepth(root-&gt;left)：输入左叶子节点，返回左叶子节点到其最远叶子节点的深度<br>maxDepth(root-&gt;right):输入右叶子节点，返回右叶子节点到其最远叶子节点的深度<br>maxDepth(root)=max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int left=maxDepth(root-&gt;left);</span><br><span class="line">        int right=maxDepth(root-&gt;right);</span><br><span class="line">        int max=(left&gt;=right)?left:right;</span><br><span class="line">        return max+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>迭代思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        int depth=0;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode*  temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                  q.push(temp-&gt;left);</span><br><span class="line">                if(temp-&gt;right != nullptr)</span><br><span class="line">                  q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（树-递归）：101-对称二叉树"><a href="#LeetCode练习（树-递归）：101-对称二叉树" class="headerlink" title="LeetCode练习（树/递归）：101.对称二叉树"></a><strong>LeetCode练习（树/递归）：101.对称二叉树</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，检查它是否是镜像对称的。<br><code><img src="/2020/02/24/剑指Offer——08.跳台阶/08_101.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><ol><li><p>迭代实现<br>逐层迭代，每遍历完一层，比较vector内的数是否中心对称（出现空树用0补齐）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right==nullptr || root-&gt;left==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            if(root-&gt;right==nullptr &amp;&amp; root-&gt;left==nullptr)</span><br><span class="line">              return true;</span><br><span class="line">            else</span><br><span class="line">              return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        q.push(root);</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            for(int i=0;i&lt;(vec.size()/2);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(vec[i] != vec[vec.size()-1-i])</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vec.clear();</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp-&gt;left != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                    vec.push_back(temp-&gt;left-&gt;val);</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    vec.push_back(0);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                    vec.push_back(temp-&gt;right-&gt;val);</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                    vec.push_back(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>递归实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">          return true;</span><br><span class="line">        return issi(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool issi(TreeNode* left,TreeNode* right)   //输入两个节点，返回两节点是否对称</span><br><span class="line">    &#123;</span><br><span class="line">        if(left==nullptr &amp;&amp; right==nullptr)</span><br><span class="line">          return true;</span><br><span class="line">        if(left==nullptr || right==nullptr)</span><br><span class="line">          return false;</span><br><span class="line">        if(left-&gt;val!=right-&gt;val)</span><br><span class="line">          return false;</span><br><span class="line">        else</span><br><span class="line">          return issi(left-&gt;left,right-&gt;right)&amp;&amp;issi(right-&gt;left,left-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（数-迭代）：102-二叉树层次遍历"><a href="#LeetCode练习（数-迭代）：102-二叉树层次遍历" class="headerlink" title="LeetCode练习（数/迭代）：102.二叉树层次遍历"></a><strong>LeetCode练习（数/迭代）：102.二叉树层次遍历</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，返回其层次遍历的节点数。（即逐层的，从左到右访问所有节点）。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">           return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(q.size() != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                temp.push_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left!=nullptr)</span><br><span class="line">                  q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right!=nullptr)</span><br><span class="line">                  q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer--07.斐波那契数列（687-779-f16.11）</title>
    <link href="http://hustxxj.github.io/2020/02/22/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9407.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/02/22/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9407.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2020-02-22T13:19:56.000Z</published>
    <updated>2020-03-07T13:22:44.638Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p>n&lt;=39 </p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><ol><li>递归实现</li><li>循环实现</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><p>循环实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n==1)</span><br><span class="line">            return 1;</span><br><span class="line">        int one=0,two=1,three=0;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            three=one+two;</span><br><span class="line">            one=two;</span><br><span class="line">            two=three;</span><br><span class="line">        &#125;</span><br><span class="line">        return three;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>递归实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n==1 || n==2)</span><br><span class="line">            return 1;</span><br><span class="line">        return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（递归）：687-最长同值路径"><a href="#LeetCode练习（递归）：687-最长同值路径" class="headerlink" title="LeetCode练习（递归）：687.最长同值路径"></a><strong>LeetCode练习（递归）：687.最长同值路径</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。这条路径可以经过也可以不经过根节点。两个节点之间的路径长度由它们之间的边数确定。<br><code><img src="/2020/02/22/剑指Offer——07.斐波那契数列/07_687.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：<br>利用递归的思想，构造一个函数，输入一个节点，返回从这个节点往下<em>与该节点值相同的最长路径值</em>。同时，每进行一次节点的查询，就更新一遍最长相同路径值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    int longestUnivaluePath(TreeNode* root) &#123;</span><br><span class="line">        backDepth(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int backDepth(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left=backDepth(root-&gt;left);</span><br><span class="line">        int right=backDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        left=(root-&gt;left!=NULL &amp;&amp; root-&gt;left-&gt;val==root-&gt;val)?left+1:0;</span><br><span class="line">        right=(root-&gt;right!=NULL &amp;&amp; root-&gt;right-&gt;val==root-&gt;val)?right+1:0;</span><br><span class="line"></span><br><span class="line">        res=(res &gt;= left+right)?res:(left+right);</span><br><span class="line"></span><br><span class="line">        return (left &gt;= right)?left:right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（递归）：面试题16-11-跳水板"><a href="#LeetCode练习（递归）：面试题16-11-跳水板" class="headerlink" title="LeetCode练习（递归）：面试题16.11.跳水板"></a><strong>LeetCode练习（递归）：面试题16.11.跳水板</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter,长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>例如：输入short=1,longer=2,k=3;输出：{3,4,5,6}</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>需要注意当shorter==longer的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; divingBoard(int shorter, int longer, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(k==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if(shorter==longer)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(k);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        int shorter_count=k,longer_count=0;</span><br><span class="line">        for(int i=k;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp=shorter*shorter_count+longer*longer_count;</span><br><span class="line">            shorter_count--;</span><br><span class="line">            longer_count++;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（递归）：779-第K个语法字符"><a href="#LeetCode练习（递归）：779-第K个语法字符" class="headerlink" title="LeetCode练习（递归）：779.第K个语法字符"></a><strong>LeetCode练习（递归）：779.第K个语法字符</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>第N排第K个，如果K&lt;=2^(N-2),则等于N-1排第K个<br>           如果k&gt;2^(N-2),k-2^(N-2),等于N-1排第k-2^(N-2)个取反<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int res=0;</span><br><span class="line">    int kthGrammar(int N, int K) &#123;</span><br><span class="line">        if(N==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(N==2)</span><br><span class="line">        &#123;</span><br><span class="line">            return (K==1)?0:1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(K&lt;=pow(2,N-2))</span><br><span class="line">        &#123;</span><br><span class="line">            res = kthGrammar(N-1,K);</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            K=K-pow(2,N-2);</span><br><span class="line">            res = !kthGrammar(N-1,K); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——06.旋转数组的最小数字（56-75-148）</title>
    <link href="http://hustxxj.github.io/2020/02/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9406.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://hustxxj.github.io/2020/02/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9406.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-20T06:35:31.000Z</published>
    <updated>2020-03-07T13:21:59.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>把一个数组最开始的若干元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1.<br>NOTE：给出的所有元素都大于0，若数组的大小为0，请返回0。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>方法1：利用sort()进行从小到大排序，输出第一个元素。<br>方法2：逐个遍历元素，比较其与下一个元素的大小，若出现大于的情况则返回下一个元素。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><p>方法1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size() == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(rotateArray.begin(),rotateArray.end());</span><br><span class="line">        return rotateArray[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size() == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(rotateArray.size()==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return rotateArray[0];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int res;</span><br><span class="line">        for(int i=0;i&lt;rotateArray.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(rotateArray[i]&gt;rotateArray[i+1])</span><br><span class="line">            &#123;</span><br><span class="line">                res=rotateArray[i+1];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==rotateArray.size()-1)</span><br><span class="line">            &#123;</span><br><span class="line">                res=rotateArray[0];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（查找和排序）：56-合并区间"><a href="#LeetCode练习（查找和排序）：56-合并区间" class="headerlink" title="LeetCode练习（查找和排序）：56.合并区间"></a><strong>LeetCode练习（查找和排序）：56.合并区间</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给出一个区间的集合，请合并所有重叠的区间。<br><code><img src="/2020/02/20/剑指Offer——06.旋转数组的最小数字/6_56.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li><em>先将区间集合按左边界从小到大排序</em></li><li>逐个比较两两区间是否重叠<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        int len=intervals.size();</span><br><span class="line">        </span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">        &#123;</span><br><span class="line">            return intervals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(intervals.begin(), intervals.end(),</span><br><span class="line">            [&amp;, this](vector&lt;int&gt; &amp;v1, vector&lt;int&gt; &amp;v2) &#123; return v1[0] &lt; v2[0];&#125;);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        res.push_back(intervals[0]);</span><br><span class="line">        int ptr=0;</span><br><span class="line">        for(int i=1;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //区间[a1,b1]和区间[a2,b2]有交集分为两种情况</span><br><span class="line">            //1.  a2&lt;=a1&lt;=b2</span><br><span class="line">            //2.  a2&lt;=b1&lt;=b2</span><br><span class="line">            if(res[ptr][0]&gt;=intervals[i][0] &amp;&amp; res[ptr][0]&lt;=intervals[i][1])</span><br><span class="line">            &#123;</span><br><span class="line">                res[ptr][0]=intervals[i][0];</span><br><span class="line">                if(res[ptr][1]&lt;=intervals[i][1])</span><br><span class="line">                &#123;</span><br><span class="line">                    res[ptr][1]=intervals[i][1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(res[ptr][0] &lt;= intervals[i][0] &amp;&amp; res[ptr][1]&gt;=intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                if(res[ptr][1]&lt;=intervals[i][1])</span><br><span class="line">                &#123;</span><br><span class="line">                    res[ptr][1]=intervals[i][1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（查找和排序）：75-颜色分类"><a href="#LeetCode练习（查找和排序）：75-颜色分类" class="headerlink" title="LeetCode练习（查找和排序）：75.颜色分类"></a><strong>LeetCode练习（查找和排序）：75.颜色分类</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个包含红色、白色和蓝色，一共n个元素的数组，原地对它们进行排序，使相同颜色的元素相邻，并按照红色、白色、蓝色顺利排列。此题中，我们使用整数0 ，1和2分别表示红色、白色和蓝色。<br>注意：不能使用代码库中的排序函数来解决这道题。<br>示例：输入：[2,0,2,1,1,0]，输出：[0,0,1,1,2,2]</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; temp0,temp1,temp2;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                temp0.push_back(0);</span><br><span class="line">            &#125;else if(nums[i]==1)</span><br><span class="line">            &#123;</span><br><span class="line">                temp1.push_back(1);</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                temp2.push_back(2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.clear();</span><br><span class="line">        nums.insert(nums.end(),temp0.begin(),temp0.end());</span><br><span class="line">        nums.insert(nums.end(),temp1.begin(),temp1.end());</span><br><span class="line">        nums.insert(nums.end(),temp2.begin(),temp2.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（查找和排序）：148-排序链表"><a href="#LeetCode练习（查找和排序）：148-排序链表" class="headerlink" title="LeetCode练习（查找和排序）：148.排序链表"></a><strong>LeetCode练习（查找和排序）：148.排序链表</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>在O(nlogn)时间复杂度和常数级空间复杂度下，对链表进行排序。<br><code><img src="/2020/02/20/剑指Offer——06.旋转数组的最小数字/6_148.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p><em>(很重要)这里先介绍链表的两个常用操作：merge(l1,l2)和cut(l,n)</em></p><ol><li><p>merge(l1,l2)实现的是链表l1和l2的归并，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ListNode* merge(ListNode* l1,ListNode* l2)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* fakehead=new ListNode(0);</span><br><span class="line">ListNode* p=fakehead;</span><br><span class="line">while(l1 &amp;&amp; l2)</span><br><span class="line">&#123;</span><br><span class="line">if(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next=l1;</span><br><span class="line">p=l1;</span><br><span class="line">l1=l1-&gt;next;</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next=l2;</span><br><span class="line">p=l2;</span><br><span class="line">l2=l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(!l1)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next=l2;</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next=l1;</span><br><span class="line">&#125;</span><br><span class="line">return fakehead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cut(l,n)实现的是将链表l切掉前n个节点，返回后半部分的链表头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListNode* cut(ListNode* head,int n)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* p=head;</span><br><span class="line">while(--n &amp;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">if(p==nullptr)</span><br><span class="line">&#123;</span><br><span class="line">return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* next=p-&gt;next;</span><br><span class="line">p-&gt;next=nullptr;   //注意：不可以省略，为了切断链表</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>回到这道题，由于空间复杂度为常数，所以不能用递归，而是用归并排序来实现：<br>举个简单的例子：[4,3,1,7,8,9,2,11,5,6].<br>step=1: (3-&gt;4)-&gt;(1-&gt;7)-&gt;(8-&gt;9)-&gt;(2-&gt;11)-&gt;(5-&gt;6)<br>step=2: (1-&gt;3-&gt;4-&gt;7)-&gt;(2-&gt;8-&gt;9-&gt;11)-&gt;(5-&gt;6)<br>step=4: (1-&gt;2-&gt;3-&gt;4-&gt;7-&gt;8-&gt;9-&gt;11)-&gt;5-&gt;6<br>step=8: (1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;11)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        ListNode* fakehead=new ListNode(0);</span><br><span class="line">        fakehead-&gt;next = head;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        int length = 0;</span><br><span class="line">        while (p) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int size = 1; size &lt; length; size &lt;&lt;= 1) &#123;</span><br><span class="line">        //size依次等于1,2,4,8,16,.....</span><br><span class="line">            ListNode* cur = fakehead-&gt;next;</span><br><span class="line">            ListNode* tail = fakehead;</span><br><span class="line">            </span><br><span class="line">            while (cur) &#123;</span><br><span class="line">                ListNode* left = cur;</span><br><span class="line">                ListNode* right = cut(left, size);</span><br><span class="line">                cur = cut(right, size);</span><br><span class="line">                </span><br><span class="line">                tail-&gt;next = merge(left, right);</span><br><span class="line">                while (tail-&gt;next) &#123;</span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return fakehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* cut(ListNode* head,int n)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        while(--n &amp;&amp; p)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p==nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* next=p-&gt;next;</span><br><span class="line">        p-&gt;next=nullptr;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* merge(ListNode* l1,ListNode* l2)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* fakehead=new ListNode(0);</span><br><span class="line">        ListNode* p=fakehead;</span><br><span class="line">        while(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=l1;</span><br><span class="line">                p=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=l2;</span><br><span class="line">                p=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!l1)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=l2;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=l1;</span><br><span class="line">        &#125;</span><br><span class="line">        return fakehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;把一个数组最开始的若干元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——05.用两个栈实现队列（20-103-150）</title>
    <link href="http://hustxxj.github.io/2020/02/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9405.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/02/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9405.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-02-17T15:44:50.000Z</published>
    <updated>2020-03-07T13:21:36.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>栈：先进后出<br>队列：先进先出，只能从队尾添加，队头弹出</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            while(stack1.size() != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                int temp=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（栈和队列）：20-有效的括号"><a href="#LeetCode练习（栈和队列）：20-有效的括号" class="headerlink" title="LeetCode练习（栈和队列）：20.有效的括号"></a><strong>LeetCode练习（栈和队列）：20.有效的括号</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个只包括‘（’，‘）’，‘{’，‘}’，‘[’，‘]’的字符串，判断字符串是否有效。<br>有效字符串需满足：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。注意控字符串可被认为是有效字符串。<br>示例：<br>输入：“()” ;输出：true<br>输入：“()[]{}”;输出：true<br>输入：“([)]”;输出：false</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：利用栈来进行判断</p><ol><li>首先对于s为空或者s长度为奇数的情况，直接返回结果</li><li>对于一般情况，建立一个栈，先将s的第一个字符入栈。</li><li>依次遍历s的字符，如果当前字符与栈顶的字符刚好匹配成一对，则栈顶字符出栈，否则当前字符入栈。</li><li>遍历完s后，如果栈为空则返回true，不为空返回false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        if(s.size() == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(s.size() &amp; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;char&gt; sta;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sta.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(s[i]);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(sta.top()==&apos;(&apos; &amp;&amp; s[i]==&apos;)&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(sta.top()==&apos;[&apos; &amp;&amp; s[i]==&apos;]&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(sta.top()==&apos;&#123;&apos; &amp;&amp; s[i]==&apos;&#125;&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sta.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sta.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（栈和队列）：103-二叉树的锯齿形层次遍历"><a href="#LeetCode练习（栈和队列）：103-二叉树的锯齿形层次遍历" class="headerlink" title="LeetCode练习（栈和队列）：103.二叉树的锯齿形层次遍历"></a><strong>LeetCode练习（栈和队列）：103.二叉树的锯齿形层次遍历</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，返回其节点值得锯齿形层次遍历。（即先从左往右，在从右往左进行下一层遍历，依次类推，层与层之间交替进行）<br>例如：给定二叉树[3,9,20,null,null,15,7]，返回锯齿形层次遍历如下：[[3],[20,9],[15,7]]</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：利用<em>queue+deque</em>实现</p><ol><li>从第一排开始逐排遍历树，每遍历完一排就将该排存放入队列q中。</li><li>然后定义一个deque，将队列中的节点弹出放入deque中（单排push_back,双排push_front）。</li><li>最后将deque压入vector，然后遍历下一排。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int signal=1;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int n=q.size();        //不可以省略</span><br><span class="line">            deque&lt;int&gt; temp;</span><br><span class="line">            for(int i=0;i&lt;n;i++)   //这里不能用q.size()代替n</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* p=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(signal &amp; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(p-&gt;val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    temp.push_front(p-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if(p-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(p-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(vector&lt;int&gt;(temp.begin(),temp.end()));</span><br><span class="line">            signal++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（栈和队列）：150-逆波兰表达式求值"><a href="#LeetCode练习（栈和队列）：150-逆波兰表达式求值" class="headerlink" title="LeetCode练习（栈和队列）：150.逆波兰表达式求值"></a><strong>LeetCode练习（栈和队列）：150.逆波兰表达式求值</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>根据逆波兰表示法，求表达式的值。<br>说明：<br>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为0的情况。<br><code><img src="/2020/02/17/剑指Offer——05.用两个栈实现队列/5_150.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li>总体思路比较简单，但是要注意<em>将string类型转换为int类型</em>，以及<em>减法和除法是n2-n1</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int str2num(string s)</span><br><span class="line">    &#123;</span><br><span class="line">        int num;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        ss&gt;&gt;num;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(tokens.size() == 0)</span><br><span class="line">        &#123;</span><br><span class="line">           return res;</span><br><span class="line">        &#125;else if(tokens.size()==1)</span><br><span class="line">        &#123;</span><br><span class="line">           return str2num(tokens[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for(int i=0;i&lt;tokens.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">           if(tokens[i]==&quot;+&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                int n1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int n2=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int temp=n1+n2;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i]==&quot;-&quot;)&#123;</span><br><span class="line">                int n1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int n2=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int temp=n2-n1;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i]==&quot;*&quot;)&#123;</span><br><span class="line">                int n1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int n2=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int temp=n1*n2;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i]==&quot;/&quot;)&#123;</span><br><span class="line">                int n1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int n2=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int temp=(int)n2/n1;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(str2num(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=s.top();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——04.重建二叉树（94-98-100）</title>
    <link href="http://hustxxj.github.io/2020/02/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9404.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://hustxxj.github.io/2020/02/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9404.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-14T12:38:39.000Z</published>
    <updated>2020-03-07T13:21:15.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>本题的关键在于在中序遍历序列中找到根节点的位置，然后就可以根据根节点的位置再将其分为左子树和右子树，最后进行迭代。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.size()==0)</span><br><span class="line">            return NULL;</span><br><span class="line">        TreeNode* Head = new TreeNode(pre[0]);</span><br><span class="line">        vector&lt;int&gt; pre_left,pre_right,vin_left,vin_right;</span><br><span class="line">        int base;</span><br><span class="line">        for(int i=0;i&lt;vin.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(vin[i] == pre[0])</span><br><span class="line">            &#123;</span><br><span class="line">                base = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;base;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_left.push_back(pre[j+1]);</span><br><span class="line">            vin_left.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=base+1;j&lt;vin.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_right.push_back(pre[j]);</span><br><span class="line">            vin_right.push_back(vin[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Head-&gt;left=reConstructBinaryTree(pre_left,vin_left);</span><br><span class="line">        Head-&gt;right=reConstructBinaryTree(pre_right,vin_right);</span><br><span class="line">        </span><br><span class="line">        return Head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（树）：94-二叉树的中序遍历"><a href="#LeetCode练习（树）：94-二叉树的中序遍历" class="headerlink" title="LeetCode练习（树）：94.二叉树的中序遍历"></a><strong>LeetCode练习（树）：94.二叉树的中序遍历</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，返回它的中序遍历。<br>示例：输入[1,null,2,3]，输出[1,3,2]</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><ol><li><p>二叉树的遍历用<em>递归</em>实现起来比较简单，以该题中序遍历来说：（同样对于先序遍历和后序遍历只需要改变代码次序即可。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root-&gt;left != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            inorderTraversal(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;right != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            inorderTraversal(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果想用<em>迭代</em>实现则相对比较复杂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        TreeNode* ptr=root;</span><br><span class="line">        while(ptr || s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(ptr-&gt;val);</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><em>用迭代法实现先序遍历</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        TreeNode* ptr=root;</span><br><span class="line">        while(ptr || s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(ptr-&gt;right);</span><br><span class="line">                res.push_back(ptr-&gt;val);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><em>用迭代法实现后序遍历</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">        TreeNode* ptr=root;</span><br><span class="line">        TreeNode* pre=NULL;</span><br><span class="line">        while(ptr || s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=s.top();</span><br><span class="line">            if(!ptr-&gt;right || pre==ptr-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(ptr-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">                pre=ptr;</span><br><span class="line">                ptr=NULL;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=ptr-&gt;right;</span><br><span class="line">                pre=NULL;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="LeetCode练习（树）：98-验证二叉搜索树"><a href="#LeetCode练习（树）：98-验证二叉搜索树" class="headerlink" title="LeetCode练习（树）：98.验证二叉搜索树"></a><strong>LeetCode练习（树）：98.验证二叉搜索树</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>本题用递归实现，需要注意在遍历树的同时需要保留节点的上界和下界，不仅需要与子节点的值比较，还要与上下界的值比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool compare(TreeNode* root,long min,long max)</span><br><span class="line">    &#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root-&gt;val &lt;= min || root-&gt;val &gt;= max)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return compare(root-&gt;left,min,root-&gt;val) &amp;&amp; compare(root-&gt;right,root-&gt;val,max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isValidBST(struct TreeNode* root)&#123;</span><br><span class="line">      return compare(root,LONG_MIN,LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（树）：100-相同的树"><a href="#LeetCode练习（树）：100-相同的树" class="headerlink" title="LeetCode练习（树）：100.相同的树"></a><strong>LeetCode练习（树）：100.相同的树</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定两个二叉树，编写一个函数来检验他们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>简单的递归实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(p==NULL &amp;&amp; q==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if((p==NULL &amp;&amp; q!=NULL) || (p!=NULL &amp;&amp; q==NULL))</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            if(p-&gt;val != q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
