<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江江的小跟班.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hustxxj.github.io/"/>
  <updated>2020-04-15T11:40:21.994Z</updated>
  <id>http://hustxxj.github.io/</id>
  
  <author>
    <name>Xuxuejie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer——37.数字在排序数组中出现的次数</title>
    <link href="http://hustxxj.github.io/2020/04/15/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9437.%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/04/15/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9437.%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2020-04-15T10:12:28.000Z</published>
    <updated>2020-04-15T11:40:21.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>统计一个数字在排序数组中出现的次数</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>略</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=<span class="built_in">find</span>(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>(),k);</span><br><span class="line">        <span class="keyword">if</span>(it==data.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ini=it-data.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ini;i&lt;data.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]==k)</span><br><span class="line">                ret++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（BFS）：542-01矩阵"><a href="#LeetCode练习（BFS）：542-01矩阵" class="headerlink" title="LeetCode练习（BFS）：542. 01矩阵"></a><strong>LeetCode练习（BFS）：542. 01矩阵</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p>示例 1:<br>输入:</p><p>0 0 0<br>0 1 0<br>0 0 0</p><p>输出:</p><p>0 0 0<br>0 1 0<br>0 0 0</p><p>示例 2:<br>输入:</p><p>0 0 0<br>0 1 0<br>1 1 1</p><p>输出:</p><p>0 0 0<br>0 1 0<br>1 2 1</p><p>注意:</p><pre><code>给定矩阵的元素个数不超过 10000。给定矩阵中至少有一个元素是 0。矩阵中的元素只在四个方向上相邻: 上、下、左、右。</code></pre><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于树的广度优先搜索，可以认为是单源的BFS,因为树只有一个根节点，所以在实现时：首先将root节点入队，再逐层遍历树，将每一层的节点一次入队就行了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">该题则是图的广度优先搜索。对于图的广度优先搜索，可以认为是多源的BFS,它与树的BFS区别有两点：</span></span><br><span class="line"><span class="comment">1. 树只有一个root,而图可以有多个源点，所以首先需要将多个源点都入队列。</span></span><br><span class="line"><span class="comment">2. 树因为本身是有向的，因此不需要标识是否访问过。而图是无向的，所以需要标记是否被访问过。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ag[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)</span><br><span class="line">                     q.push(make_pair(i,j));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   matrix[i][j]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> di=temp.first + ag[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> dj=temp.second + ag[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(di&gt;=<span class="number">0</span> &amp;&amp; di&lt;m &amp;&amp; dj&gt;=<span class="number">0</span> &amp;&amp; dj&lt;n &amp;&amp; matrix[di][dj]==<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[di][dj]=matrix[temp.first][temp.second]+<span class="number">1</span>;</span><br><span class="line">                    q.push(make_pair(di,dj));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（BFS）：559-N叉树的最大深度"><a href="#LeetCode练习（BFS）：559-N叉树的最大深度" class="headerlink" title="LeetCode练习（BFS）：559.N叉树的最大深度"></a><strong>LeetCode练习（BFS）：559.N叉树的最大深度</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 3叉树 :</p><p>​                                  1</p><p>​     2                           3                           4</p><p>5         6</p><p>我们应返回其最大深度，3。</p><p>说明:</p><pre><code>树的深度不会超过 1000。树的节点总不会超过 5000。</code></pre><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">int</span> k=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">vector</span>&lt;Node*&gt; childVec=temp-&gt;children;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;childVec.<span class="built_in">size</span>();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(childVec[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（BFS）：279-完全平方数"><a href="#LeetCode练习（BFS）：279-完全平方数" class="headerlink" title="LeetCode练习（BFS）：279.完全平方数"></a><strong>LeetCode练习（BFS）：279.完全平方数</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例 1:</p><p>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.</p><p>示例 2:</p><p>输入: n = 13<br>输出: 2<br>解释: 13 = 4 + 9.</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将该题看成是N叉树的BFS。子节点的个数等于小于n的完全平方数的个数，子节点的值等于 n-完全平方数 。</span></span><br><span class="line"><span class="comment">当子节点的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(n);</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">int</span> k=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; children;</span><br><span class="line">                <span class="keyword">int</span> ini=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ini*ini &lt; temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                       children.push_back(temp-ini*ini);</span><br><span class="line">                       ini++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(ini*ini==temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> depth;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;children.<span class="built_in">size</span>();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;统计一个数字在排序数组中出现的次数&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;解题思路&quot;
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——36.两个链表的第一个公共节点（25-61-355）</title>
    <link href="http://hustxxj.github.io/2020/04/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9436.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>http://hustxxj.github.io/2020/04/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9436.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2020-04-12T14:10:49.000Z</published>
    <updated>2020-04-13T05:13:24.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两个链表，找出它们的第一个公共结点。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>首先需要注意这里的<strong>第一个公共节点</strong>所指的意义：<strong><em>两个并不是只有一个公共节点，而是从某个公共节点开始，后面的节点全都是完全重合的。</em></strong></p><p>解题思路是：1.找出较长的一个链表</p><p>​                      2.然后将其前面的n个节点截断，使得两个链表一样长。</p><p>​                      3.然后同时从起点开始遍历找到第一个公共节点就退出循环，返回节点。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">nullptr</span> || pHead2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//获得链表1的长度</span></span><br><span class="line">        <span class="keyword">int</span> len1=<span class="number">0</span>;</span><br><span class="line">        ListNode* ptr1=pHead1;</span><br><span class="line">        <span class="keyword">while</span>(ptr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1=ptr1-&gt;next;</span><br><span class="line">            len1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得链表2的长度</span></span><br><span class="line">        <span class="keyword">int</span> len2=<span class="number">0</span>;</span><br><span class="line">        ListNode* ptr2=pHead2;</span><br><span class="line">        <span class="keyword">while</span>(ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr2=ptr2-&gt;next;</span><br><span class="line">            len2++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将长链表的前lenPath切割，使得两个链表一样长</span></span><br><span class="line">        ListNode* longList;</span><br><span class="line">        ListNode* shortList;</span><br><span class="line">        <span class="keyword">int</span> lenPath=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len1 &lt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            longList=pHead2;</span><br><span class="line">            shortList=pHead1;</span><br><span class="line">            lenPath=len2-len1;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            longList=pHead1;</span><br><span class="line">            shortList=pHead2;</span><br><span class="line">            lenPath=len1-len2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenPath;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            longList=longList-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始同时遍历链表，遇到相同结点则退出</span></span><br><span class="line">        <span class="keyword">while</span>(longList!=<span class="literal">nullptr</span> &amp;&amp; shortList!=<span class="literal">nullptr</span> &amp;&amp; longList!=shortList)</span><br><span class="line">        &#123;</span><br><span class="line">            longList=longList-&gt;next;</span><br><span class="line">            shortList=shortList-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> shortList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：61-旋转链表"><a href="#LeetCode练习（链表）：61-旋转链表" class="headerlink" title="LeetCode练习（链表）：61.旋转链表"></a><strong>LeetCode练习（链表）：61.旋转链表</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p><p>示例 2:</p><p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span> || k==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode* ptr1=head;</span><br><span class="line">        <span class="keyword">while</span>(ptr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1=ptr1-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k=k%len;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* ptr2=head;</span><br><span class="line">        ListNode* ptr3=head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-k<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr2=ptr2-&gt;next;  <span class="comment">//ptr2是旋转后的未节点</span></span><br><span class="line">            ptr3=ptr3-&gt;next;  <span class="comment">//从ptr3这个节点开始,后面的节点都是要旋转的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* endNode=ptr2;</span><br><span class="line"></span><br><span class="line">        ListNode* newList=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* resNode=newList;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tempnode=<span class="keyword">new</span> ListNode(ptr3-&gt;val);</span><br><span class="line">            newList-&gt;next=tempnode;</span><br><span class="line">            newList=newList-&gt;next;</span><br><span class="line">            ptr3=ptr3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newList-&gt;next=head;</span><br><span class="line">        endNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：25-K个一组翻转链表"><a href="#LeetCode练习（链表）：25-K个一组翻转链表" class="headerlink" title="LeetCode练习（链表）：25.K个一组翻转链表"></a><strong>LeetCode练习（链表）：25.K个一组翻转链表</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例：</p><p>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>说明：</p><pre><code>你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</code></pre><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span> || k==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftlen=<span class="number">0</span>;</span><br><span class="line">        ListNode* ptr1=head;</span><br><span class="line">        <span class="keyword">while</span>(ptr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1=ptr1-&gt;next;</span><br><span class="line">            leftlen++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *retNode,*lastcheadNode;</span><br><span class="line">        ListNode* currentNode=head;</span><br><span class="line">        ListNode* targetNode=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">bool</span> isFirst=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftlen&gt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tempNode=<span class="literal">NULL</span>;</span><br><span class="line">            ListNode* cheadNode=currentNode;</span><br><span class="line">            <span class="comment">/*原地旋转链表，然后将旋转的链表加回原链表中*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                tempNode=currentNode-&gt;next;</span><br><span class="line">                currentNode-&gt;next=targetNode;</span><br><span class="line">                targetNode=currentNode;</span><br><span class="line">                currentNode=tempNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFirst)</span><br><span class="line">            &#123;</span><br><span class="line">                retNode=targetNode;</span><br><span class="line">                cheadNode-&gt;next=currentNode;</span><br><span class="line">                isFirst=<span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                lastcheadNode-&gt;next=targetNode;</span><br><span class="line">                cheadNode-&gt;next=currentNode;</span><br><span class="line">            &#125;</span><br><span class="line">            lastcheadNode=cheadNode;</span><br><span class="line"></span><br><span class="line">            leftlen-=k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（堆、设计）：355-设计推特"><a href="#LeetCode练习（堆、设计）：355-设计推特" class="headerlink" title="LeetCode练习（堆、设计）：355.设计推特"></a><strong>LeetCode练习（堆、设计）：355.设计推特</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p><pre><code>postTweet(userId, tweetId): 创建一条新的推文getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。follow(followerId, followeeId): 关注一个用户unfollow(followerId, followeeId): 取消关注一个用户</code></pre><p>示例:</p><p>Twitter twitter = new Twitter();</p><p>// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).<br>twitter.postTweet(1, 5);</p><p>// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.<br>twitter.getNewsFeed(1);</p><p>// 用户1关注了用户2.<br>twitter.follow(1, 2);</p><p>// 用户2发送了一个新推文 (推文id = 6).<br>twitter.postTweet(2, 6);</p><p>// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].<br>// 推文id6应当在推文id5之前，因为它是在5之后发送的.<br>twitter.getNewsFeed(1);</p><p>// 用户1取消关注了用户2.<br>twitter.unfollow(1, 2);</p><p>// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.<br>// 因为用户1已经不再关注用户2.<br>twitter.getNewsFeed(1);</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//构建一个510*510的关系网，relationshipMap[i][j]==1表示j关注了i</span></span><br><span class="line">    <span class="keyword">int</span> relationshipMap[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line">    <span class="comment">//双端队列，dq[i]记录第i个用户发送的推特的时间和id</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; dq[<span class="number">510</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> time;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Twitter() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(relationshipMap, <span class="number">0</span>, <span class="keyword">sizeof</span> relationshipMap);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">510</span>; i++) relationshipMap[i][i] = <span class="number">1</span>;<span class="comment">//自己必须关注自己</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">510</span>; i++) dq[i].<span class="built_in">clear</span>();</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        time++;</span><br><span class="line">        <span class="keyword">if</span>(dq[userId].<span class="built_in">size</span>()&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dq[userId].pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        dq[userId].push_back(&#123;time,tweetId&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNewsFeed(<span class="keyword">int</span> userId) &#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;  <span class="comment">//构建一个大顶堆，按时间顺序排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">510</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(relationshipMap[i][userId]==<span class="number">1</span>) <span class="comment">//如果userid关注了i,则将i的推特放入候选队列</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> d:dq[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(d);   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按时间排序，选前10条输出</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>&amp;&amp;q.<span class="built_in">size</span>()&gt;<span class="number">0</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(q.top().second);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        relationshipMap[followeeId][followerId]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(followeeId!=followerId)</span><br><span class="line">           relationshipMap[followeeId][followerId]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Twitter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Twitter* obj = new Twitter();</span></span><br><span class="line"><span class="comment"> * obj-&gt;postTweet(userId,tweetId);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getNewsFeed(userId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;follow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;unfollow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两个链表，找出它们的第一个公共结点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;解题
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——35.数组中的逆序对（151-f13-f01.07）</title>
    <link href="http://hustxxj.github.io/2020/04/10/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9435.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://hustxxj.github.io/2020/04/10/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9435.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2020-04-10T04:04:43.000Z</published>
    <updated>2020-04-10T06:30:11.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例 1:</p><p>输入: [7,5,6,4]<br>输出: 5</p><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 50000</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><ol><li>暴力解法，依次遍历每个数字，比较它与后面数字的大小，看是否为逆序。时间复杂度O(N^2)</li><li>利用归并排序的思想，将数组分为两组，逆序对数量就等于左边组逆序对的数量+右边组逆序对的数量+左右合并逆序对的数量</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            copy.push_back(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans(data,copy,<span class="number">0</span>,data.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">ans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; copy,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> leftcount=ans(copy,data,left,mid);</span><br><span class="line">        <span class="keyword">long</span> rightcount=ans(copy,data,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=mid;</span><br><span class="line">        <span class="keyword">int</span> j=right;</span><br><span class="line">        <span class="keyword">int</span> k=right;</span><br><span class="line">        <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=left &amp;&amp; j&gt;=mid+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                count+=j-mid;</span><br><span class="line">                copy[k--]=data[i--];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                copy[k--]=data[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=left;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[k--]=data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=mid+<span class="number">1</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[k--]=data[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftcount+rightcount+count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：面试题13-机器人的运动范围"><a href="#LeetCode练习（数组）：面试题13-机器人的运动范围" class="headerlink" title="LeetCode练习（数组）：面试题13. 机器人的运动范围"></a><strong>LeetCode练习（数组）：面试题13. 机器人的运动范围</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*注意：并不是只要行列位数之和小于k就一定可以到达</span></span><br><span class="line"><span class="comment">     如果所有可走路径都被封死了,就算位数之和小于k也无*法达到</span></span><br><span class="line"><span class="comment">*p[i][j]能否到达需要满足两个条件：</span></span><br><span class="line"><span class="comment">      1. get(i)+get(j)&lt;=k</span></span><br><span class="line"><span class="comment">      2. mp[i][j-1] or mp[i-1][j]至少有一个可达</span></span><br><span class="line"><span class="comment">*需要注意处理方格边界 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        mp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i<span class="number">-1</span>][<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; <span class="built_in">get</span>(i)&lt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[<span class="number">0</span>][i<span class="number">-1</span>]==<span class="number">1</span> &amp;&amp; <span class="built_in">get</span>(i)&lt;=k)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(i)+<span class="built_in">get</span>(j)&gt;k)</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    mp[i][j]=mp[i<span class="number">-1</span>][j]||mp[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(mp[i][j]==<span class="number">1</span>)</span><br><span class="line">                       ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=num%<span class="number">10</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：151-翻转字符串里的单词"><a href="#LeetCode练习（字符串）：151-翻转字符串里的单词" class="headerlink" title="LeetCode练习（字符串）：151. 翻转字符串里的单词"></a><strong>LeetCode练习（字符串）：151. 翻转字符串里的单词</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：</p><p>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：</p><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：</p><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>说明：</p><pre><code>无空格字符构成一个单词。输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; savestr;</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">bool</span> isreading=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isreading==<span class="literal">false</span> &amp;&amp; s[i]==<span class="string">' '</span>)</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(isreading==<span class="literal">true</span> &amp;&amp; s[i]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                savestr.push_back(str);</span><br><span class="line">                str=<span class="string">""</span>;</span><br><span class="line">                isreading=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isreading=<span class="literal">true</span>;</span><br><span class="line">                str.push_back(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[s.<span class="built_in">size</span>()<span class="number">-1</span>]!=<span class="string">' '</span>)</span><br><span class="line">          savestr.push_back(str);</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(savestr.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=savestr.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=savestr[i];</span><br><span class="line">            res+=<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=savestr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：面试题-01-07-旋转矩阵"><a href="#LeetCode练习（数组）：面试题-01-07-旋转矩阵" class="headerlink" title="LeetCode练习（数组）：面试题 01.07. 旋转矩阵"></a><strong>LeetCode练习（数组）：面试题 01.07. 旋转矩阵</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p><p>不占用额外内存空间能否做到？</p><p>示例 1:</p><p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p><p>示例 2:</p><p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/*1.将矩阵转置*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[j][i];</span><br><span class="line">                matrix[j][i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*2.逐行翻转*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right=N<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][left];</span><br><span class="line">                matrix[i][left]=matrix[i][right];</span><br><span class="line">                matrix[i][right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——34.第一个只出现一次的字符（39-40-51回溯算法）</title>
    <link href="http://hustxxj.github.io/2020/04/05/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9434.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://hustxxj.github.io/2020/04/05/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9434.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</id>
    <published>2020-04-05T04:00:10.000Z</published>
    <updated>2020-04-06T01:33:50.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用hashmap来求解，遍历一遍字符串，记录每个字符出现的次数。输出第一个只出现一次的字符。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[str[i]]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯）：39-数组总和"><a href="#LeetCode练习（回溯）：39-数组总和" class="headerlink" title="LeetCode练习（回溯）：39.数组总和"></a><strong>LeetCode练习（回溯）：39.数组总和</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><pre><code>所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </code></pre><p>示例 1:</p><p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]</p><p>示例 2:</p><p>输入: candidates = [2,3,5], target = 8,<br>所求解集为:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trace;</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        backtrace(trace,candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; trace,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; opt,<span class="keyword">int</span> target,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(addvec(trace)==target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(trace);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;opt.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(addvec(trace)+opt[i] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            trace.push_back(opt[i]);</span><br><span class="line">            backtrace(trace,opt,target,i);</span><br><span class="line">            trace.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addvec</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯）：40-数组总和II"><a href="#LeetCode练习（回溯）：40-数组总和II" class="headerlink" title="LeetCode练习（回溯）：40.数组总和II"></a><strong>LeetCode练习（回溯）：40.数组总和II</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><pre><code>所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 </code></pre><p>示例 1:</p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p><p>示例 2:</p><p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trace;</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        backtrace(trace,candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; trace,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; opt,<span class="keyword">int</span> target,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum(trace)==target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(trace);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;opt.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start<span class="comment">/*这个条件需要重点理解，表示一层只使用这个数字一次*/</span> &amp;&amp; opt[i]==opt[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sum(trace)+opt[i] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            trace.push_back(opt[i]);</span><br><span class="line">            backtrace(trace,opt,target,i+<span class="number">1</span>);</span><br><span class="line">            trace.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯）：51-N皇后"><a href="#LeetCode练习（回溯）：51-N皇后" class="headerlink" title="LeetCode练习（回溯）：51.N皇后"></a><strong>LeetCode练习（回溯）：51.N皇后</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例:</p><p>输入: 4<br>输出: [<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]<br>解释: 4 皇后问题存在两个不同的解法。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trace;</span><br><span class="line">        backtrace(trace,n,<span class="number">-10</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; trace,<span class="keyword">int</span> n,<span class="keyword">int</span> lastchoice)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.<span class="built_in">size</span>()==n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(trans(trace,n));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isInsert=findBind(trace,n,i);</span><br><span class="line">            <span class="keyword">if</span>(isInsert==<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            trace.push_back(i);</span><br><span class="line">            backtrace(trace,n,i);</span><br><span class="line">            trace.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; trans(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tempstr=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==vec[i])</span><br><span class="line">                   tempstr+=<span class="string">"Q"</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   tempstr+=<span class="string">"."</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tempstr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断target位置能否放置皇后，可以返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findBind</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> n,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>((vec[i]-(len-i)) &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i]-len+i==target)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((vec[i]+(len-i)) &lt;= n<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i]+len-i==target)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在一个字符串(0&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)中找到
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——33.丑数（47-77-78回溯算法练习）</title>
    <link href="http://hustxxj.github.io/2020/04/04/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9433.%E4%B8%91%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/04/04/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9433.%E4%B8%91%E6%95%B0/</id>
    <published>2020-04-04T05:12:06.000Z</published>
    <updated>2020-04-05T04:04:14.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p>示例:</p><p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p><p>说明:  </p><pre><code>1 是丑数。n 不超过1690。</code></pre><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>如果用常规思路逐一遍历每一个元素判断其是否为丑数，然后找到第n个丑数，时间复杂度过高。</p><p>可以转换思路：第n个丑数，一定是前n-1个丑数中的某一个<em>2 or </em>3 or *5而来。所以从第一个丑数1开始迭代，将其乘2,3,5找出其中的最小值，作为第二个丑数，依次类推。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; save(n);</span><br><span class="line">        save[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a1=<span class="number">0</span>,a2=<span class="number">0</span>,a3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            save[i]=<span class="built_in">min</span>(save[a1]*<span class="number">2</span>,save[a2]*<span class="number">3</span>,save[a3]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(save[i]==save[a1]*<span class="number">2</span>) a1++;</span><br><span class="line">            <span class="keyword">if</span>(save[i]==save[a2]*<span class="number">3</span>) a2++;</span><br><span class="line">            <span class="keyword">if</span>(save[i]==save[a3]*<span class="number">5</span>) a3++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> save[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a&lt;=b &amp;&amp; a&lt;=c) ans = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b&lt;=a &amp;&amp; b&lt;=c) ans = b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&lt;=a &amp;&amp; c&lt;=b) ans = c;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯）：78-子集"><a href="#LeetCode练习（回溯）：78-子集" class="headerlink" title="LeetCode练习（回溯）：78.子集"></a><strong>LeetCode练习（回溯）：78.子集</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  res;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;   <span class="comment">//记录路径</span></span><br><span class="line">        backtrace(<span class="built_in">stack</span>,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;<span class="built_in">stack</span><span class="comment">/*路径*/</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums<span class="comment">/*选择列表*/</span>,<span class="keyword">int</span> start<span class="comment">/*起点*/</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.push_back(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            <span class="built_in">stack</span>.push_back(nums[i]);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            backtrace(<span class="built_in">stack</span>,nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//取消选择</span></span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯）：77-组合"><a href="#LeetCode练习（回溯）：77-组合" class="headerlink" title="LeetCode练习（回溯）：77.组合"></a><strong>LeetCode练习（回溯）：77.组合</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><p>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trace;</span><br><span class="line">        backtrace(trace,<span class="number">1</span>,n,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; trace,<span class="keyword">int</span> start,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.<span class="built_in">size</span>()==k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(trace);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            trace.push_back(i);</span><br><span class="line">            backtrace(trace,i+<span class="number">1</span>,n,k);</span><br><span class="line">            trace.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯）：47-全排列"><a href="#LeetCode练习（回溯）：47-全排列" class="headerlink" title="LeetCode练习（回溯）：47.全排列"></a><strong>LeetCode练习（回溯）：47.全排列</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*对于全排列的变形，需要用一个数组记录当前路径是否被选择过</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trace;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;  isused(nums.<span class="built_in">size</span>(),<span class="literal">false</span>);</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());   <span class="comment">//进行回溯前需要对数组排序</span></span><br><span class="line">        backtrace(trace,nums,isused);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; trace,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; opt,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; isused)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.<span class="built_in">size</span>()==opt.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(trace);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;opt.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isused[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; opt[i]==opt[i<span class="number">-1</span>] &amp;&amp; !isused[i<span class="number">-1</span>]<span class="comment">/*很重要，如果当前数字和上一个数字一样，那么他们的全排列也相同，所以直接跳过该数字，注意这里的isused[i-1]要判断前一个数字是否被使用过，只有前一个数字没有被使用过才说明这是回溯的第一层*/</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            trace.push_back(opt[i]);</span><br><span class="line">            isused[i]=<span class="literal">true</span>;</span><br><span class="line">            backtrace(trace,opt,isused);</span><br><span class="line">            trace.pop_back();</span><br><span class="line">            isused[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——32.把数组排成最小的数（48-69-289）</title>
    <link href="http://hustxxj.github.io/2020/04/02/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9432.%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/04/02/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9432.%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</id>
    <published>2020-04-02T02:51:27.000Z</published>
    <updated>2020-04-03T02:14:07.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>需要理解灵活使用sort()函数的用法</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> B=<span class="string">""</span>;</span><br><span class="line">        A+=to_string(a);</span><br><span class="line">        A+=to_string(b);</span><br><span class="line">        B+=to_string(b);</span><br><span class="line">        B+=to_string(a);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> A&lt;B;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">""</span>;</span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(),numbers.<span class="built_in">end</span>(),compare);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：289-生命游戏"><a href="#LeetCode练习（数组）：289-生命游戏" class="headerlink" title="LeetCode练习（数组）：289.生命游戏"></a><strong>LeetCode练习（数组）：289.生命游戏</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><pre><code>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</code></pre><p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>示例：</p><p>输入：<br>[<br>  [0,1,0],<br>  [0,0,1],<br>  [1,1,1],<br>  [0,0,0]<br>]<br>输出：<br>[<br>  [0,0,0],<br>  [1,0,1],<br>  [0,1,1],<br>  [0,1,0]<br>]</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=board.<span class="built_in">size</span>()+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n=board[<span class="number">0</span>].<span class="built_in">size</span>()+<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; copy(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;m<span class="number">-2</span> &amp;&amp; j&lt;n<span class="number">-2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j]==<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        copy[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> livecount=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> dir:dirs)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> dx=i+<span class="number">1</span>+dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> dy=j+<span class="number">1</span>+dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(copy[dx][dy]==<span class="number">1</span>)</span><br><span class="line">                       livecount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(livecount&lt;<span class="number">2</span> &amp;&amp; board[i][j]==<span class="number">1</span>)</span><br><span class="line">                    board[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(livecount&gt;<span class="number">3</span> &amp;&amp; board[i][j]==<span class="number">1</span>)</span><br><span class="line">                    board[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(livecount==<span class="number">3</span> &amp;&amp; board[i][j]==<span class="number">0</span>)</span><br><span class="line">                    board[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：48-旋转图像"><a href="#LeetCode练习（数组）：48-旋转图像" class="headerlink" title="LeetCode练习（数组）：48.旋转图像"></a><strong>LeetCode练习（数组）：48.旋转图像</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:</p><p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 首先对矩阵进行转职</span></span><br><span class="line"><span class="comment">[                                                  [</span></span><br><span class="line"><span class="comment">  [1,2,3],                                            [1,4,7]</span></span><br><span class="line"><span class="comment">  [4,5,6],          ----------------------------&gt;     [2,5,8]</span></span><br><span class="line"><span class="comment">  [7,8,9]                                             [3,6,9]</span></span><br><span class="line"><span class="comment">],                                                 ]</span></span><br><span class="line"><span class="comment">* 然后再对转置后的矩阵逐行翻转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[j][i];</span><br><span class="line">                matrix[j][i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][l];</span><br><span class="line">                matrix[i][l]=matrix[i][r];</span><br><span class="line">                matrix[i][r]=temp;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：69-x的平方根"><a href="#LeetCode练习（数组）：69-x的平方根" class="headerlink" title="LeetCode练习（数组）：69.x的平方根"></a><strong>LeetCode练习（数组）：69.x的平方根</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2</p><p>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*需要注意以下几点：1. 使用二分查找可以提高效率</span></span><br><span class="line"><span class="comment">                 2. 判断中位数的平方是否等于目标值x时，用mid*mid==x会导致越界，应该                     使用mid==mid/x</span></span><br><span class="line"><span class="comment">                 3. x==1的情况不能忽略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=x;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid == x/mid)</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mid &lt; x/mid)</span><br><span class="line">                &#123;</span><br><span class="line">                    l=mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; x/mid)</span><br><span class="line">                &#123;</span><br><span class="line">                    r=mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://hustxxj.github.io/2020/04/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://hustxxj.github.io/2020/04/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-04-01T10:27:25.000Z</published>
    <updated>2020-04-02T02:11:27.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h1><hr><p>平衡二叉树是对二叉排序树的改进，由于二叉排序树在某些情况下会退化为链表，为了解决二叉排序树存在的这个问题，于是规定了<strong><em>平衡二叉树任意结点的左右子树的高度差不能超过1</em></strong>。</p><p>有关平衡二叉树的两个概念：</p><p>1&gt;平衡因子：</p><p>平衡二叉树上结点左子树的高度减去右子树的高度称为该结点的平衡因子BF（Balance Factor）。BF的取值范围为[-1,1]，如果发现某个结点的BF不在这个范围，就需要对树进行调整。</p><p>2&gt;最小不平衡子树：</p><p>插入一个结点后，距离插入结点最近的，且平衡因子不在[-1,1]范围的结点。</p><p><code><img src="/2020/04/01/平衡二叉树/pic0.jpg" title="示例图"></code></p><p>二叉排序树是如何进化为平衡二叉树的呢？答案是：<strong><em>旋转</em></strong></p><p>在介绍如何将一个失衡的二叉排序树旋转为一个平衡二叉树之前，首先介绍二叉排序树失衡的四种情况：</p><blockquote><p>LL型：根节点的左子树的左子树过深导致失衡状态</p></blockquote><blockquote><p>LR型：根节点的左子树的右子树过深导致失衡状态</p></blockquote><blockquote><p>RL型：根节点的右子树的左子树过深导致失衡状态</p></blockquote><blockquote><p>RR型：根节点的右子树的右子树过深导致失衡状态</p></blockquote><p><code><img src="/2020/04/01/平衡二叉树/pic1.jpg" title="示例图"></code></p><p>对于每种情况导致的失衡，旋转的策略也不相同。</p><hr><h2 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a><strong>平衡二叉树的调整</strong></h2><p><strong>参考博客</strong>：<em><a href="https://blog.csdn.net/isunbin/article/details/81707606" target="_blank" rel="noopener">https://blog.csdn.net/isunbin/article/details/81707606</a></em></p><p>定义平衡二叉树的结点结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure><h3 id="LL型失衡调整"><a href="#LL型失衡调整" class="headerlink" title="LL型失衡调整"></a><strong>LL型失衡调整</strong></h3><p><code><img src="/2020/04/01/平衡二叉树/pic2.jpg" title="示例图"></code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">LL_Rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x;</span><br><span class="line">    x=y-&gt;left;</span><br><span class="line">    y-&gt;left=x-&gt;right;</span><br><span class="line">    x-&gt;right=y;</span><br><span class="line">    </span><br><span class="line">    y-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left),<span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left),<span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RR型失衡调整"><a href="#RR型失衡调整" class="headerlink" title="RR型失衡调整"></a><strong>RR型失衡调整</strong></h3><p><code><img src="/2020/04/01/平衡二叉树/pic3.jpg" title="示例图"></code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">RR_Rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x;</span><br><span class="line">    x=y-&gt;right;</span><br><span class="line">    y-&gt;right=x-&gt;left;</span><br><span class="line">    x-&gt;left=y;</span><br><span class="line">    </span><br><span class="line">    y-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left),<span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left),<span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LR型调整"><a href="#LR型调整" class="headerlink" title="LR型调整"></a><strong>LR型调整</strong></h3><p><code><img src="/2020/04/01/平衡二叉树/pic4.jpg" title="示例图"></code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">LR_Rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x=y-&gt;left;</span><br><span class="line">    y-&gt;left=RR_Rotate(x);</span><br><span class="line">    <span class="keyword">return</span> LL_Rotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RL型调整"><a href="#RL型调整" class="headerlink" title="RL型调整"></a><strong>RL型调整</strong></h3><p><code><img src="/2020/04/01/平衡二叉树/pic5.jpg" title="示例图"></code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">RL_Rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* x=y-&gt;right;</span><br><span class="line">    y-&gt;right=LL_Rotate(x);</span><br><span class="line">    <span class="keyword">return</span> RR_Rotate(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="平衡二叉树实现实例"><a href="#平衡二叉树实现实例" class="headerlink" title="平衡二叉树实现实例"></a><strong>平衡二叉树实现实例</strong></h2><h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a><strong>平衡二叉树的插入</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct Node *N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)   <span class="comment">//这一步很重要</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> = (<span class="title">BTNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">LL_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line"> </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">RR_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;right;</span><br><span class="line">    y-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left = y;</span><br><span class="line"> </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(BTNode* N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)  <span class="comment">//这一步很重要</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(N-&gt;left) - <span class="built_in">height</span>(N-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//向平衡二叉树中插入值为key的节点，返回二叉树的根节点</span></span><br><span class="line"><span class="function">BTNode* <span class="title">insert</span><span class="params">(BTNode* node<span class="comment">/*平衡二叉树根节点*/</span>, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*part1:常规判断根节点是否为NULL，为空则新建一个节点*/</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode(key);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*part2:迭代找出需要添加节点的位置*/</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*part3:判断二叉树是否还是平衡二叉树，不平衡则旋转*/</span></span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> LL_rotate(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)     <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> RR_rotate(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key)     <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;left = RR_rotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> LL_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key)     <span class="comment">//RL型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;right = LL_rotate(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> RR_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *root = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    root = insert(root, <span class="number">2</span>);</span><br><span class="line">    root = insert(root, <span class="number">1</span>);</span><br><span class="line">    root = insert(root, <span class="number">0</span>);</span><br><span class="line">    root = insert(root, <span class="number">3</span>);</span><br><span class="line">    root = insert(root, <span class="number">4</span>);</span><br><span class="line">    root = insert(root, <span class="number">4</span>);</span><br><span class="line">    root = insert(root, <span class="number">5</span>);</span><br><span class="line">    root = insert(root, <span class="number">6</span>);</span><br><span class="line">    root = insert(root, <span class="number">9</span>);</span><br><span class="line">    root = insert(root, <span class="number">8</span>);</span><br><span class="line">    root = insert(root, <span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历："</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><strong>删除节点</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">minValueNode</span><span class="params">(BTNode* node)</span>   <span class="comment">//返回最左叶子节点（值最小的点）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* current = node;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        current=current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除平衡二叉树中值为key的节点，返回平衡二叉树的根节点</span></span><br><span class="line"><span class="function">BTNode* <span class="title">deleteNode</span><span class="params">(BTNode* root<span class="comment">/*平衡二叉树根节点*/</span>,<span class="keyword">int</span> key)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*part1:常规判断根节点是否为NULL，为NULL则返回NULL*/</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*part2:迭代找出需要删除节点的位置*/</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left=deleteNode(root-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right=deleteNode(root-&gt;right,key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((root-&gt;left==<span class="literal">NULL</span>) || (root-&gt;right==<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp=(root-&gt;left!=<span class="literal">NULL</span>)?root-&gt;left:root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)  <span class="comment">//根节点没有子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=root;</span><br><span class="line">                root=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>          <span class="comment">//根存在一个子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                *root=*temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;<span class="keyword">else</span>             <span class="comment">//根节点左右两个子节点都存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp=minValueNode(root-&gt;right);</span><br><span class="line">            root-&gt;key=temp-&gt;key;</span><br><span class="line">            root-&gt;right=deleteNode(root-&gt;right,temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)  <span class="comment">//这一步不能忘记</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*part3:判断二叉树是否还是平衡二叉树，不平衡则旋转*/</span></span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="number">0</span>) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> LL_rotate(root);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="number">0</span>) <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left =  RR_rotate(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> LL_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> RR_rotate(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="number">0</span>)  <span class="comment">//RL型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = LL_rotate(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> RR_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct Node *N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> = (<span class="title">BTNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">ll_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;left;</span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line"> </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">rr_rotate</span><span class="params">(BTNode* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *x = y-&gt;right;</span><br><span class="line">    y-&gt;right = x-&gt;left;</span><br><span class="line">    x-&gt;left = y;</span><br><span class="line"> </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(BTNode* N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(N-&gt;left) - <span class="built_in">height</span>(N-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">insert</span><span class="params">(BTNode* node, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> newNode(key);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"> </span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> ll_rotate(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)     <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> rr_rotate(node);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key)     <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;left = rr_rotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ll_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key)     <span class="comment">//RL型</span></span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;right = ll_rotate(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> rr_rotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode * <span class="title">minValueNode</span><span class="params">(BTNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode* current = node;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BTNode* <span class="title">deleteNode</span><span class="params">(BTNode* root, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;left == <span class="literal">NULL</span>) || (root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *root = *temp;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode* temp = minValueNode(root-&gt;right);</span><br><span class="line"> </span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line"> </span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"> </span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(root);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="number">0</span>) <span class="comment">//LL型</span></span><br><span class="line">        <span class="keyword">return</span> ll_rotate(root);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="number">0</span>) <span class="comment">//LR型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = rr_rotate(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ll_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">//RR型</span></span><br><span class="line">        <span class="keyword">return</span> rr_rotate(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="number">0</span>)  <span class="comment">//Rl型</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = ll_rotate(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> rr_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(struct Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *root = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    root = insert(root, <span class="number">9</span>);</span><br><span class="line">    root = insert(root, <span class="number">5</span>);</span><br><span class="line">    root = insert(root, <span class="number">10</span>);</span><br><span class="line">    root = insert(root, <span class="number">0</span>);</span><br><span class="line">    root = insert(root, <span class="number">6</span>);</span><br><span class="line">    root = insert(root, <span class="number">11</span>);</span><br><span class="line">    root = insert(root, <span class="number">-1</span>);</span><br><span class="line">    root = insert(root, <span class="number">1</span>);</span><br><span class="line">    root = insert(root, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历：\n"</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* The constructed AVL Tree would be</span></span><br><span class="line"><span class="comment">                     9</span></span><br><span class="line"><span class="comment">                    /  \</span></span><br><span class="line"><span class="comment">                   1    10</span></span><br><span class="line"><span class="comment">                 /  \     \</span></span><br><span class="line"><span class="comment">                0    5     11</span></span><br><span class="line"><span class="comment">               /    /  \</span></span><br><span class="line"><span class="comment">              -1   2    6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    root = deleteNode(root, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* The AVL Tree after deletion of 10</span></span><br><span class="line"><span class="comment">                       1</span></span><br><span class="line"><span class="comment">                     /   \</span></span><br><span class="line"><span class="comment">                    0     9</span></span><br><span class="line"><span class="comment">                  /     /  \</span></span><br><span class="line"><span class="comment">                -1     5     11</span></span><br><span class="line"><span class="comment">                     /  \</span></span><br><span class="line"><span class="comment">                    2    6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"前序遍历：\n"</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;&lt;strong&gt;平衡二叉树&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;平衡二叉树是对二叉排序树的改进，由于二叉排序树在某些情况下会退化为链表，
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://hustxxj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://hustxxj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——31.整数中1出现的次数（365-416-f62）</title>
    <link href="http://hustxxj.github.io/2020/03/30/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9431.%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/03/30/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9431.%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2020-03-30T04:13:39.000Z</published>
    <updated>2020-03-30T05:51:11.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>最简单的思路：将数字转换为字符串，然后逐一计算每个字符串中’1’出现的个数，累加起来得到答案。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=Caculate1num(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Caculate1num</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss&lt;&lt;num;</span><br><span class="line">        str=ss.str();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">'1'</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（约瑟夫环）：面试题62-圆圈中最后剩下的数字"><a href="#LeetCode练习（约瑟夫环）：面试题62-圆圈中最后剩下的数字" class="headerlink" title="LeetCode练习（约瑟夫环）：面试题62. 圆圈中最后剩下的数字"></a><strong>LeetCode练习（约瑟夫环）：面试题62. 圆圈中最后剩下的数字</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>示例 1：</p><p>输入: n = 5, m = 3<br>输出: 3</p><p>示例 2：</p><p>输入: n = 10, m = 17<br>输出: 2</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">推导法：</span></span><br><span class="line"><span class="comment">n=1: ans=0;</span></span><br><span class="line"><span class="comment">n=2: ans=(0+m)%2</span></span><br><span class="line"><span class="comment">n=3: ans=((0+m)%2+m)%3</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=(ans+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：416-分割等和子集"><a href="#LeetCode练习（动态规划）：416-分割等和子集" class="headerlink" title="LeetCode练习（动态规划）：416.分割等和子集"></a><strong>LeetCode练习（动态规划）：416.分割等和子集</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><pre><code>每个数组中的元素不会超过 100数组的大小不会超过 200</code></pre><p>示例 1:</p><p>输入: [1, 5, 11, 5]</p><p>输出: true</p><p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2:</p><p>输入: [1, 2, 3, 5]</p><p>输出: false</p><p>解释: 数组不能分割成两个元素和相等的子集.</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i][j]表示利用前i个数，能否组成一个和为j的值</span></span><br><span class="line"><span class="comment">最后返回结果bool ans=dp[nums.size()][sum/2]</span></span><br><span class="line"><span class="comment">注意：第i个值的大小为num[i-1]</span></span><br><span class="line"><span class="comment">dp[i][j]:</span></span><br><span class="line"><span class="comment">    case1:dp[i-1][j-nums[i-1]] //加第i个值</span></span><br><span class="line"><span class="comment">    case2:dp[i-1][j]         //不加第i个值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;((sum/<span class="number">2</span>)+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=sum/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sum/<span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i<span class="number">-1</span>]&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]] | dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len][sum/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数学）：365-水壶问题"><a href="#LeetCode练习（数学）：365-水壶问题" class="headerlink" title="LeetCode练习（数学）：365. 水壶问题"></a><strong>LeetCode练习（数学）：365. 水壶问题</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p><p>你允许：</p><pre><code>装满任意一个水壶清空任意一个水壶从一个水壶向另外一个水壶倒水，直到装满或者倒空</code></pre><p>示例 1: (From the famous “Die Hard” example)</p><p>输入: x = 3, y = 5, z = 4<br>输出: True</p><p>示例 2:</p><p>输入: x = 2, y = 6, z = 5<br>输出: False</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(z&gt;x+y)          <span class="comment">//两个杯子都装满也达不到所需容量</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span> || y==<span class="number">0</span>)   <span class="comment">//只有一个杯子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(z==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x==z || y==z)   <span class="comment">//只有一个杯子，且杯子的容量正好等于所需容量</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z%gcd(x,y)==<span class="number">0</span>;   <span class="comment">//z是否是x,y最大公约数的整数倍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——30.连续子数组的最大和（64-820-1162）</title>
    <link href="http://hustxxj.github.io/2020/03/28/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9430.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://hustxxj.github.io/2020/03/28/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9430.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
    <published>2020-03-28T01:33:00.000Z</published>
    <updated>2020-03-29T03:58:52.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>这是一道典型的动态规划题目，整理出状态转移方程：</p><p>dp[n]表示读取完第n个数，最大连续子序列的和<br>所以dp[n]= dp[n-1]+array[n]    当dp[n-1]&gt;0时<br>               = array[n]                 当dp[n-1]&lt;=0时</p><p>直接按照状态转移方程可以得出正确结果，但是这里可以做一些简化以降低空间复杂度：因为dp[n]的值只与前一个状态dp[n-1]有关，所以可以用一个变量v_last存储dp[n-1]的值。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> v_last=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v_max=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v_last&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v_last+=<span class="built_in">array</span>[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                v_last=<span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v_last&gt;v_max)</span><br><span class="line">            &#123;</span><br><span class="line">                v_max=v_last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：820-单词的压缩编码"><a href="#LeetCode练习（字符串）：820-单词的压缩编码" class="headerlink" title="LeetCode练习（字符串）：820.单词的压缩编码"></a><strong>LeetCode练习（字符串）：820.单词的压缩编码</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p><p>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。</p><p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p><p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><p>示例：</p><p>输入: words = [“time”, “me”, “bell”]<br>输出: 10<br>说明: S = “time#bell#” ， indexes = [0, 2, 5] 。</p><p>提示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= words.length &lt;= <span class="number">2000</span></span><br><span class="line"><span class="number">1</span> &lt;= words[i].length &lt;= <span class="number">7</span></span><br><span class="line">每个单词都是小写字母 。</span><br></pre></td></tr></table></figure><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：</p><p>由数据范围可知一个单词最多含有 7 个后缀，所以我们可以枚举单词所有的后缀。对于每个后缀，如果其存在 words 列表中，我们就将其从列表中删除。为了高效删除，我们将 words 用哈希集合（HashSet）来存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; good(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="keyword">word</span>:words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                good.erase(<span class="keyword">word</span>.substr(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">word</span>: good) &#123;</span><br><span class="line">            ans += <span class="keyword">word</span>.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（BSF）：1162-地图分析"><a href="#LeetCode练习（BSF）：1162-地图分析" class="headerlink" title="LeetCode练习（BSF）：1162.地图分析"></a><strong>LeetCode练习（BSF）：1162.地图分析</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p><p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先寻找出所有陆地的坐标,存储在队列中</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">                   que.push(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(que.empty()  || que.<span class="built_in">size</span>()==grid.<span class="built_in">size</span>()*grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐个弹出队列中的陆地，将它上下左右的海洋(0)标记为陆地(BFS),标记值为基地陆地值+1</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;   <span class="comment">//存储基地陆地值</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            ans=grid[temp.first][temp.second];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d:direction)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> dx=temp.first+d[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> dy=temp.second+d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dx&lt;<span class="number">0</span> || dx &gt;= grid.<span class="built_in">size</span>())</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dy&lt;<span class="number">0</span> || dy &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid[dx][dy]!=<span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                grid[dx][dy]=ans+<span class="number">1</span>;</span><br><span class="line">                que.push(&#123;dx,dy&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：64-最小路径和"><a href="#LeetCode练习（动态规划）：64-最小路径和" class="headerlink" title="LeetCode练习（动态规划）：64.最小路径和"></a><strong>LeetCode练习（动态规划）：64.最小路径和</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——29.最小K个数</title>
    <link href="http://hustxxj.github.io/2020/03/27/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9429.%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/"/>
    <id>http://hustxxj.github.io/2020/03/27/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9429.%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/</id>
    <published>2020-03-27T01:57:45.000Z</published>
    <updated>2020-03-27T04:44:20.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>需要注意考虑K大于输入数组的容量的情况。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(input.<span class="built_in">size</span>()==<span class="number">0</span> || k==<span class="number">0</span> || k&gt;input.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        sort(input.<span class="built_in">begin</span>(),input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：941-卡牌分组"><a href="#LeetCode练习（数组）：941-卡牌分组" class="headerlink" title="LeetCode练习（数组）：941.卡牌分组"></a><strong>LeetCode练习（数组）：941.卡牌分组</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路：计算数组中每个数出现的次数，然后求最大公约数，如果最大公约数小于等于1则返回false，否则返回true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=deck.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[deck[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sav;     <span class="comment">//记录每个数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            sav.push_back(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sav.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sav[<span class="number">0</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sav.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sav[i+<span class="number">1</span>]=measure(sav[i],sav[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sav[sav.<span class="built_in">size</span>()<span class="number">-1</span>]&lt;=<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">            &#123;</span><br><span class="line">                a=a-b;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                b=b-a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：12-整数转罗马数字"><a href="#LeetCode练习（字符串）：12-整数转罗马数字" class="headerlink" title="LeetCode练习（字符串）：12.整数转罗马数字"></a><strong>LeetCode练习（字符串）：12.整数转罗马数字</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/27/剑指Offer——29.最小K个数/29_2.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'M'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num-=count*<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'C'</span>);</span><br><span class="line">                res.push_back(<span class="string">'D'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'C'</span>);</span><br><span class="line">                res.push_back(<span class="string">'M'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'D'</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count<span class="number">-5</span>;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'C'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'C'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num-=count*<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'X'</span>);</span><br><span class="line">                res.push_back(<span class="string">'L'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'X'</span>);</span><br><span class="line">                res.push_back(<span class="string">'C'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'L'</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count<span class="number">-5</span>;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'X'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'X'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num-=count*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'I'</span>);</span><br><span class="line">                res.push_back(<span class="string">'V'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="string">'I'</span>);</span><br><span class="line">                res.push_back(<span class="string">'X'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;=<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'V'</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num<span class="number">-5</span>;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'I'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="string">'I'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：125-验证回文串"><a href="#LeetCode练习（字符串）：125-验证回文串" class="headerlink" title="LeetCode练习（字符串）：125.验证回文串"></a><strong>LeetCode练习（字符串）：125.验证回文串</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/27/剑指Offer——29.最小K个数/29_3.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> new_str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">               new_str.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'a'</span>&amp;&amp;s[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">               new_str.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'A'</span>&amp;&amp;s[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">               new_str.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=new_str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(new_str[left]!=new_str[right]  &amp;&amp; <span class="built_in">abs</span>(new_str[left]-new_str[right])!=<span class="number">32</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(new_str[left]&gt;=<span class="string">'0'</span>&amp;&amp;new_str[left]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(new_str[right]&gt;=<span class="string">'a'</span>&amp;&amp;new_str[right]&lt;=<span class="string">'z'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(new_str[right]&gt;=<span class="string">'A'</span>&amp;&amp;new_str[right]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(new_str[right]&gt;=<span class="string">'0'</span>&amp;&amp;new_str[right]&lt;=<span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(new_str[left]&gt;=<span class="string">'a'</span>&amp;&amp;new_str[left]&lt;=<span class="string">'z'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(new_str[left]&gt;=<span class="string">'A'</span>&amp;&amp;new_str[left]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——28.数组中出现次数超过一半的数字（876-999-f17.16）</title>
    <link href="http://hustxxj.github.io/2020/03/26/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9428.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://hustxxj.github.io/2020/03/26/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9428.%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-03-26T01:06:15.000Z</published>
    <updated>2020-03-26T02:34:10.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用map对每个数字出现的次数进行计数，并且判断计数是否超过长度的一半。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cot[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(cot[numbers[i]]&gt;(len/<span class="number">2</span>))</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：999-车的可用捕获量"><a href="#LeetCode练习（数组）：999-车的可用捕获量" class="headerlink" title="LeetCode练习（数组）：999.车的可用捕获量"></a><strong>LeetCode练习（数组）：999.车的可用捕获量</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p><p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p><p>返回车能够在一次移动中捕获到的卒的数量。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hang=board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(hang==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lie=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> location_x,location_y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hang;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator it=<span class="built_in">find</span>(board[i].<span class="built_in">begin</span>(),board[i].<span class="built_in">end</span>(),<span class="string">'R'</span>);</span><br><span class="line">            <span class="keyword">if</span>(it!=board[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                location_x=i;</span><br><span class="line">                location_y=it-board[i].<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//'R'的坐标为board[location_x][location_y]</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左找'p',如果找到'p'之前先遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_y<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_y+<span class="number">1</span>;i&lt;=lie<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[location_x][i]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_x<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向下找'p',如果找到'p'之前遇到'B'则结束,吃掉第一个'p'也结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=location_x+<span class="number">1</span>;i&lt;=hang<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'B'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][location_y]==<span class="string">'p'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（快慢指针）：876-链表的中间结点"><a href="#LeetCode练习（快慢指针）：876-链表的中间结点" class="headerlink" title="LeetCode练习（快慢指针）：876.链表的中间结点"></a><strong>LeetCode练习（快慢指针）：876.链表的中间结点</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针实现，需要注意while结束边界条件</span></span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：面试题17-16-按摩师"><a href="#LeetCode练习（动态规划）：面试题17-16-按摩师" class="headerlink" title="LeetCode练习（动态规划）：面试题17.16.按摩师"></a><strong>LeetCode练习（动态规划）：面试题17.16.按摩师</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i][0]表示当前预约不接，所获得最大钱数</span></span><br><span class="line"><span class="comment">dp[i][0]=max&#123;dp[i-1][0],dp[i-1][1]&#125;;</span></span><br><span class="line"><span class="comment">dp[i][1]表示当前预约接，所获得最大钱数</span></span><br><span class="line"><span class="comment">dp[i][1]=dp[i-1][0]+nums[i];</span></span><br><span class="line"><span class="comment">result=max&#123;dp[len-1][0],dp[len-1][1]&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[len<span class="number">-1</span>][<span class="number">0</span>],dp[len<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>基础查找算法整理</title>
    <link href="http://hustxxj.github.io/2020/03/23/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://hustxxj.github.io/2020/03/23/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-03-23T12:19:40.000Z</published>
    <updated>2020-03-24T12:39:46.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5种基础的查找算法"><a href="#5种基础的查找算法" class="headerlink" title="5种基础的查找算法"></a><strong>5种基础的查找算法</strong></h1><hr><p>本文对7种基础的查找算法做了整理，包括顺序查找（不做讨论）、二分查找、插值查找、哈希查找、二叉搜索树查找以及红黑树。实现了这5中查找算法的代码并讨论了各自的时间复杂度和空间复杂度。</p><hr><h2 id="01-二分查找"><a href="#01-二分查找" class="headerlink" title="#01.二分查找"></a><strong>#01.二分查找</strong></h2><hr><p>对于一个常规的<em>有序</em>数组而言，进行二分查找的思路比较简单。将所要查找的元素每次和数组的中间元素进行比较，如果大于中间元素值，则对数组的后半部分进行二分查找；如果小于中间元素，则对数组的前半部分进行二分查找。</p><p>二分查找的时间复杂度为O(logN)，空间复杂度为O(1)，要求数组是有序的。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">        &#123;</span><br><span class="line">            index=mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//简单二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>简单二分查找要求数组需要是一个常规有序数组，现在考虑利用二分查找对一个<em>旋转有序数组</em>进行查找。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//旋转数组二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_Rotate_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=a[left])   <span class="comment">//左边有序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=a[left] &amp;&amp; target&lt;a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右边有序</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;=a[right] &amp;&amp; target&gt;a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_Rotate_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="02-插值查找"><a href="#02-插值查找" class="headerlink" title="#02.插值查找"></a><strong>#02.插值查找</strong></h2><hr><p>插值查找是对二分查找的改进，适用于数组数据分布比较均匀的情况，但是如果数组分布较极端那么插值查找的效率反而不如二分查找。</p><p>二分查找的公式为：</p><p><code><img src="/2020/03/23/基础查找算法整理/02_01.jpg" title="示例图"></code></p><p>插值查找的公式为：</p><p><code><img src="/2020/03/23/基础查找算法整理/02_02.jpg" title="示例图"></code></p><p>插值查找的平均期望复杂度为O(loglogN)，空间复杂度为O(1)，要求数组是有序的。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_target</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=left+((target-a[left])/(a[right]-a[left]))*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">26</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">10</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> index=find_target(ex,<span class="number">0</span>,len<span class="number">-1</span>,target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d index = %d\n"</span>,target,index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="03-哈希查找"><a href="#03-哈希查找" class="headerlink" title="#03.哈希查找"></a><strong>#03.哈希查找</strong></h2><hr><p>哈希查找是指：将所要查找的值带入哈希函数中，直接索引出值的位置。即：index=H(value)，H()表示哈希函数。</p><p><strong>哈希函数的构造方式</strong>：哈希函数的构造方式通常有五种</p><p>1&gt;直接定址法：H(value)=a x value+b，这种形式适合于表较小且连续的情况。</p><p>2&gt;数字分析法</p><p>3&gt;平方取中法</p><p>4&gt;折叠法</p><p>5&gt;除数留余法：H(value)=value MOD p （p&lt;=m，m为表长）。该方法是用的最多的方法。</p><p><strong>解决哈希冲突的方法</strong>：解决哈希冲突的方法通常有四种，开放定制法，链地址法，公共溢出区法，再散列法。主要介绍前两种常见方法。</p><p>1&gt;<strong>开放定制法</strong>：如果两个数value_x（前），value_y（后）的哈希函数值发生冲突，H(value_x)==H(value_y)，那么H(value_y)会改为H(value_y)+D </p><p>D的取值有三种取法：</p><p>①线性探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_01.jpg" title="示例图"></code></p><p>②平方探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_02.jpg" title="示例图"></code></p><p>③随机探测再散列</p><p><code><img src="/2020/03/23/基础查找算法整理/03_03.jpg" title="示例图"></code></p><p>2&gt; <strong>链地址法</strong>：产生哈希冲突后再存储数据后面加一个指针，指向后面冲突的数据</p><p><code><img src="/2020/03/23/基础查找算法整理/03_04.jpg" title="示例图"></code></p><p>需要注意的是哈希表在删除元素时：链地址法可以直接删除；<em>但是对于开放定制法，如果直接删除前面的元素就会导致后面的元素无法索引到，所以需要在删除时插入一个原来不存在的数据如-1。</em></p><p>哈希查找的时间复杂度为O(1)，空间复杂度为O(n)，对于要查找的数组是否有序没有要求。</p><hr><h2 id="04-二叉搜索树查找"><a href="#04-二叉搜索树查找" class="headerlink" title="#04.二叉搜索树查找"></a><strong>#04.二叉搜索树查找</strong></h2><hr><p>首先介绍一下<strong>什么是二叉搜索树</strong>，二叉搜索树满足以下条件：</p><p>①若它的左子树不为空，则<strong>左子树上所有节点</strong>的值均小于它根节点的值</p><p>②若它的右子树不为空，则<strong>右子树上所有节点</strong>的值均大于它根节点的值</p><p><code><img src="/2020/03/23/基础查找算法整理/04_01.jpg" title="示例图"></code></p><p>二叉搜索树的查找时间复杂度受树的深度影响，平均时间复杂度为O(logN)</p><hr><p>1&gt;二叉搜索树查找最大值：从根节点一直往右走，直到无路可走，遍可访问到最大值节点。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchMax</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> SearchMax(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>2&gt;二叉搜索树查找最小值：从根节点一直往左走，直到无路可走，遍可以访问到最小值节点。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchMin</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(rooy-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> SearchMin(root-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3&gt;二叉搜索数进行一般查找</p><p>①递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchValue</span><span class="params">(TreeNode* root,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val==target)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; target)</span><br><span class="line">        <span class="keyword">return</span> SearchValue(root-&gt;left,target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; target)</span><br><span class="line">        <span class="keyword">return</span> SearchValue(root-&gt;right,target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②非递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchValue</span><span class="params">(TreeNode* root,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode* ptr=root;</span><br><span class="line">    <span class="keyword">while</span>(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;val==target)</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        </span><br><span class="line">        ptr=(root-&gt;val &gt; target)?ptr-&gt;left:ptr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="05-红黑树"><a href="#05-红黑树" class="headerlink" title="#05.红黑树"></a><strong>#05.红黑树</strong></h2><hr><p><a href="https://www.jianshu.com/p/104fa73c81b3" target="_blank" rel="noopener">https://www.jianshu.com/p/104fa73c81b3</a></p><p><a href="https://blog.csdn.net/hackbuteer1/article/details/7740956" target="_blank" rel="noopener">https://blog.csdn.net/hackbuteer1/article/details/7740956</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5种基础的查找算法&quot;&gt;&lt;a href=&quot;#5种基础的查找算法&quot; class=&quot;headerlink&quot; title=&quot;5种基础的查找算法&quot;&gt;&lt;/a&gt;&lt;strong&gt;5种基础的查找算法&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;本文对7种基础的查找算法做了整理，包括顺
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://hustxxj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://hustxxj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——27.字符串的排列（67-136-f40）</title>
    <link href="http://hustxxj.github.io/2020/03/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9427.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9427.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2020-03-20T07:10:48.000Z</published>
    <updated>2020-03-23T13:50:53.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>a,b,c全排列得出的所有字符串，可以看做：</p><ol><li><p>以a开头，（b,c）全排列得出的字符串</p></li><li><p>以b开头，（a,c）全排列得出的字符串</p></li><li><p>以c开头，（a,b）全排列得出的字符串</p></li></ol><p>   <em>定义Permutation1（string str,int begin,vector<string>result）：</string></em></p><p>   表示从str的第begin个字符开始，计算str的全排列，将结果放入result中。</p><p>   显然，当begin==str.size()-1的时候，全排列只存在一种，就是当下的str，所以将str放入result中。</p><p>   而当begin!=str.size()时：</p><p>   ​       ①交换a和a的顺序，计算（b，c）的全排列</p><p>   ​       ②交换a和b的顺序，计算（a，c）的全排列</p><p>   ​       ③交换a和c的顺序，计算（b，a）的全排列</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(str.empty()) <span class="keyword">return</span> result;</span><br><span class="line">         </span><br><span class="line">        Permutation1(str,result,<span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 此时得到的result中排列并不是字典顺序，可以单独再排下序</span></span><br><span class="line">        sort(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Permutation1</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result,<span class="keyword">int</span> <span class="built_in">begin</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == str.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="comment">// 递归结束条件：索引已经指向str最后一个元素时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>(),str) == result.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果result中不存在str，才添加；避免aa和aa重复添加的情况</span></span><br><span class="line">                result.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一次循环i与begin相等，相当于第一个位置自身交换，关键在于之后的循环，</span></span><br><span class="line">            <span class="comment">// 之后i != begin，则会交换两个不同位置上的字符，直到begin==str.size()-1，进行输出；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">begin</span>;i&lt;str.<span class="built_in">size</span>();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(str[i],str[<span class="built_in">begin</span>]);</span><br><span class="line">                Permutation1(str,result,<span class="built_in">begin</span>+<span class="number">1</span>);</span><br><span class="line">                swap(str[i],str[<span class="built_in">begin</span>]); <span class="comment">// 复位，用以恢复之前字符串顺序，达到第一位依次跟其他位交换的目的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> &amp;fir,<span class="keyword">char</span> &amp;sec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = fir;</span><br><span class="line">        fir = sec;</span><br><span class="line">        sec = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：面试题40-最小的K个数"><a href="#LeetCode练习（数组）：面试题40-最小的K个数" class="headerlink" title="LeetCode练习（数组）：面试题40.最小的K个数"></a><strong>LeetCode练习（数组）：</strong>面试题40.最小的K个数</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：67-二进制求和"><a href="#LeetCode练习（字符串）：67-二进制求和" class="headerlink" title="LeetCode练习（字符串）：67.二进制求和"></a><strong>LeetCode练习（字符串）：67.二进制求和</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/20/剑指Offer——27.字符串的排列/27_67.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> max_len=(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())?b.<span class="built_in">size</span>():a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=b.<span class="built_in">size</span>();i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            b=temp+b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a.<span class="built_in">size</span>();i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            a=temp+a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isadd=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'0'</span> &amp;&amp; b[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                isadd=<span class="literal">false</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'0'</span> &amp;&amp; b[i]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">false</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'1'</span> &amp;&amp; b[i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">false</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'1'</span> &amp;&amp; b[i]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isadd==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'0'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(<span class="string">'1'</span>);</span><br><span class="line">                    isadd=<span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isadd==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：136-只出现一次的数字"><a href="#LeetCode练习（数组）：136-只出现一次的数字" class="headerlink" title="LeetCode练习（数组）：136.只出现一次的数字"></a><strong>LeetCode练习（数组）：136.只出现一次的数字</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/20/剑指Offer——27.字符串的排列/27_136.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                out = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]==nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                out = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>基础排序算法整理</title>
    <link href="http://hustxxj.github.io/2020/03/19/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://hustxxj.github.io/2020/03/19/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2020-03-19T01:46:35.000Z</published>
    <updated>2020-03-23T08:09:47.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9种基础的排序算法"><a href="#9种基础的排序算法" class="headerlink" title="9种基础的排序算法"></a><strong>9种基础的排序算法</strong></h1><hr><p>撰写本文意在帮助自己复习巩固基础的10大排序算法，分析每种排序算法的原理及实现思路。同时对各个排序算法的时间复杂度，空间复杂度以及稳定性进行了总结。</p><hr><h2 id="01-冒泡排序"><a href="#01-冒泡排序" class="headerlink" title="#01.冒泡排序"></a><strong>#01.冒泡排序</strong></h2><hr><p>冒泡排序的基本思想就是对数值进行两两比较，如果出现反序，则交换两个数值的位置。一直到序列中没有反序为止。<br>实现过程：（以将数据从小到大排序为目标）</p><ol><li>从数组起始点开始，比较相邻的两个数据，如果后一个数据<em>小于</em>前一个数据，则交换两个数据的位置。</li><li>继续以上步骤，知道遍历完数组元素。完成第一次遍历。</li><li>从数组的第二个元素开始，再次两两比较，如果后一个数据<em>小于</em>前一个数据，则交换两个数据的位置。</li><li>重复上述步骤直到数组完全有序。</li></ol><hr><p>实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//冒泡排序(从小到大)</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每比较完一轮，就会将最大值放到数组的尾部，所以剩余需要比较的数为len-1-i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&gt;ex[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=ex[j];</span><br><span class="line">                ex[j]=ex[j+<span class="number">1</span>];</span><br><span class="line">                ex[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>时间复杂度：</p><ol><li>按照上述基本方法进行冒泡排序，需要进行n次循环，第一循环需要进行n-1次比较，第二次循环需要进行n-2次比较，以此类推… （1+2+3+…+n-1）=n(n-1)/2，所以最好最坏的时间复杂度都是O(n2)；</li><li>如果对上述方法进行优化，<em>最好情况下</em>，时间复杂度为O(n)。</li></ol><p>空间复杂度：</p><ol><li>由于完成排序没有利用新的内存空间，所以空间复杂度是O(1)。</li></ol><p>稳定性：</p><ol><li>排序后没有影响数据的位置关系，是稳定的。</li></ol><hr><h2 id="02-选择排序"><a href="#02-选择排序" class="headerlink" title="#02.选择排序"></a><strong>#02.选择排序</strong></h2><hr><p>选择排序的基本思想是（从小到大排序）：</p><ol><li>第一次遍历n-1个数，找出最小的元素与第1个数进行位置交换</li><li>第二次遍历n-2个数，找出最小值与第2个数进行位置交换。<br>…</li><li>第n-1次遍历，找到最小元素与第n-1个元素进行交换<br>排序完成</li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//得出第i轮遍历找到的最小值</span></span><br><span class="line">        <span class="keyword">int</span> min_value=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&lt;ex[min_value])</span><br><span class="line">            &#123;</span><br><span class="line">                min_value=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换位置</span></span><br><span class="line">        <span class="keyword">int</span> temp=ex[i];</span><br><span class="line">        ex[i]=ex[min_value];</span><br><span class="line">        ex[min_value]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>第一遍排序，需要进行n-1次比较；第二遍排序，需要进行n-2次比较；…第n-2轮排序，需要进行1次比较。<br>1+2+3+…+n-1=n(n-1)/2，所以时间复杂度为O(n2)</li></ol><p>空间复杂度：</p><ol><li>没有开辟新的内存空间，所以O(1)</li></ol><p>稳定性：</p><ol><li>不是稳定的。两个相等的元素，在排序前后相对位置有可能发生变化</li></ol><hr><h2 id="03-插入排序"><a href="#03-插入排序" class="headerlink" title="#03.插入排序"></a><strong>#03.插入排序</strong></h2><hr><p>插入排序的基本思路是：</p><ol><li>对于一个数组，假定前n-1个数据是已经排序好的。</li><li>现在将第n个元素插入到前面已序的n-1个数据中，使得这n个数据已序。</li><li>令n=1，2，… ，反复循环直到全部排序好。</li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ex[j]&lt;ex[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=ex[j];</span><br><span class="line">                ex[j]=ex[j<span class="number">-1</span>];</span><br><span class="line">                ex[j<span class="number">-1</span>]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复制度：</p><ol><li>最好的情况，如果数组已经是一个已序数组，那么只需要经过n次比较就可以得出结果，时间复杂度为O(n)。</li><li>最坏的情况，如果数组是一个逆序数组，那么需要比较1+2+3+…+n-1=n(n-1)/2次，时间复杂度为O(n2)。</li></ol><p>空间复杂度：</p><ol><li>没有利用新的空间，空间复杂度为O(1)。</li></ol><p>算法稳定性：</p><ol><li>相等数据在排序前后，相对位置没有发生变化，所以是稳定的。</li></ol><hr><h2 id="04-快速排序"><a href="#04-快速排序" class="headerlink" title="#04.快速排序"></a><strong>#04.快速排序</strong></h2><hr><p>快速排序的基本思想是利用分治法：</p><ol><li><p>选基准数。先从数列中取出一个数作为基准数</p></li><li><p>分区过程。将比基准数大的数全部放到它的右边，比基准数小的数全部放到它的左边。</p></li><li><p>迭代。对左右分区再进行上述操作。</p><p><em>具体代码实现思路（挖坑填数）：</em></p><ol><li>取i=L（区间左边界），j=R（区间右边界）。将基准数BASE设为a[i]，作为第一个坑。</li><li>j–从右向左搜寻，找到小于BASE的数则挖出这个数，填入坑a[i]中。</li><li>i++从左往右搜寻，找到大于BASE的数则挖出这个数，填入前一步挖出的坑a[j]中。</li><li>重复执行2,3步直到i==j，然后将BASE放入a[i]中。</li></ol></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fast_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=right;</span><br><span class="line">        <span class="keyword">int</span> BASE=a[i];</span><br><span class="line">        <span class="keyword">while</span>(i!=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;i;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;BASE)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i]=a[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;j;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;BASE)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[j]=a[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i]=BASE;</span><br><span class="line"></span><br><span class="line">        Fast_sort(a,left,i<span class="number">-1</span>);</span><br><span class="line">        Fast_sort(a,i+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    Fast_sort(ex,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li><p>如果数组本身已经是一个有序的数组，最好情况下时间复杂度为O(n*logn)。</p></li><li><p>如果数组是个逆序数组，那么此时时间复杂度最高，为O(n^2)。</p></li></ol><p>   空间复杂度：</p><ol><li>没有利用新的空间，空间复杂度O(1)。</li></ol><pre><code>算法稳定性：1. 不稳定</code></pre><hr><h2 id="05-堆排序"><a href="#05-堆排序" class="headerlink" title="#05.堆排序"></a><strong>#05.堆排序</strong></h2><hr><p>堆排序的基本原理：</p><ol><li><p>将一个无序序列构建成一个堆，如果需要序后的数组为升序排列则构建成大顶堆，如果序后数组为降序排列则构建成小顶堆。</p><p>（以升序排列为例）</p></li><li><p>将堆顶元素与末尾元素交换，将最大元素下沉到数组末端。</p></li><li><p>重新调整结构，使其满足大顶堆的定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换，知道整个序列有序。</p></li></ol><p>   <em>原理说明可以参考下面的博客：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></em></p><p>   <em>代码实现参考下面博客：<a href="https://www.cnblogs.com/skywang12345/p/3602162.html#a42" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3602162.html#a42</a></em></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxtopheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> sta,<span class="keyword">int</span> en)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current=sta;             <span class="comment">//当前节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> left=sta*<span class="number">2</span>+<span class="number">1</span>;            <span class="comment">//当前节点左子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> value=a[current];        <span class="comment">//当前节点的值</span></span><br><span class="line">    <span class="keyword">for</span>(;left&lt;en;current=left,left=left*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[left]&lt;a[left+<span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;=a[left])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[current]=a[left];</span><br><span class="line">            a[left]=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_ASCSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将数组a构成大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(length/<span class="number">2</span>)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        maxtopheap(a,i,length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换+继续重组成大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];</span><br><span class="line">        a[i]=a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>]=temp;</span><br><span class="line">        maxtopheap(a,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序(从小到大)</span></span><br><span class="line">    Heap_ASCSort(ex,len);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>堆排序最优情况下，最差情况下以及平均时间复杂度都为O(n*logn)</li></ol><p>   空间复杂度:</p><ol><li>只涉及元素直接的调换，空间复杂度为O(1)</li></ol><pre><code>算法稳定性：1. 不稳定</code></pre><hr><h2 id="06-归并排序"><a href="#06-归并排序" class="headerlink" title="#06.归并排序"></a><strong>#06.归并排序</strong></h2><hr><p>归并排序的基本原理：</p><p><em>归并排序时基于两组已序的数组进行合并，时间复杂度为O(n)这一事实实现的</em></p><ol><li><p>将数据分为A，B两组，如果这A，B分别都是已序数组，那么就可以很方便的将两组数据合并成一个有序数组。</p></li><li><p>如何实现A，B数组的已序？就是再对A，B进行划分，直到每个小组只有1个元素，那么就可以任务这个小组组内有序了。</p></li><li><p>然后再逐层合并实现整体的已序。</p><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/6_1.jpg" title="示例图"></code></p></li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; before,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; after)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(before[i]&lt;before[j])</span><br><span class="line">        &#123;</span><br><span class="line">            after[k++]=before[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            after[k++]=before[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">        after[k++]=before[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        after[k++]=before[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并以后还需要反向赋值回原数组，以便留给后续迭代使用</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        before[left + i] = after[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; before,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; after)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        Merge_sort(before,left,mid,after);          <span class="comment">//左边归并排序</span></span><br><span class="line">        Merge_sort(before,mid+<span class="number">1</span>,right,after);       <span class="comment">//右边归并排序</span></span><br><span class="line">        MergeArray(before,left,mid,right,after);    <span class="comment">//合并左右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; af(<span class="number">20</span>);</span><br><span class="line">    Merge_sort(ex,<span class="number">0</span>,len<span class="number">-1</span>,af);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>任何情况下归并排序的时间复杂度为O(n*logn)。假设数量长为n，将数列分开成小数列一共要logn步，每一步都是一个合并有序数列的过程，合并有序数列时间复杂度为O(n)。</li></ol><p>   空间复杂度：</p><ol><li>空间复杂度为O(n)，因为借用了一个数组af[]用于暂存已序的数组。</li></ol><pre><code>稳定性：1. 稳定</code></pre><hr><h2 id="07-希尔排序"><a href="#07-希尔排序" class="headerlink" title="#07.希尔排序"></a><strong>#07.希尔排序</strong></h2><hr><p>希尔排序的基本原理：</p><p>希尔排序可以理解为是堆插入排序的改进，改进的思路是：把数组按<em>下标的增量进行分组</em>，对每组使用直接插入排序；随着增量的逐渐减少，每组包含的元素越来越多，<em>当增量减至1时</em>，整个数组正好为一组，算法终止。</p><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/7_1.jpg" title="示例图"></code></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> distance=len;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        distance=distance/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;distance;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=k+distance;i&lt;len;i+=distance)   <span class="comment">//i+=distance需要注意</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;k;j-=distance)    <span class="comment">//j&gt;k这个也需要注意</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ex[j]&lt;ex[j-distance])</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=ex[j];</span><br><span class="line">                        ex[j]=ex[j-distance];</span><br><span class="line">                        ex[j-distance]=temp;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(distance==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>希尔排序的时间复杂度取决于增量选取，最坏情况下希尔排序的时间复杂度会到O(n2)，平均时间复杂度为O(n*logn2)。</li></ol><p>   空间复杂度：</p><ol><li>与插入排序一样都是O(1)。</li></ol><pre><code>算法稳定性：1.  尽管插入排序是稳定的，但是由于希尔排序涉及到分组，相同的元素被分到不同的组中然后各自进行插入排序有可能会改变它们之间的位置关系，所以希尔排序时不稳定的。</code></pre><hr><h2 id="08-计数排序"><a href="#08-计数排序" class="headerlink" title="#08.计数排序"></a><strong>#08.计数排序</strong></h2><hr><p>计数排序的基本原理：</p><p><em>计数排序是一种非比较的排序，它适用于<strong>一定范围</strong>的整数排序。在取值范围不是很大的情况下，它的性能甚至会快过O(nlogn)的排序方法</em></p><p>计数排序的算法步骤：</p><ol><li><p>找出待排序数组的最大值和最小值。</p></li><li><p>构建一个数组C，统计原数组中每个元素i出现的次数k，将k存入数组C的第i项中。</p></li><li><p>对C中的所有计数累加。</p></li><li><p>反向填充原数组。</p></li></ol><p>   <em>原理参考图：</em></p><p>   <code><img src="/2020/03/19/基础排序算法整理/8_1.jpg" title="示例图"></code></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//计数排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> v_min=ex[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> v_max=ex[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ex[i]&gt;v_max)</span><br><span class="line">        &#123;</span><br><span class="line">            v_max=ex[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ex[i]&lt;v_min)</span><br><span class="line">        &#123;</span><br><span class="line">            v_min=ex[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> range=v_max-v_min+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countArray(range,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArray[ex[j]-v_min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ptr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;range;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;countArray[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ex[ptr++]=i+v_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li><p>计数排序的时间复杂度受到数组中最大值和最小值的差值影响。</p></li><li><p>设max-min=m，则时间复杂度为O(m+n)</p></li></ol><p>   空间复杂度:</p><ol><li>空间复杂度同样取决于数组最大和最小值得差值，设max-min=m，则空间复杂度为O(m)。</li></ol><pre><code>算法稳定性：1. 稳定</code></pre><hr><h2 id="09-基数排序"><a href="#09-基数排序" class="headerlink" title="#09. 基数排序"></a><strong>#09. 基数排序</strong></h2><hr><p>基数排序的原理：</p><ol><li>将整数按位数切割成不同的数字，然后按每个位数分别比较。</li></ol><p><em>原理参考图：</em></p><p><code><img src="/2020/03/19/基础排序算法整理/9_1.gif" title="示例图"></code></p><p><code><img src="/2020/03/19/基础排序算法整理/9_2.jpg" title="示例图"></code></p><p><em>ex：基数排序还有前面的计数排序都可以看做是桶排序的特殊形式，三者的差异在于：</em></p><p><em>1.基数排序：根据元素的每<strong>位</strong>数字来分配桶。</em></p><p><em>2.计数排序：每个桶只存在单一元素。</em></p><p><em>3.桶排序：每个桶凑存储一定范围的元素。</em></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span>;             <span class="comment">//指数，用来区分每次排序是按哪一位，exp=1表示按个位排序，ex=10表示按十位排序...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> v_max=vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]&gt;v_max)</span><br><span class="line">        &#123;</span><br><span class="line">            v_max=vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从个位开始，对数组进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">exp</span>=<span class="number">1</span>;v_max/<span class="built_in">exp</span>&gt;<span class="number">0</span>;<span class="built_in">exp</span>*=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> buckets[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(length,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i]+=buckets[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]<span class="number">-1</span>]=vec[i];</span><br><span class="line">            buckets[(vec[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>]=&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">64</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">15</span>,<span class="number">27</span>,<span class="number">38</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">99</span>,<span class="number">45</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ex(arr,arr+<span class="number">20</span>);</span><br><span class="line">    print_vector(ex);</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    <span class="keyword">int</span> len=ex.<span class="built_in">size</span>();</span><br><span class="line">    radix_sort(ex,len);</span><br><span class="line"></span><br><span class="line">    print_vector(ex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时间复杂度：</p><ol><li>基数排序的时间复杂度取决于数组中最大数有多少位，设最大数有k位，则时间复杂度为O(kn)</li></ol><p>   空间复杂度：</p><ol><li>这里开辟了一个包含10个整型的数组，空间复杂度为O(1)</li></ol><pre><code>算法稳定性：1. 稳定</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;9种基础的排序算法&quot;&gt;&lt;a href=&quot;#9种基础的排序算法&quot; class=&quot;headerlink&quot; title=&quot;9种基础的排序算法&quot;&gt;&lt;/a&gt;&lt;strong&gt;9种基础的排序算法&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;撰写本文意在帮助自己复习巩固基础的10大
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://hustxxj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://hustxxj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——26.二叉搜索树和双向链表（23-33-836）</title>
    <link href="http://hustxxj.github.io/2020/03/18/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9426.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://hustxxj.github.io/2020/03/18/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9426.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-18T04:48:28.000Z</published>
    <updated>2020-03-23T13:50:27.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>思路与迭代法实现二叉树的中序遍历类似，可以参考剑指Offer——04.二叉树的重建</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRootOfTree==nullptr)</span><br><span class="line">            return nullptr;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; sta;</span><br><span class="line">        TreeNode* ptr=pRootOfTree;</span><br><span class="line">        TreeNode* res=new TreeNode(-1);</span><br><span class="line">        TreeNode* res_ptr=res;</span><br><span class="line">        bool isFirst=true;</span><br><span class="line">        while(ptr!=nullptr || !sta.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            while(ptr!=nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            res_ptr-&gt;right=ptr;</span><br><span class="line">            if(isFirst==false)</span><br><span class="line">              ptr-&gt;left=res_ptr;</span><br><span class="line">            res_ptr=ptr;</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">            isFirst=false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：836-矩阵重叠"><a href="#LeetCode练习（数组）：836-矩阵重叠" class="headerlink" title="LeetCode练习（数组）：836.矩阵重叠"></a><strong>LeetCode练习（数组）：836.矩阵重叠</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_836.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123;</span><br><span class="line">        bool res=false;</span><br><span class="line">        </span><br><span class="line">        if(rec2[0]&lt;rec1[2] &amp;&amp; rec2[1]&lt;rec1[3] &amp;&amp; rec2[2]&gt;rec1[0] &amp;&amp; rec2[3]&gt;rec1[1])</span><br><span class="line">           res=true;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（链表）：23-合并K个排序链表"><a href="#LeetCode练习（链表）：23-合并K个排序链表" class="headerlink" title="LeetCode练习（链表）：23.合并K个排序链表"></a><strong>LeetCode练习（链表）：23.合并K个排序链表</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_23.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        int len=lists.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return nullptr;</span><br><span class="line">        if(len==1)</span><br><span class="line">           return lists[0];</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* ptr=lists[i];</span><br><span class="line">            while(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                vec.push_back(ptr-&gt;val);</span><br><span class="line">                ptr=ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(vec.begin(),vec.end());</span><br><span class="line">        ListNode* res=new ListNode(-1);</span><br><span class="line">        ListNode* res_ptr=res;</span><br><span class="line">        for(int i=0;i&lt;vec.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tempnode=new ListNode(vec[i]);</span><br><span class="line">            res_ptr-&gt;next=tempnode;</span><br><span class="line">            res_ptr=tempnode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：33-搜索旋转排序数组"><a href="#LeetCode练习（数组）：33-搜索旋转排序数组" class="headerlink" title="LeetCode练习（数组）：33.搜索旋转排序数组"></a><strong>LeetCode练习（数组）：33.搜索旋转排序数组</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/18/剑指Offer——26.二叉搜索树和双向链表/26_33.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) </span><br><span class="line">    &#123;</span><br><span class="line">        int low=0,high=nums.size()-1;</span><br><span class="line">        </span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=low+(high-low)/2;</span><br><span class="line">            if(target==nums[mid]) return mid;</span><br><span class="line"></span><br><span class="line">            if(nums[low]&lt;=nums[mid])  /////左区间有序</span><br><span class="line">            &#123;</span><br><span class="line">                if(target&gt;=nums[low]&amp;&amp;target&lt;nums[mid])   ////target在左区间</span><br><span class="line">                    high=mid-1;</span><br><span class="line">                else low=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else                     ///右区间有序</span><br><span class="line">            &#123;</span><br><span class="line">                if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[high])    ////target在右区间</span><br><span class="line">                    low=mid+1;</span><br><span class="line">                else high=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——25.复制链表的复制（46-62-1160）</title>
    <link href="http://hustxxj.github.io/2020/03/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9425.%E5%A4%8D%E5%88%B6%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>http://hustxxj.github.io/2020/03/17/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9425.%E5%A4%8D%E5%88%B6%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
    <published>2020-03-17T12:58:55.000Z</published>
    <updated>2020-03-18T04:45:18.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><ol><li>在每个节点后面复制一个和当前节点一模一样的节点（节点值，下一节点地址，随机节点地址都一样）</li><li>将复制的节点拿出来单独组成一个链表</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    struct RandomListNode *next, *random;</span><br><span class="line">    RandomListNode(int x) :</span><br><span class="line">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        </span><br><span class="line">        clo(pHead);</span><br><span class="line">        setrandomptr(pHead);</span><br><span class="line">        return depart(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void clo(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode* ptr=head;</span><br><span class="line">        while(ptr!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* cloneNode=new RandomListNode(ptr-&gt;label);</span><br><span class="line">            cloneNode-&gt;next=ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next=cloneNode;</span><br><span class="line">            ptr=cloneNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void setrandomptr(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode *pNode = head;</span><br><span class="line">     </span><br><span class="line">        while (pNode != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode *pClone = pNode-&gt;next;</span><br><span class="line">            if (pNode-&gt;random)</span><br><span class="line">            &#123;</span><br><span class="line">                pClone-&gt;random = pNode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pClone-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RandomListNode* depart(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode* ptr=head;</span><br><span class="line">        RandomListNode* res=head-&gt;next;</span><br><span class="line">        while(ptr!=nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* ptr_res=ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next=ptr_res-&gt;next;</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">            if(ptr!=nullptr)</span><br><span class="line">              ptr_res-&gt;next=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（哈希表）：1160-拼写单词"><a href="#LeetCode练习（哈希表）：1160-拼写单词" class="headerlink" title="LeetCode练习（哈希表）：1160.拼写单词"></a><strong>LeetCode练习（哈希表）：1160.拼写单词</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/17/剑指Offer——25.复制链表的复制/25_1160.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123;</span><br><span class="line">        if(words.size()==0 || chars.size()==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        map&lt;char,int&gt; mp;</span><br><span class="line">        for(int i=0;i&lt;chars.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[chars[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;words.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(words[i].size() &gt; chars.size())</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(words[i].begin(),words[i].end());</span><br><span class="line">            int target=0,count=0;</span><br><span class="line">            bool isRight=true;</span><br><span class="line">            for(int j=0;j&lt;words[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[words[i][j]]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    isRight=false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(words[i][j]==words[i][target])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(count&gt;mp[words[i][target]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        isRight=false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        target=j;</span><br><span class="line">                        count=1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&gt;mp[words[i][target]])</span><br><span class="line">            &#123;</span><br><span class="line">                isRight=false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isRight==true)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=words[i].size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：46-全排列"><a href="#LeetCode练习（数组）：46-全排列" class="headerlink" title="LeetCode练习（数组）：46.全排列"></a><strong>LeetCode练习（数组）：46.全排列</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;  res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        do&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;while(next_permutation(nums.begin(),nums.end()));</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：62-不同路径"><a href="#LeetCode练习（动态规划）：62-不同路径" class="headerlink" title="LeetCode练习（动态规划）：62.不同路径"></a><strong>LeetCode练习（动态规划）：62.不同路径</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/17/剑指Offer——25.复制链表的复制/25_62.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if(m&lt;=1 || n&lt;=1)</span><br><span class="line">           return 1;</span><br><span class="line">        int dp[n][m]=&#123;0&#125;;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[0][i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][0]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][m-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——24.二叉树中和为某一值得路径（22-695-f01.06）</title>
    <link href="http://hustxxj.github.io/2020/03/16/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9424.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E5%BE%97%E8%B7%AF%E5%BE%84/"/>
    <id>http://hustxxj.github.io/2020/03/16/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9424.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E5%BE%97%E8%B7%AF%E5%BE%84/</id>
    <published>2020-03-16T04:10:32.000Z</published>
    <updated>2020-03-18T04:45:48.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>利用递归实现：</p><ol><li>如果当前节点是叶子节点，且节点值等于目标值，则将该子数组放入最后的结果中</li><li>如果当前节点值小于目标值，但是还存在子节点，则迭代，目标值相应递减。</li></ol><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(root==nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;val == expectNumber &amp;&amp; root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        if(root-&gt;val &lt; expectNumber &amp;&amp; root-&gt;left!=nullptr)</span><br><span class="line">            FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        if(root-&gt;val &lt; expectNumber &amp;&amp; root-&gt;right!=nullptr)</span><br><span class="line">            FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组-深度优先遍历）：695-岛屿的最大面积"><a href="#LeetCode练习（数组-深度优先遍历）：695-岛屿的最大面积" class="headerlink" title="LeetCode练习（数组/深度优先遍历）：695.岛屿的最大面积"></a><strong>LeetCode练习（数组/深度优先遍历）：695.岛屿的最大面积</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_695.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>思路： 遍历数组，每当发现一个1，就从该元素出发搜索周围四个方向是否存在1，将该元素以及周围为1的元素都置0，顺便计数一共置0了多少个1（代表岛屿的面积）。遍历完后返回最大岛屿面积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int area;</span><br><span class="line">public:</span><br><span class="line">    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int rows=grid.size();</span><br><span class="line">        if(rows==0)</span><br><span class="line">           return 0;</span><br><span class="line">        int cols=grid[0].size();</span><br><span class="line">        if(cols==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;rows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;cols;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    area=0;</span><br><span class="line">                    find_1(grid,i,j);</span><br><span class="line">                    res=(area&gt;res)?area:res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void find_1(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int i,int j)</span><br><span class="line">    &#123;</span><br><span class="line">        if(grid[i][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j]=0;</span><br><span class="line">            area++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i-1&gt;=0 &amp;&amp; grid[i-1][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i-1,j);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i+1&lt;grid.size() &amp;&amp; grid[i+1][j]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i+1,j);</span><br><span class="line">        &#125;</span><br><span class="line">        if(j-1&gt;=0 &amp;&amp; grid[i][j-1]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i,j-1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(j+1&lt;grid[0].size() &amp;&amp; grid[i][j+1]==1)</span><br><span class="line">        &#123;</span><br><span class="line">            find_1(grid,i,j+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h1 id="LeetCode练习（字符串）：面试题01-06-字符串压缩"><a href="#LeetCode练习（字符串）：面试题01-06-字符串压缩" class="headerlink" title="LeetCode练习（字符串）：面试题01.06.字符串压缩"></a><strong>LeetCode练习（字符串）：面试题01.06.字符串压缩</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_f0106.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><p>数字转字符串 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss&lt;&lt;a;</span><br><span class="line">string str=ss.str();</span><br><span class="line">或</span><br><span class="line">int a=10;</span><br><span class="line">string str=to_string(a);</span><br></pre></td></tr></table></figure></p><p>字符串转数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int stoi(const strings str, size_t* pos = 0/*返回第一个无法转换的字符位置*/, int base = 10/*表示按10进制转换为整数*/)</span><br><span class="line">long stol(const strings str, size_t* pos = 0, int base = 10)</span><br><span class="line">float stof(const strings str, size_t* pos = 0)</span><br><span class="line">double stod(const strings str, size_t* pos = 0)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string compressString(string S) &#123;</span><br><span class="line">        int len=S.size();</span><br><span class="line">        if(len&lt;=1)</span><br><span class="line">          return S;</span><br><span class="line">        </span><br><span class="line">        int target=0;</span><br><span class="line">        int count=0;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(S[i]==S[target])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(S[target]);</span><br><span class="line">                res+=to_string(count);</span><br><span class="line">                target=i;</span><br><span class="line">                count=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(S[target]);</span><br><span class="line">        res+=to_string(count);</span><br><span class="line"></span><br><span class="line">        res=(res.size()&gt;=len)?S:res;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（回溯算法）：22-括号生成"><a href="#LeetCode练习（回溯算法）：22-括号生成" class="headerlink" title="LeetCode练习（回溯算法）：22.括号生成"></a><strong>LeetCode练习（回溯算法）：22.括号生成</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/16/剑指Offer——24.二叉树中和为某一值得路径/24_22.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><ol><li>在str中放入n个”()”</li><li>利用next_permutation对str进行全排列，然后检查每个排列是否合法（调用next_permutation之前先要对str进行sort排序，否则会出错）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if(n==0)</span><br><span class="line">           return res;</span><br><span class="line">        if(n==1)</span><br><span class="line">        &#123;</span><br><span class="line">            string ss=&quot;()&quot;;</span><br><span class="line">            res.push_back(ss);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ss=&quot;&quot;;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ss+=&quot;()&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ss.begin(),ss.end());</span><br><span class="line"></span><br><span class="line">        do&#123;</span><br><span class="line">            if(IsLegal(ss))</span><br><span class="line">               res.push_back(ss);</span><br><span class="line">        &#125;while(next_permutation(ss.begin(),ss.end()));</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool IsLegal(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        int len=str.size();</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==&apos;(&apos;)</span><br><span class="line">               count++;</span><br><span class="line">            else</span><br><span class="line">               count--;</span><br><span class="line">            </span><br><span class="line">            if(count&lt;0)</span><br><span class="line">               return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——23.二叉搜索树的后序遍历序列（6-34-300）</title>
    <link href="http://hustxxj.github.io/2020/03/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9423.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/14/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9423.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-14T11:43:59.000Z</published>
    <updated>2020-03-14T14:46:46.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><pre><code>采用自顶向下的方式进行运算如果vector是二叉搜索树的后续遍历序列，那么vector{a1,....,a2,b1,.....,b2,c1}一定满足a1~a2小于c1,b1~b2大于c1如果以上条件满足，那么再将a1~a2,b1~b2分别作为输入验证他们是否满足</code></pre><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool isFirstIn=true;</span><br><span class="line">public:</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">        int len=sequence.size();</span><br><span class="line">        if(len==0 &amp;&amp; isFirstIn==true)</span><br><span class="line">            return false;</span><br><span class="line">        if(len &lt;=2)</span><br><span class="line">            return true;</span><br><span class="line">        isFirstIn=false;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; left,right;</span><br><span class="line">        int root=sequence[len-1];</span><br><span class="line">        int ptr;</span><br><span class="line">        for(int i=0;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sequence[i] &lt; root)</span><br><span class="line">                left.push_back(sequence[i]);</span><br><span class="line">            if(sequence[i] &gt; root)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==len-2)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr=i+1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=ptr;i&lt;len-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sequence[i]&gt;root)</span><br><span class="line">                right.push_back(sequence[i]);</span><br><span class="line">            if(sequence[i]&lt;root)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return VerifySquenceOfBST(left) &amp;&amp; VerifySquenceOfBST(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：300-最长的上升子序列"><a href="#LeetCode练习（动态规划）：300-最长的上升子序列" class="headerlink" title="LeetCode练习（动态规划）：300.最长的上升子序列"></a><strong>LeetCode练习（动态规划）：300.最长的上升子序列</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_300.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>状态转移方程：设dp[n]表示从第n个数字往左，最长上升子序列的长度            则，dp[n]=max(dp[j])+1; 0&lt;=j&lt;n;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">           return len;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; dp(len,0);</span><br><span class="line">        for(int j=0;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=1;</span><br><span class="line">            for(int i=0;i&lt;j;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i] &lt; nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j]=max(dp[j],dp[i]+1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：6-Z字形变换"><a href="#LeetCode练习（字符串）：6-Z字形变换" class="headerlink" title="LeetCode练习（字符串）：6.Z字形变换"></a><strong>LeetCode练习（字符串）：6.Z字形变换</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_6.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convert(string s, int numRows) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        if(s==&quot;&quot; || numRows==0)</span><br><span class="line">           return res;</span><br><span class="line">        </span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len &lt;=numRows || numRows==1)</span><br><span class="line">           return s;</span><br><span class="line">        vector&lt;string&gt; ss(numRows);</span><br><span class="line">        bool isDown=true;</span><br><span class="line">        int stairs=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isDown==true)</span><br><span class="line">            &#123;</span><br><span class="line">                ss[stairs].push_back(s[i]);</span><br><span class="line">                stairs++;</span><br><span class="line">                if(stairs==numRows)</span><br><span class="line">                &#123;</span><br><span class="line">                    isDown=false;</span><br><span class="line">                    stairs-=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                ss[stairs].push_back(s[i]);</span><br><span class="line">                stairs--;</span><br><span class="line">                if(stairs&lt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    isDown=true;</span><br><span class="line">                    stairs+=2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=ss[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode练习（数组）：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode练习（数组）：34. 在排序数组中查找元素的第一个和最后一个位置"></a><strong>LeetCode练习（数组）：34. 在排序数组中查找元素的第一个和最后一个位置</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/14/剑指Offer——23.二叉搜索树的后序遍历序列/23_6.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;int&gt;::iterator it1=find(nums.begin(),nums.end(),target);</span><br><span class="line">        if(it1==nums.end())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(-1);</span><br><span class="line">            res.push_back(-1);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(it1-nums.begin());</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">        vector&lt;int&gt;::iterator it2=find(nums.begin(),nums.end(),target);</span><br><span class="line">        res.push_back(nums.size()-(it2-nums.begin())-1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Ye
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——22.从上往下打印二叉树（58-169-322）</title>
    <link href="http://hustxxj.github.io/2020/03/13/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9422.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://hustxxj.github.io/2020/03/13/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9422.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-13T08:46:04.000Z</published>
    <updated>2020-03-13T17:54:55.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>简单的利用队列实现</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt;  res;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">            return res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left!=nullptr)</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                if(temp-&gt;right!=nullptr)</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：169-多数元素"><a href="#LeetCode练习（数组）：169-多数元素" class="headerlink" title="LeetCode练习（数组）：169.多数元素"></a><strong>LeetCode练习（数组）：169.多数元素</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_169.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        int count=0;int target=nums[0];</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==target)</span><br><span class="line">               count++;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(count &gt; len/2)</span><br><span class="line">                   return target;</span><br><span class="line">                count=1;</span><br><span class="line">                target=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（动态规划）：322-零钱兑换"><a href="#LeetCode练习（动态规划）：322-零钱兑换" class="headerlink" title="LeetCode练习（动态规划）：322.零钱兑换"></a><strong>LeetCode练习（动态规划）：322.零钱兑换</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_322.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><pre><code>动态规划问题最重要的就是列出状态转移方程设dp[n]表示凑出n块钱，所需要的硬币个数最小值  那么就有dp[n]=min(dp[n-coin]+1)，即需要凑出n-coin块钱需要的硬币个数+1个面额为coin的硬币n=0时,dp[0]=0;n&lt;0时,dp[n]=-1;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        int num=coins.size();</span><br><span class="line">        if(num==0)</span><br><span class="line">           return -1;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(amount+1,amount+1);</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for(int i=0;i&lt;amount+1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;num;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i-coins[j] &lt; 0)</span><br><span class="line">                   continue;</span><br><span class="line">                dp[i]=min(dp[i-coins[j]]+1,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (dp[amount]==amount+1)?-1:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：58-最后一个单词的长度"><a href="#LeetCode练习（数组）：58-最后一个单词的长度" class="headerlink" title="LeetCode练习（数组）：58.最后一个单词的长度"></a><strong>LeetCode练习（数组）：58.最后一个单词的长度</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/13/剑指Offer——22.从上往下打印二叉树/22_58.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        int len=s.size();</span><br><span class="line">        if(len==0)</span><br><span class="line">           return 0;</span><br><span class="line">        </span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=len-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&apos; &apos;)</span><br><span class="line">               continue;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j=i;j&gt;=0;j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s[j]==&apos; &apos;)</span><br><span class="line">                      break;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;从上往下打印出二叉树的每个节点，同层节点从左至右打印。&lt;/p&gt;
&lt;hr&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer——21.栈的弹入弹出序列（38-283-1071）</title>
    <link href="http://hustxxj.github.io/2020/03/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9421.%E6%A0%88%E7%9A%84%E5%BC%B9%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://hustxxj.github.io/2020/03/12/%E5%89%91%E6%8C%87Offer%E2%80%94%E2%80%9421.%E6%A0%88%E7%9A%84%E5%BC%B9%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-12T08:37:14.000Z</published>
    <updated>2020-03-12T11:24:18.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><hr><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h1><hr><p>记录弹出序列中逆序的数量，当逆序数大于等于2时则表示该序列不可能是弹出序列。</p><hr><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        int num=pushV.size();</span><br><span class="line">        if(num==0)</span><br><span class="line">            return true;</span><br><span class="line">        if(num==1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pushV[0]!=popV[0])</span><br><span class="line">                return false;</span><br><span class="line">            else</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int reversetime=0;</span><br><span class="line">        for(int i=0;i&lt;num-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int a=popV[i];</span><br><span class="line">            int b=popV[i+1];</span><br><span class="line">            vector&lt;int&gt;::iterator ptra=find(pushV.begin(),pushV.end(),a);</span><br><span class="line">            vector&lt;int&gt;::iterator ptrb=find(pushV.begin(),pushV.end(),b);</span><br><span class="line">            if(ptra==pushV.end() || ptrb==pushV.end())</span><br><span class="line">                return false;</span><br><span class="line">            if((ptra-pushV.begin())&lt;(ptrb-pushV.begin()))</span><br><span class="line">                reversetime++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(reversetime&gt;=2)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（字符串）：1071-字符串的最大公因子"><a href="#LeetCode练习（字符串）：1071-字符串的最大公因子" class="headerlink" title="LeetCode练习（字符串）：1071.字符串的最大公因子"></a><strong>LeetCode练习（字符串）：1071.字符串的最大公因子</strong></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_1071.jpg" title="示例图"></code></p><hr><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string gcdOfStrings(string str1, string str2) &#123;</span><br><span class="line">        string res=&quot;&quot;;</span><br><span class="line">        int len1=str1.size();</span><br><span class="line">        int len2=str2.size();</span><br><span class="line">        int M=gcd(len1,len2);           //gcd(x,y)求x，y的最大公约数</span><br><span class="line">        for(int i=0;i&lt;M;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str1[i]==str2[i])</span><br><span class="line">               res.push_back(str1[i]);</span><br><span class="line">            else</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str1[i]!=res[i%M])</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str2[i]!=res[i%M])</span><br><span class="line">               return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：38-外观数列"><a href="#LeetCode练习（数组）：38-外观数列" class="headerlink" title="LeetCode练习（数组）：38.外观数列"></a><strong>LeetCode练习（数组）：38.外观数列</strong></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_38.jpg" title="示例图"></code></p><hr><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string res=&quot;1&quot;;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=transform(res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string transform(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        string res;</span><br><span class="line">        int len=str.size();</span><br><span class="line">        int ptr=0;</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]==str[ptr])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count+&apos;0&apos;);</span><br><span class="line">                res.push_back(str[ptr]);</span><br><span class="line">                ptr=i;</span><br><span class="line">                count=0;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(count+&apos;0&apos;);</span><br><span class="line">        res.push_back(str[ptr]);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode练习（数组）：283-移动零"><a href="#LeetCode练习（数组）：283-移动零" class="headerlink" title="LeetCode练习（数组）：283.移动零"></a><strong>LeetCode练习（数组）：283.移动零</strong></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><hr><p><code><img src="/2020/03/12/剑指Offer——21.栈的弹入弹出序列/21_283.jpg" title="示例图"></code></p><hr><h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">               count++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.push_back(0);</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                i--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹
      
    
    </summary>
    
    
      <category term="刷题" scheme="http://hustxxj.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="-剑指Offer" scheme="http://hustxxj.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
